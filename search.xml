<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【数据结构】树与二叉树复习</title>
      <link href="/2023/11/14/23-11-14/"/>
      <url>/2023/11/14/23-11-14/</url>
      
        <content type="html"><![CDATA[<h3 id="树的定义和基本术语"><a href="#树的定义和基本术语" class="headerlink" title="树的定义和基本术语"></a>树的定义和基本术语</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>树是n(n&gt;=0)个结点的有限集。</p><p>(1)<strong>有且仅有</strong>一个特定的称为根的结点</p><p>(2)n&gt;1时，其他结点可以分为m个不相交的有限集，其中每个集合也构成一颗树，称为根的子树。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>(1)树的根结点没有前驱，其他结点有且仅有一个前驱。</p><p>(2)树中任何一个结点可以有零或多个后继结点。</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>1.结点(node)</p><p>2.结点的度(degree)</p><p>3.树的度</p><p>4.叶子或终端结点</p><p>5.非终端结点</p><p>6.父(双)亲结点(parent)</p><p>7.儿(孩)子结点(child)</p><p>8.兄弟结点(sibling)</p><p>9.路径</p><p>10.祖先</p><p>11.子孙(后代)</p><p>12.结点的层数(level)</p><p>12.树的深度(depth)或高度</p><p>14.有序树和无序树</p><p>15.森林(forest): 是m(m&gt;=0)棵互不相交的树的集合</p><h4 id="树的表示方法"><a href="#树的表示方法" class="headerlink" title="树的表示方法"></a>树的表示方法</h4><p>1.图</p><p>2.嵌套集合</p><p>3.广义表形式： (A(B(D),C))</p><p>4.凹入表示法</p><h3 id="树的有关概念"><a href="#树的有关概念" class="headerlink" title="树的有关概念"></a>树的有关概念</h3><h4 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ADT Tree&#123;</span><br><span class="line">    数据对象D:D是具有相同特性的元素的集合。</span><br><span class="line">  数据关系R:若D为空集,则称为空树;否则:</span><br><span class="line">                  (<span class="number">1</span>)在D中存在唯一的称为根的数据元素，则R集为空;</span><br><span class="line">                (<span class="number">2</span>)当n&gt;<span class="number">1</span>时,其余结点n&gt;<span class="number">1</span>时，其他结点可以分为m个不相交的有限集，其中每个集合也是一颗符合本定义的树，称为根root的子树。</span><br><span class="line">  基本操作P:查找类、插入类、删除类操作。                                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树的基本操作类"><a href="#树的基本操作类" class="headerlink" title="树的基本操作类"></a>树的基本操作类</h4><p>查找类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Root(T)//求树的根结点</span><br><span class="line">Value(T,cur_e)//求当前结点的元素值</span><br><span class="line">Parent(T,cur_e)//求当前结点的双亲结点</span><br><span class="line">LeftChild(T,cur_e)//求当前结点的最左孩子</span><br><span class="line">RightSibling(T,cur_e)//求当前结点的右兄弟</span><br><span class="line">TreeEmpty(T)//判断树是否为空</span><br><span class="line">TreeDepth(T)//求树的高度</span><br><span class="line">TraverseTree(T,Visit())//遍历</span><br></pre></td></tr></table></figure><p>插入类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InitTree(&amp;T)//初始化置空树</span><br><span class="line">CreateTree(&amp;T,definition)//按定义构造树</span><br><span class="line">Assign(T,cur_e,value)//为当前结点赋值</span><br><span class="line">InsertChild(&amp;T,&amp;p,i,c)//将c为根的树插入为结点p的第i棵子树</span><br></pre></td></tr></table></figure><p>删除类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClearTree(&amp;T)//清空树</span><br><span class="line">DestroyTree(&amp;T)//销毁树的结构</span><br><span class="line">DeleteChild(&amp;T,&amp;p,i)删除结点p的第i棵子树</span><br></pre></td></tr></table></figure><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>二叉树(Binary Tree)是n(n&gt;=0)个结点的集合，这个集合可以是空集，可以是一个结点，或者是由一个根结点和两棵称为左子树和右子树的互不相交的二叉树组成。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>1.可以为空，即不含结点</p><p>2.每个结点至多有二棵子树(二叉树中不存在度大于2的结点)</p><p>3.二叉树是有序树，子树有左右之分，次序不能任意颠倒；允许有些结点只有左子树或右子树</p><h4 id="五种基本形态"><a href="#五种基本形态" class="headerlink" title="五种基本形态"></a>五种基本形态</h4><p>如图：<img src="/2023/11/14/23-11-14/树的五种基本形态.png" alt="image1"></p><h4 id="二叉树与树的区别"><a href="#二叉树与树的区别" class="headerlink" title="二叉树与树的区别"></a>二叉树与树的区别</h4><p>每个结点至多两个子树，且有左右之分</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>1.在二叉树的第i(i&gt;=1)层上至多有$2^{i-1}$个结点</p><p>2.深度为k的二叉树最多有$2^k$-1个结点</p><p>3.对任意二叉树T，如果终端结点数为n~0~(度数为0的结点树),n~1~,n~2~分别表示度数为1，2的结点个数，则n~0~=n~2~+1</p><p>满二叉树：</p><p>一个二叉树的叶子结点都在最后一层上，且不存在度数为1的结点</p><p>设高为k则有$2^k$-1个结点</p><p>特点：</p><p>1.对给定的高度，满二叉树有最多结点</p><p>2.不存在度为1的结点</p><p>3.每个分支都有两颗高度相同的子树</p><p>4.叶子结点都在最后一层</p><p>(重点)<strong>完全二叉树</strong>：如果存在一颗二叉树，对树中结点自上而下，自左而右连续编号，若编号为i的结点的位置与满二叉树中i的结点的位置相同，则称此二叉树为完全二叉树。</p><p>特点：</p><p>1.叶子结点只可能在<strong>层树最大的两层</strong>上出现</p><p>2.对任意结点，若有右子树则必有左子树</p><p>3.具有n个结点的完全二叉树深度为$\lfloor log_2n\rfloor$+1（向下取整）或者$\lceil log_2(n+1)\rceil$(向上取整)</p><p>4.对于一个具有n个结点的完全二叉树，其结点按层序编号，则对任意结点k~i~(1$\leq$i$\leq$n)：</p><p>已知编号i(1$\leq$i$\leq$n)，双亲结点是$\lfloor i/2 \rfloor$</p><p>已知编号i(1$\leq$i$\leq$n/2)，左孩子结点为2i</p><p>已知编号i(1$\leq$i$\leq$(n-1)/2)，左孩子结点为2i+1</p><p>已知编号i(i为奇数,且1&lt;i&lt;n),左兄弟结点为i-1</p><p>已知编号i(i为偶数,且1&lt;i&lt;n),左兄弟结点为i+1</p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>利用完全二叉树的性质，可以将完全二叉树存入向量b[n]中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE];</span><br><span class="line">SqBiTree bt;<span class="comment">//和TElemType bt[100]相同</span></span><br></pre></td></tr></table></figure><p><img src="/2023/11/14/23-11-14/顺序存储结构.png" alt="image2"></p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>31</td><td>23</td><td>12</td><td>66</td><td>$\emptyset$</td><td>05</td><td>17</td><td>70</td><td>62</td><td>$\O$</td><td>$\O$</td><td>$\O$</td><td>88</td><td>$\O$</td><td>55</td></tr></tbody></table></div><p>顺序存储方式对于畸形二叉树，浪费空间</p><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p>每个结点中，设置两个链域指向左孩子和右孩子，一个数据域，若没有左孩子或右孩子，则指针指向NULL</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TElemType</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lch</span>,*<span class="title">rch</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><p>n个结点的二叉树中，共有n+1个空域</p><p>二叉链表很难找到双亲</p><p>三叉链表(带双亲的二叉链表) 含四个域：数据域，左指针域，右指针域，双亲域</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TElemType</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lch</span>,*<span class="title">rch</span>,*<span class="title">parent</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><h4 id="二叉树的生成"><a href="#二叉树的生成" class="headerlink" title="二叉树的生成"></a>二叉树的生成</h4><p>递归创建</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BiTNode* <span class="title">CreateBiTree</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n, <span class="type">int</span> &amp;i,<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;size&amp;&amp;a[i]!=n)</span><br><span class="line">    &#123;</span><br><span class="line">        BiTNode* newNode = <span class="built_in">InitBtNode</span>(a[i]);</span><br><span class="line">        i++;</span><br><span class="line">        newNode-&gt;lch = <span class="built_in">CreateBiTree</span>(a, n, i,size);</span><br><span class="line">        i++;</span><br><span class="line">        newNode-&gt;rch = <span class="built_in">CreateBiTree</span>(a, n, i,size);</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestoryBiTree</span><span class="params">(BiTree &amp;root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span>==root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DestoryBiTree(root-&gt;lch);</span><br><span class="line">    DestoryBiTree(root-&gt;rch);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>样例：<img src="/2023/11/14/23-11-14/遍历例子.png" alt="image3"></p><h4 id="前序遍历-先根遍历"><a href="#前序遍历-先根遍历" class="headerlink" title="前序遍历(先根遍历)"></a>前序遍历(先根遍历)</h4><p>1.若二叉树为空，则返回；</p><p>若不空：</p><p>2.访问根结点；</p><p>3.前序遍历左子树</p><p>4.前序遍历右子树</p><p><strong>先根，再左，后右</strong></p><p>遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 4 8 9 5 10 11 3 6 12 7</span><br></pre></td></tr></table></figure><p>前序遍历的第一个结点的是根结点，最后一个结点一定是叶子结点。</p><h4 id="中序遍历-中根遍历"><a href="#中序遍历-中根遍历" class="headerlink" title="中序遍历(中根遍历)"></a>中序遍历(中根遍历)</h4><p>1.若二叉树空，返回；</p><p>若不空：</p><p>2.中序遍历左子树；</p><p>3.访问根结点；</p><p>4.中序遍历右子树。</p><p><strong>先左，再根，后右</strong></p><p>遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 4 9 2 10 5 11 1 12 6 3 7</span><br></pre></td></tr></table></figure><p>第一个结点是最左边的结点，最后一个结点是最右边的结点，根结点位于左子树结点和右子树结点之间。</p><h4 id="后序遍历-后根遍历"><a href="#后序遍历-后根遍历" class="headerlink" title="后序遍历(后根遍历)"></a>后序遍历(后根遍历)</h4><p>1.若二叉树空，返回；</p><p>若不空：</p><p>2.中序遍历左子树；</p><p>3.后序遍历右子树；</p><p>4.访问根结点。</p><p><strong>先左，再右，后根</strong></p><p>遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 9 4 10 11 5 2 12 6 7 3 1</span><br></pre></td></tr></table></figure><p>后序遍历中最后一个结点是根结点</p><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><h4 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h4><p>先序遍历：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">    visit(T-&gt;data);<span class="comment">//遍历操作，可以是打印该结点的值</span></span><br><span class="line">    PreOrder(T-&gt;lch);</span><br><span class="line">    PreOrder(T-&gt;rch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T)&#123;</span><br><span class="line">    InOrder(T-&gt;lch);</span><br><span class="line">    visit(T-&gt;data);</span><br><span class="line">    InOrder(T-&gt;rch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T)&#123;</span><br><span class="line">    PostOrder(T-&gt;lch);</span><br><span class="line">    PostOrder(T-&gt;rch);</span><br><span class="line">    visit(T-&gt;data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h4><p>先序遍历：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTNode *root)</span></span>&#123;</span><br><span class="line">  BiTNode *p,*BiNode[MAX];</span><br><span class="line">  <span class="type">int</span> top=<span class="number">0</span>;p=root;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">      BiNode[top]=p;</span><br><span class="line">      top++;</span><br><span class="line">      p=p-&gt;lch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      top--;</span><br><span class="line">      p=BiNode[top];</span><br><span class="line">      p=p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">while</span>(top&gt;<span class="number">0</span>||p!=<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder_N</span><span class="params">(BiTree root)</span></span>&#123;</span><br><span class="line">    BiTNode *p,*BiNode[MAX];</span><br><span class="line">    <span class="type">int</span> top=<span class="number">0</span>;p=root;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>(root))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BiTree Empty!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            BiNode[top]=p;</span><br><span class="line">            top++;</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            top--;</span><br><span class="line">            p=BiNode[top];</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            p=p-&gt;rch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(top&gt;<span class="number">0</span>||p!=<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder_N</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTNode *p, *lastVisited = <span class="literal">NULL</span>;</span><br><span class="line">    BiTNode *stack[MAX];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>; <span class="comment">// 栈顶位置下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || top &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stack[++top] = p;</span><br><span class="line">            p = p-&gt;lch;</span><br><span class="line">        &#125;</span><br><span class="line">        p = stack[top];</span><br><span class="line">        <span class="comment">// 判断右子树是否已经访问过</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rch == <span class="literal">NULL</span> || p-&gt;rch == lastVisited)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            lastVisited = p;</span><br><span class="line">            top--;</span><br><span class="line">            p = <span class="literal">NULL</span>; <span class="comment">// 置空，防止重复访问</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;rch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="二叉树的其他操作"><a href="#二叉树的其他操作" class="headerlink" title="二叉树的其他操作"></a>二叉树的其他操作</h4><p>判断树是否空：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">(BiTree root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问结点操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(TElemType data)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,data.key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求结点数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">NodesNum</span><span class="params">(BiTNode *b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">NodesNum</span>(b-&gt;lch)+<span class="built_in">NodesNum</span>(b-&gt;rch)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求叶子结点数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LeafNodesNum</span><span class="params">(BiTNode *b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b-&gt;lch==<span class="literal">NULL</span>&amp;&amp;b-&gt;rch==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        num1=<span class="built_in">LeafNodesNum</span>(b-&gt;lch);</span><br><span class="line">        num2=<span class="built_in">LeafNodesNum</span>(b-&gt;rch);</span><br><span class="line">        <span class="keyword">return</span> (num1+num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制树的操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Copy</span><span class="params">(BiTNode *b,BiTNode *&amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>) t=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        t=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        t-&gt;data=b-&gt;data;</span><br><span class="line">        <span class="built_in">Copy</span>(b-&gt;lch, t-&gt;lch);</span><br><span class="line">        <span class="built_in">Copy</span>(b-&gt;rch,t-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交换左右子树：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(BiTNode *b,BiTNode *&amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>) t=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        t=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        t-&gt;data=b-&gt;data;</span><br><span class="line">        <span class="built_in">Swap</span>(b-&gt;lch, t-&gt;lch);</span><br><span class="line">        <span class="built_in">Swap</span>(b-&gt;rch,t-&gt;rch);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>求树的高度：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(BiTree t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tl,tr;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    tl=<span class="built_in">height</span>(t-&gt;lch);</span><br><span class="line">    tr=<span class="built_in">height</span>(t-&gt;rch);</span><br><span class="line">    <span class="keyword">if</span>(tl&gt;=tr) <span class="keyword">return</span> tl+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> tr+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>给定遍历序列是否可以确定树的唯一结构？</p><p>只给出一个序列，无法确定树的唯一结构</p><p>给出前序和后序序列，无法确定唯一的二叉树</p><p>给出中序和后序序列，可以确定唯一的二叉树</p><p>给出中序和前序序列，可以确定唯一的二叉树</p><p>问题：给出前序和中序序列，如何构建二叉树？</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateTree</span><span class="params">(BiTree &amp;T,<span class="type">int</span> root,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">char</span> *m,<span class="type">char</span> *n)</span>   <span class="comment">//创建二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T=(BiNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiNode));</span><br><span class="line">    <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=start;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;end&amp;&amp;n[i]!=m[root])</span><br><span class="line">        i++;</span><br><span class="line">    T-&gt;data=n[i];</span><br><span class="line">    <span class="built_in">CreateTree</span>(T-&gt;lch,root+<span class="number">1</span>,start,i<span class="number">-1</span>,m,n);</span><br><span class="line">    <span class="built_in">CreateTree</span>(T-&gt;rch,root+<span class="number">1</span>+i-start,i+<span class="number">1</span> ,end,m,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>既可以指示前驱又可以指示后继的双链结构的二叉树称为线索二叉树</p><p>若结点有左子树，则lch指示左孩子，否则指示其前驱</p><p>若结点有右子树，则rch指示其右孩子，否则指示其后继</p><h4 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构"></a>结点结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    datatype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lch</span>,*<span class="title">rch</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;threadbithptr,*BiThrTree;</span><br></pre></td></tr></table></figure><p>ltag=0 lch指向左孩子 ltag=1 lch指向前驱</p><p>ltag=0 rch指向右孩子 ltag=1 rch指向后继</p><h4 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h4><p>存储结构：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> *lch,*rch;</span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;threadbithptr,*BiThrTree;</span><br><span class="line">BiThrTree pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中序线索化：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        <span class="built_in">InThreading</span>(p-&gt;lch);</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;lch)&#123;</span><br><span class="line">            p-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">            p-&gt;lch=pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;rch)&#123;</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">            pre-&gt;rch=p;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;</span><br><span class="line">        <span class="built_in">InThreading</span>(p-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderThreading</span><span class="params">(BiThrTree &amp;Thrt,BiThrTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(Thrt=(threadbithptr*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(threadbithptr))))&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Thrt-&gt;ltag=<span class="number">0</span>;</span><br><span class="line">    Thrt-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    Thrt-&gt;rch=Thrt;</span><br><span class="line">    <span class="keyword">if</span>(!T)&#123;</span><br><span class="line">        Thrt-&gt;lch=Thrt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Thrt-&gt;lch=T;</span><br><span class="line">        pre=Thrt;</span><br><span class="line">        <span class="built_in">InThreading</span>(T);</span><br><span class="line">        pre-&gt;rch=Thrt;</span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">        Thrt-&gt;rch=pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中序线索树中查找结点*p的后继：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">threadbithptr* <span class="title">InOrderNext</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    threadbithptr *q;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q=p-&gt;rch;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">            q=q-&gt;lch;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraverseInthread</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            p=<span class="built_in">InOrderNext</span>(p);</span><br><span class="line">        &#125;<span class="keyword">while</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中序线索树中查找结点*p的前驱：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">threadbithptr* <span class="title">InOrderPre</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    threadbithptr *q;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;lch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q=p-&gt;lch;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">            q=q-&gt;rch;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历中序线索二叉树的非递归算法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraverseInthread</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            p=<span class="built_in">InOrderNext</span>(p);</span><br><span class="line">        &#125;<span class="keyword">while</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><h5 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h5><p>采用一组连续空间存储树的结点，通过保存每个结点的双亲结点的位置，表示树中结点关系的位置结构。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br></pre></td></tr></table></figure><h5 id="孩子链表表示法"><a href="#孩子链表表示法" class="headerlink" title="孩子链表表示法"></a>孩子链表表示法</h5><p>对树的每个结点用线性链表存储它的孩子结点。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CTNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> child;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">CTNode</span> *next;</span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">  <span class="type">int</span> parent;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  CTBox nodes[MAX];</span><br><span class="line">  <span class="type">int</span> n,r;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><h5 id="带双亲的孩子链表表示法"><a href="#带双亲的孩子链表表示法" class="headerlink" title="带双亲的孩子链表表示法"></a>带双亲的孩子链表表示法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CTNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> child;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">CTNode</span> *next;</span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">  <span class="type">int</span> parent;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  CTBox nodes[MAX];</span><br><span class="line">  <span class="type">int</span> n,r;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><h5 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CSNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CSNode</span> *firstchild,*firstbrother;</span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><h4 id="树、森林与二叉树的转化"><a href="#树、森林与二叉树的转化" class="headerlink" title="树、森林与二叉树的转化"></a>树、森林与二叉树的转化</h4><h5 id="树到二叉树"><a href="#树到二叉树" class="headerlink" title="树到二叉树"></a>树到二叉树</h5><p>1)在所有兄弟结点之间加一条连线。</p><p>2)对每个结点，除了保留与其长子的连线外，去掉该结点与其他孩子的连线。</p><h5 id="森林到二叉树"><a href="#森林到二叉树" class="headerlink" title="森林到二叉树"></a>森林到二叉树</h5><p>1)将森林中的每一棵树转化为二叉树</p><p>2)将各二叉树的根结点视为兄弟连在一起</p><h4 id="树的遍历-1"><a href="#树的遍历-1" class="headerlink" title="树的遍历"></a>树的遍历</h4><p>一般不中序遍历</p><p>两条路径：从左到右、从上到下</p><p><strong>树的前序遍历</strong>与转换成<strong>二叉树的前序遍历</strong>相同</p><p><strong>树的后序遍历</strong>与转换成<strong>二叉树的中序遍历</strong>相同</p><h3 id="赫夫曼树及其应用"><a href="#赫夫曼树及其应用" class="headerlink" title="赫夫曼树及其应用"></a>赫夫曼树及其应用</h3><p>基本概念</p><p>路径长度：路径上边的个数</p><p>树的路径长度：从根结点出发，到所有结点的路径长度之和</p><p>结点的带权路径长度：结点到根结点的长度与权重的乘积</p><p>树的带权路径长度：所有叶子结点的带权路径长度之和</p><h4 id="赫夫曼树的定义"><a href="#赫夫曼树的定义" class="headerlink" title="赫夫曼树的定义"></a>赫夫曼树的定义</h4><p>最优二叉树，给定叶结点权重，具有最小带权路径长度的二叉树。</p><h4 id="构造赫夫曼树-赫夫曼算法"><a href="#构造赫夫曼树-赫夫曼算法" class="headerlink" title="构造赫夫曼树(赫夫曼算法)"></a>构造赫夫曼树(赫夫曼算法)</h4><p>基本思想：使权值大的叶子结点尽量靠近根节点，而使权值小的叶子结点尽量远离根结点</p><p>将给定的一些叶子结点中取出两个最小的叶子作为一个结点的左孩子和右孩子，然后将它们的权值相加，从剩下的叶子中寻找最小的结点作为上面结点的兄弟，重复此操作。</p><p>n个叶结点，按上述操作，构造的树中含有2n-1个结点。</p><p><img src="/2023/11/14/23-11-14/赫夫曼树构造.png" alt="image4"></p><p>huffman算法实现：</p><p>主函数先给n，m赋值。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">    <span class="type">int</span> lch,rch,parent;</span><br><span class="line">&#125;hufmtree;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateHuffmanTree</span><span class="params">(hufmtree tree[])</span></span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        tree[i].weight=<span class="number">0.0</span>;</span><br><span class="line">        tree[i].lch=<span class="number">-1</span>;</span><br><span class="line">        tree[i].rch=<span class="number">-1</span>;</span><br><span class="line">        tree[i].parent=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputWeight</span><span class="params">(hufmtree tree[])</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> w;</span><br><span class="line">    <span class="type">float</span> small1,small2,f;</span><br><span class="line">    <span class="type">int</span> i,j,p1,p2;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n输入第%d个权值:&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;w);</span><br><span class="line">        tree[i].weight=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&lt;m;i++)&#123;<span class="comment">//把合并后的结点放入n～m向量</span></span><br><span class="line">        p1=<span class="number">0</span>;p2=<span class="number">0</span>;    <span class="comment">//两个根结点在tree中的下标</span></span><br><span class="line">        small1=MAXFLOAT;<span class="comment">//MAXFLOAT为最大浮点数</span></span><br><span class="line">        small2=MAXFLOAT;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i<span class="number">-1</span>;j++)&#123;<span class="comment">//选择两个最小的权</span></span><br><span class="line">            <span class="keyword">if</span>(tree[j].parent==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tree[j].weight&lt;small1)&#123;</span><br><span class="line">                    small2=small1;<span class="comment">//更新最小权，次小权，及其位置</span></span><br><span class="line">                    small1=tree[j].weight;<span class="comment">//找出最小权</span></span><br><span class="line">                    p2=p1;</span><br><span class="line">                    p1=j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tree[j].weight&lt;small2)&#123;</span><br><span class="line">                    small2=tree[j].weight;<span class="comment">//改变次小权及位置</span></span><br><span class="line">                    p2=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[p1].parent=i+<span class="number">1</span>;</span><br><span class="line">        tree[p2].parent=i+<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//将新生成的结点放在tree[i+1]</span></span><br><span class="line">        tree[i+<span class="number">1</span>].lch=p1;</span><br><span class="line">        tree[i+<span class="number">1</span>].rch=p2;</span><br><span class="line">        tree[i+<span class="number">1</span>].weight=tree[p1].weight+tree[p1].weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h4><p>1)首先构造出赫夫曼树</p><p>2)每个结点的左分支计0 右分支计1，从根结点到叶子结点的沿途路径分支组成的01代码串即赫夫曼编码</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>个人博客基本部署成功！</title>
      <link href="/2023/11/09/successcd-blog-lincoxi/"/>
      <url>/2023/11/09/successcd-blog-lincoxi/</url>
      
        <content type="html"><![CDATA[<p>11.09日我的博客基本部署成功了，有一些基本的美化功能（借鉴各路大佬）<br>接下来预计将会逐步完善各项功能，留言板已开，可以多多留言<br>预计接下来会发布内容关于：<br>1.ctf题目/工具解答 本人misc做的多点，预计一个月内发布一篇misc工具合集介绍。<br>2.学校的课程内容，主要是为了复习+记录。<br>3.个人日常板块还没做，迟早会发。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>a basic test</title>
      <link href="/2023/11/09/a-basic-test/"/>
      <url>/2023/11/09/a-basic-test/</url>
      
        <content type="html"><![CDATA[<p>test test tes</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>今日测试</title>
      <link href="/2023/11/09/11-9work/"/>
      <url>/2023/11/09/11-9work/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="314b778ccd1012cad8846435536f091270f2b36b97591be73fd3ae3f00163cdd">10d79030e8222445804370796b90fca18d3af0ca0aed65002f2d27e5161276f9a34ce6f47914fa2d3c77a4530036ebbf49392c613893bc04a4747ee94fb4d5f88c16dc93152c4f00c0ef25a2ae27d29cd3b7a1c8f2dba4224c6e826413ea97a1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>work_12.11</title>
      <link href="/2023/11/09/work-12-11/"/>
      <url>/2023/11/09/work-12-11/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4237b5ab9b62ff40e91ec2f2339630465adbd8b2917c54802b887802653cdc78">01c5434afc057ec70c0b06aa0591fac6feaac8ea76c74c2a16a82314c7311e3d7a8f6737cf7b5c9038c6896dbf539075414845885f166cbc4c60fc4e2685be30b483fc1b39384fa2edc582211d27467ff62aac53660ebd6b7cbe4aff2b8872e220eb40bd790ff5838c8e22b6a2b2e12cafa1ba3d29e51f2b55cbeab4c022e21298cf2583bbf44aa28cd5bb30cdc842aa07134361303d2e403741d7cee9bc62af</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">需要密码！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test4blog</title>
      <link href="/2023/11/08/test4blog/"/>
      <url>/2023/11/08/test4blog/</url>
      
        <content type="html"><![CDATA[<p>This is a test for lincoxi to test if his blog works ok.</p><p>My github account is cyan4run. It’s easy to recongnize.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/08/hello-world/"/>
      <url>/2023/11/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
