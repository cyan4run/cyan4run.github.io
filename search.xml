<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【数据结构】 查找</title>
      <link href="/2023/11/21/23-11-21-2/"/>
      <url>/2023/11/21/23-11-21-2/</url>
      
        <content type="html"><![CDATA[<p>本节的哈希散列技术还有待进一步掌握</p><h3 id="查找的前置知识"><a href="#查找的前置知识" class="headerlink" title="查找的前置知识"></a>查找的前置知识</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>1.查找表：同一类型的数据元素或记录构成的集合</p><p>2.静态查找表：仅作查询和检索操作的查找表</p><p>3.动态查找表：在查找时包含插入、删除或修改</p><p>4.主关键字：可以识别的一个记录的数据项(字段)</p><p>5.次关键字：关联若干记录的数据项（字段）</p><p>6.根据给定的某个值，在查找表中确定一个群关键字等于给定值的数据元素(记录)</p><p>7.查找成功：查找表中存在满足条件的记录</p><p>8.查找不成功：查找表中不存在满足条件的记录</p><h4 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> Keytype; <span class="comment">//Keytype为浮点数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Keytype;<span class="comment">//Keytype为整型数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> Keytype;<span class="comment">//Keytype为字符指针数据类型</span></span><br></pre></td></tr></table></figure><p>数据元素定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">Keytype key;<span class="comment">//关键字</span></span><br><span class="line">... <span class="comment">//可以是其他关键字</span></span><br><span class="line">&#125;ElemType;<span class="comment">//ElemType结构体数据类型</span></span><br></pre></td></tr></table></figure><h4 id="查找的分类"><a href="#查找的分类" class="headerlink" title="查找的分类"></a>查找的分类</h4><p>1.基于关键词比较的查找：顺序查找、折半查砸后、分块查找、BST&amp;AVL、B-树和B+树</p><p>2.基于关键字存储位置的查找：散列法</p><p>根据被查找的数据集合存储位置又分为：</p><p>1.内查找：整个查找过程都在内存进行</p><p>2.外查找：查找过程中需要访问外存</p><h3 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h3><h4 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h4><h5 id="静态查找表的抽象数据类型"><a href="#静态查找表的抽象数据类型" class="headerlink" title="静态查找表的抽象数据类型"></a>静态查找表的抽象数据类型</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ADT StaticSearchTable&#123;</span><br><span class="line">数据对象D：D是具有相同特性的数据元素的集合。每个数据元素含有类型相同的关键字，可唯一表示数据元素。</span><br><span class="line">数据关系R：数据元素同属一个集合</span><br><span class="line">基本操作P：</span><br><span class="line"><span class="built_in">Create</span>(&amp;ST,n);<span class="comment">//建立静态查找表</span></span><br><span class="line"><span class="built_in">Destroy</span>(&amp;ST);<span class="comment">//销毁静态查找表</span></span><br><span class="line"><span class="built_in">Search</span>(ST,key)<span class="comment">//按关键字key查找</span></span><br><span class="line"><span class="built_in">Traverse</span>(ST,<span class="built_in">visit</span>());<span class="comment">//遍历查找表</span></span><br><span class="line"><span class="comment">//插入、删除操作，在顺序表中不适合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="顺序查找表的存储结构"><a href="#顺序查找表的存储结构" class="headerlink" title="顺序查找表的存储结构"></a>顺序查找表的存储结构</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br></pre></td></tr></table></figure><h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=key;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=ST.length;ST.elem[i].key!=key;i--);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">    <span class="comment">//若返回非0，则找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    ST.length=<span class="number">10</span>;</span><br><span class="line">    ST.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*(ST.length+<span class="number">1</span>));</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=<span class="literal">NULL</span>;</span><br><span class="line">    ST.elem[<span class="number">1</span>].key=<span class="number">1</span>;</span><br><span class="line">    ST.elem[<span class="number">2</span>].key=<span class="number">5</span>;</span><br><span class="line">    ST.elem[<span class="number">3</span>].key=<span class="number">3</span>;</span><br><span class="line">    ST.elem[<span class="number">4</span>].key=<span class="number">9</span>;</span><br><span class="line">    ST.elem[<span class="number">5</span>].key=<span class="number">10</span>;</span><br><span class="line">    ST.elem[<span class="number">6</span>].key=<span class="number">14</span>;</span><br><span class="line">    ST.elem[<span class="number">7</span>].key=<span class="number">2</span>;</span><br><span class="line">    ST.elem[<span class="number">8</span>].key=<span class="number">12</span>;</span><br><span class="line">    ST.elem[<span class="number">9</span>].key=<span class="number">19</span>;</span><br><span class="line">    ST.elem[<span class="number">10</span>].key=<span class="number">17</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search_Seq</span>(ST, <span class="number">13</span>));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><p>进行比较的关键字个数的期望值： 即查找成功时的平均查找长度</p><script type="math/tex; mode=display">ASL=\sum_{i=1}^{n}P_iC_i</script><p>其中n为表长</p><p>$P_i$为查找表中第i个记录被查找的概率</p><p>$C_i$为找到记录i时关键字的比较次数</p><p>在等概率查找情况下，$P_i=\frac{1}{n}$</p><p>顺序表的平均(成功)查找长度为：$ASL_{ss}=\frac{1}{n}\sum_{i=1}^n(n-i+1)=\frac{n+1}{2}$</p><p>在不等概率查找的情况下，ASL在$P_n\geqslant P_{n-1}\geqslant …\geqslant P_2 \geqslant P_1$ 时取最小值</p><p>$ASL_{失败}=n+1$</p><h4 id="有序表的查找"><a href="#有序表的查找" class="headerlink" title="有序表的查找"></a>有序表的查找</h4><h5 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h5><p>前提要求：顺序存储且有序</p><h5 id="折半查找的思想"><a href="#折半查找的思想" class="headerlink" title="折半查找的思想"></a>折半查找的思想</h5><p>1.将要查找的关键字与查找表中间的元素的关键字进行比较，若相等，返回当前位置</p><p>2.若查找关键字比当前位置关键字小，向前秭归，否则向后递归</p><h5 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> high=ST.length;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(ST.elem[mid].key==key) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ST.elem[mid].key&gt;key)&#123;</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low=mid+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="comment">//折半查找，有序表；</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    ST.length=<span class="number">10</span>;</span><br><span class="line">    ST.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*(ST.length+<span class="number">1</span>));</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=<span class="literal">NULL</span>;</span><br><span class="line">    ST.elem[<span class="number">1</span>].key=<span class="number">1</span>;</span><br><span class="line">    ST.elem[<span class="number">2</span>].key=<span class="number">3</span>;</span><br><span class="line">    ST.elem[<span class="number">3</span>].key=<span class="number">5</span>;</span><br><span class="line">    ST.elem[<span class="number">4</span>].key=<span class="number">7</span>;</span><br><span class="line">    ST.elem[<span class="number">5</span>].key=<span class="number">9</span>;</span><br><span class="line">    ST.elem[<span class="number">6</span>].key=<span class="number">10</span>;</span><br><span class="line">    ST.elem[<span class="number">7</span>].key=<span class="number">12</span>;</span><br><span class="line">    ST.elem[<span class="number">8</span>].key=<span class="number">14</span>;</span><br><span class="line">    ST.elem[<span class="number">9</span>].key=<span class="number">20</span>;</span><br><span class="line">    ST.elem[<span class="number">10</span>].key=<span class="number">21</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search_Bin</span>(ST, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>折半查找只适用于静态查找</p><h5 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h5><p>时间复杂度为$O(\log_2n)$</p><p>对于n个元素，二分查找，成功最多关键字比较次数为$\lceil log_2(n+1)\rceil$（向上取整），不成功的关键字比较次数为：$\lceil log_2(n+1)\rceil$</p><h5 id="折半查找的递归实现"><a href="#折半查找的递归实现" class="headerlink" title="折半查找的递归实现"></a>折半查找的递归实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinSearch2</span><span class="params">(SSTable ST,<span class="type">int</span> low,<span class="type">int</span> high,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;ST.elem[mid].key)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BinSearch2</span>(ST, low, mid<span class="number">-1</span>, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;ST.elem[mid].key)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BinSearch2</span>(ST, mid+<span class="number">1</span>, high, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    ST.length=<span class="number">10</span>;</span><br><span class="line">    ST.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*(ST.length+<span class="number">1</span>));</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=<span class="literal">NULL</span>;</span><br><span class="line">    ST.elem[<span class="number">1</span>].key=<span class="number">1</span>;</span><br><span class="line">    ST.elem[<span class="number">2</span>].key=<span class="number">3</span>;</span><br><span class="line">    ST.elem[<span class="number">3</span>].key=<span class="number">5</span>;</span><br><span class="line">    ST.elem[<span class="number">4</span>].key=<span class="number">7</span>;</span><br><span class="line">    ST.elem[<span class="number">5</span>].key=<span class="number">9</span>;</span><br><span class="line">    ST.elem[<span class="number">6</span>].key=<span class="number">10</span>;</span><br><span class="line">    ST.elem[<span class="number">7</span>].key=<span class="number">12</span>;</span><br><span class="line">    ST.elem[<span class="number">8</span>].key=<span class="number">14</span>;</span><br><span class="line">    ST.elem[<span class="number">9</span>].key=<span class="number">20</span>;</span><br><span class="line">    ST.elem[<span class="number">10</span>].key=<span class="number">21</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">BinSearch2</span>(ST, <span class="number">1</span>,<span class="number">10</span>,<span class="number">9</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="索引顺序表的查找"><a href="#索引顺序表的查找" class="headerlink" title="索引顺序表的查找"></a>索引顺序表的查找</h4><h5 id="索引顺序表的存储要求"><a href="#索引顺序表的存储要求" class="headerlink" title="索引顺序表的存储要求"></a>索引顺序表的存储要求</h5><p>两张表 一张线性表 一张索引表</p><p>线性表要求：查找表分为n块，当i&gt;j时，第i块中的最小元素的关键字大于第j块中的最大元素的关键字</p><p>索引表要求：1.索引表是顺序存储 2.索引表里存储了各个块的最大值和开始地址</p><h5 id="索引顺序表的查找思想"><a href="#索引顺序表的查找思想" class="headerlink" title="索引顺序表的查找思想"></a>索引顺序表的查找思想</h5><p>1.首先确定所要查找的关键字在哪一块</p><p>2.在所确定的块中用顺序查找查找关键字</p><h5 id="索引表的存储结构"><a href="#索引表的存储结构" class="headerlink" title="索引表的存储结构"></a>索引表的存储结构</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> maxblock 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  KeyType key;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">&#125;indextype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  indextype index[maxblock];</span><br><span class="line">  <span class="type">int</span> block;</span><br><span class="line">&#125;INtable;</span><br></pre></td></tr></table></figure><h5 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  索引顺序表</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 徐可钊 on 2023/11/20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxblock 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  KeyType key;</span><br><span class="line">    <span class="type">int</span> addr;</span><br><span class="line">&#125;indextype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  indextype index[maxblock];</span><br><span class="line">  <span class="type">int</span> block;</span><br><span class="line">&#125;INtable;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search</span><span class="params">(SSTable ST,INtable IX,KeyType key )</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,s=<span class="number">0</span>,e;</span><br><span class="line">    <span class="comment">//s记录查找表中的开始位置</span></span><br><span class="line">    <span class="comment">//e记录查找表中的结束位置</span></span><br><span class="line">    <span class="keyword">while</span>((key&gt;IX.index[i].key)&amp;&amp;(i&lt;IX.block))&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;IX.block)&#123;</span><br><span class="line">        s=IX.index[i].addr;</span><br><span class="line">        <span class="keyword">if</span>(i==IX.block<span class="number">-1</span>) e=ST.length;</span><br><span class="line">        <span class="keyword">else</span> e=IX.index[i+<span class="number">1</span>].addr<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(key!=ST.elem[s].key&amp;&amp;s&lt;=e)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s&lt;=e) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    ST.length=<span class="number">10</span>;</span><br><span class="line">    ST.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(KeyType)*(ST.length+<span class="number">1</span>));</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=<span class="number">22</span>;</span><br><span class="line">    ST.elem[<span class="number">1</span>].key=<span class="number">12</span>;</span><br><span class="line">    ST.elem[<span class="number">2</span>].key=<span class="number">9</span>;</span><br><span class="line">    ST.elem[<span class="number">3</span>].key=<span class="number">20</span>;</span><br><span class="line">    <span class="comment">//==========</span></span><br><span class="line">    ST.elem[<span class="number">4</span>].key=<span class="number">33</span>;</span><br><span class="line">    ST.elem[<span class="number">5</span>].key=<span class="number">42</span>;</span><br><span class="line">    ST.elem[<span class="number">6</span>].key=<span class="number">48</span>;</span><br><span class="line">    <span class="comment">//==========</span></span><br><span class="line">    ST.elem[<span class="number">7</span>].key=<span class="number">49</span>;</span><br><span class="line">    ST.elem[<span class="number">8</span>].key=<span class="number">60</span>;</span><br><span class="line">    ST.elem[<span class="number">9</span>].key=<span class="number">86</span>;</span><br><span class="line">    ST.elem[<span class="number">10</span>].key=<span class="number">53</span>;</span><br><span class="line">    INtable IX;</span><br><span class="line">    IX.block=<span class="number">3</span>;</span><br><span class="line">    IX.index[<span class="number">0</span>].key=<span class="number">22</span>;</span><br><span class="line">    IX.index[<span class="number">0</span>].addr=<span class="number">0</span>;</span><br><span class="line">    IX.index[<span class="number">1</span>].key=<span class="number">48</span>;</span><br><span class="line">    IX.index[<span class="number">1</span>].addr=<span class="number">4</span>;</span><br><span class="line">    IX.index[<span class="number">2</span>].key=<span class="number">86</span>;</span><br><span class="line">    IX.index[<span class="number">2</span>].addr=<span class="number">7</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search</span>(ST, IX, <span class="number">53</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search</span>(ST, IX, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search</span>(ST, IX, <span class="number">49</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h5><p>如果索引表长度为b，每块平均程度为L 平均查找长度为：$(b+1)/2+(L+1)/2$</p><p>长度为n的线性表，平均分为$\sqrt n$  查找次数最少</p><h3 id="动态查找表"><a href="#动态查找表" class="headerlink" title="动态查找表"></a>动态查找表</h3><h4 id="二叉排序树和平衡二叉树"><a href="#二叉排序树和平衡二叉树" class="headerlink" title="二叉排序树和平衡二叉树"></a>二叉排序树和平衡二叉树</h4><h5 id="二叉排序树的定义"><a href="#二叉排序树的定义" class="headerlink" title="二叉排序树的定义"></a>二叉排序树的定义</h5><p>二叉排序树(Binary Sort Tree)或者是一颗空树；或者是具有下列性质的二叉树：若根结点有左子树，则左子树上所有结点关键字的值均小于根结点的关键字的值；若根结点有右子树，则右子树上所有结点关键字的值均大结点的关键字的值；根结点的左右子树也分别为二叉排序树。</p><h5 id="二叉排序树的结点查找"><a href="#二叉排序树的结点查找" class="headerlink" title="二叉排序树的结点查找"></a>二叉排序树的结点查找</h5><p>例：<img src="/2023/11/21/23-11-21-2/二叉排序树的例子.png" alt="二叉排序树例子"><br>查找思想：</p><p>1.当二叉排序树不空时，先将给定值和根结点的关键字比较，若相等，则查找成功；否则：</p><p>2.若给定值小于根结点的关键字，则在左子树上继续进行查砸后</p><p>3.若给定值大于根结点的关键字，则在右子树上继续进行查找</p><p>4.直到找到或查到空结点为止。</p><p>存储结构</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    <span class="comment">//  其他信息</span></span><br><span class="line">&#125;TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lch,*rch;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span>* <span class="built_in">createNode</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span>* newNode = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BiTNode));</span><br><span class="line">    newNode-&gt;data.key = value;</span><br><span class="line">    newNode-&gt;lch = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;rch = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BiTree T=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;data.key=<span class="number">45</span>;</span><br><span class="line">    T-&gt;lch=<span class="built_in">createNode</span>(<span class="number">12</span>);</span><br><span class="line">    T-&gt;lch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">3</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">37</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">24</span>);</span><br><span class="line">    T-&gt;rch=<span class="built_in">createNode</span>(<span class="number">53</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">100</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">61</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">90</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">78</span>);</span><br><span class="line">    <span class="comment">//创建了如图的二叉排序树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>算法实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    <span class="comment">//  其他信息</span></span><br><span class="line">&#125;TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lch,*rch;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span>* <span class="built_in">createNode</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span>* newNode = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BiTNode));</span><br><span class="line">    newNode-&gt;data.key = value;</span><br><span class="line">    newNode-&gt;lch = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;rch = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BiTree <span class="title">SearchBST</span><span class="params">(BiTree T,KeyType key)</span></span>&#123;</span><br><span class="line">    BiTree p=T;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data.key==key)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;p-&gt;data.key)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">else</span> p=p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BiTree T=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;data.key=<span class="number">45</span>;</span><br><span class="line">    T-&gt;lch=<span class="built_in">createNode</span>(<span class="number">12</span>);</span><br><span class="line">    T-&gt;lch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">3</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">37</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">24</span>);</span><br><span class="line">    T-&gt;rch=<span class="built_in">createNode</span>(<span class="number">53</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">100</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">61</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">90</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">78</span>);</span><br><span class="line">    <span class="comment">//创建了如图的二叉排序树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">SearchBST</span>(T, <span class="number">24</span>)-&gt;data.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>算法分析</p><p>1.二叉排序树平均查找长度的嘴擦情况与顺序表相同（关键字有序）为$O(n)$</p><p>2.最好情况与折半查找相同，是$O(\log_2{n})$数量级</p><p>3.二叉排序树的平均查找长度是$O(\log_2{n})$</p><p>若，以中序对二叉查找树遍历，特点为：按关键字升序排序</p><h5 id="二叉排序树的结点插入"><a href="#二叉排序树的结点插入" class="headerlink" title="二叉排序树的结点插入"></a>二叉排序树的结点插入</h5><p>算法思想</p><p>1.若二叉树为空，则待插入结点s作为根结点</p><p>2.当二叉排序树非空时：</p><p>将待插结点关键字与根结点进行比较，</p><p>若相等则树中已有此结点，无需插入；</p><p>若小于根结点，插入左子树；</p><p>若大于根结点，插入右子树。</p><p>算法实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    <span class="comment">//  其他信息</span></span><br><span class="line">&#125;TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lch,*rch;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span>* <span class="built_in">createNode</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span>* newNode = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BiTNode));</span><br><span class="line">    newNode-&gt;data.key = value;</span><br><span class="line">    newNode-&gt;lch = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;rch = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BiTree <span class="title">SearchBST</span><span class="params">(BiTree T,KeyType key)</span></span>&#123;</span><br><span class="line">    BiTree p=T;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data.key==key)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;p-&gt;data.key)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">else</span> p=p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SearchBST</span><span class="params">(BiTree T,KeyType key ,BiTree f,BiTree &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)&#123;p=f;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key==T-&gt;data.key)&#123;p=T;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;data.key) <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;lch,key,T,p);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;rch, key,T,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InsertBST</span><span class="params">(BiTree &amp;T,TElemType e)</span></span>&#123;</span><br><span class="line">    BiTree p,s;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">SearchBST</span>(T, e.key,<span class="literal">NULL</span>,p))&#123;</span><br><span class="line">        s=(BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        s-&gt;data=e;</span><br><span class="line">        s-&gt;lch=s-&gt;rch=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p) T=s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(e.key&lt;p-&gt;data.key)</span><br><span class="line">            p-&gt;lch=s;</span><br><span class="line">        <span class="keyword">else</span> p-&gt;rch=s;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertBST_D</span><span class="params">(TElemType e,BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        T=(BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        T-&gt;data=e;</span><br><span class="line">        T-&gt;lch=T-&gt;rch=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e.key&lt;T-&gt;data.key)&#123;</span><br><span class="line">        <span class="built_in">InsertBST_D</span>(e, T-&gt;lch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e.key&gt;T-&gt;data.key)&#123;</span><br><span class="line">        <span class="built_in">InsertBST_D</span>(e, T-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BiTree T=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;data.key=<span class="number">45</span>;</span><br><span class="line">    T-&gt;lch=<span class="built_in">createNode</span>(<span class="number">12</span>);</span><br><span class="line">    T-&gt;lch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">3</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">37</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">24</span>);</span><br><span class="line">    T-&gt;rch=<span class="built_in">createNode</span>(<span class="number">53</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">100</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">61</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">90</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">78</span>);</span><br><span class="line">    <span class="comment">//创建了如图的二叉排序树</span></span><br><span class="line">    TElemType e;</span><br><span class="line">    e.key=<span class="number">23</span>;</span><br><span class="line">    <span class="built_in">InsertBST</span>(T, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">SearchBST</span>(T, <span class="number">23</span>)-&gt;data.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>算法分析</p><p>1.二叉排序树的插入算法时间复杂度与查找算法的时间复杂性相同</p><p>2.最好情况是$O(log_2{n})$;最坏情况是$O(n)$;平均情况是$O(log_2{n})$</p><p>生成一个二叉排序树的方法就是从空树开始循环调用插入算法</p><h5 id="二叉排序树的结点删除"><a href="#二叉排序树的结点删除" class="headerlink" title="二叉排序树的结点删除"></a>二叉排序树的结点删除</h5><p>定义：在二叉查找树上删除一个结点，要求删除结点后仍然保持原来二叉树的结构特点不变。</p><p>删除方法</p><p>设被删的结点为p，其双亲结点为f，则p可能有以下四种情况：</p><p>1.p为叶子结点</p><p>​    释放结点p，修改父结点f的相应结点</p><p>2.p只有左子树</p><p>​    释放结点p，p的左子树顶替p的位置</p><p>3.p只有右子树</p><p>​    释放结点p，p的右子树顶替p的结点</p><p>4.p左右子树都有</p><p>​    把左子树作为右子树中最小结点的左子树</p><p>​    或者把右子树作为左子树中最大节点的右子树</p><p>​    缺点是增加树的高度</p><p>​    改进方法：找一个结点顶替p的位置</p><p>​    这个结点满足：左子树中最大或者右子树中最小</p><h5 id="平衡二叉树的构建"><a href="#平衡二叉树的构建" class="headerlink" title="平衡二叉树的构建"></a>平衡二叉树的构建</h5><p>定义：平衡二叉树又称AVL树，一棵AVL树或者是空树，或者是具有以下性质的二叉排序树：他的所有结点的左子树和右子树的高度之差的绝对值不超过1</p><p>平衡因子的定义：任一结点的左子树的高度减去右子树的高度所得的高度差称为该结点的平衡因子BF，根据AVL树的定义，任一结点的平衡因子只能取-1，0，1。一棵平衡二叉排序树如果有n个结点，其高度可以保持在$O(\log_2n)$,平均查找长度也可以保持在$O(\log_2n)$</p><p>因为插入右子树的右子树导致不平衡，调整办法为RR旋转，实际操作是向左旋转</p><p>因为插入左子树的左子树导致不平衡，调整办法为LL旋转，实际操作是向右旋转</p><p>因为插入左子树的右子树导致不平衡，调整办法为LR旋转，实际操作是先左旋，再右旋</p><p>因为插入右子树的左子树导致不平衡，调整办法为RL旋转，实际操作是先右旋，再左旋</p><p>构造思想</p><p>在构造中，每当插入一个新结点时，首先检查是否因为插入而破坏了树的平衡性</p><p>若是，则找出其中的最小不平衡子树，在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的连接关系，以达到新平衡</p><p>最小不平衡子树：以离插入结点最近，平衡因子绝对值大于1的结点作为根的子树</p><p>操作实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">R_Rotate</span><span class="params">(BiTree &amp;p)</span></span>&#123;   <span class="comment">//LL型 右旋</span></span><br><span class="line">    BiTree lc;</span><br><span class="line">    lc=p-&gt;lch;</span><br><span class="line">    p-&gt;lch=lc-&gt;rch;</span><br><span class="line">    lc-&gt;rch=p;</span><br><span class="line">    p=lc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">L_Rotate</span><span class="params">(BiTree &amp;p)</span></span>&#123;   <span class="comment">//RR型 左旋</span></span><br><span class="line">    BiTree rc;</span><br><span class="line">    rc=p-&gt;rch;</span><br><span class="line">    p-&gt;rch=rc-&gt;lch;</span><br><span class="line">    rc-&gt;lch=p;</span><br><span class="line">    p=rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希(散列)技术：把记录(元素)的存储位置和该记录的关键字的值之间建立一种映射关系。关键字的值在这种映射下的像就是相应记录在表中的存储位置</p><p>散列技术在理想状况下查找的期望时间是$O(1)$</p><p>设U表示所有可能出现的关键字集合，K表示实际出现的关键字集合即K$\subseteq$U,F[B]是一个数组；从U到表F[B]下标集合上的一个映射h：U-&gt;{0,1,2,…,B-1}称为<strong>散列函数</strong>(哈希函数，杂凑函数)</p><p>数组F称为散列表(Hash表，杂凑表),数组中每一个单元被称为桶(bucket)</p><p>对于任意关键字k$\in$U，函数值h(k)称为k的散列地址（Hash地址，散列值，存储地址，桶号）</p><p>将结点按关键字的散列地址存储到散列表的过程称为散列</p><p>不同关键字具有相同的散列地址的现象，称为散列冲突，这两个关键字称为同义字</p><p>哈希函数的构造原则：</p><p>计算简单，散列函数不应该有很大的计算量，会降低查找效率</p><p>分布均匀：散列函数值即散列地址要尽量均匀的分布在地址空间，这样才能保证存储空间的有效利用并减少冲突</p><h4 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h4><h5 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h5><p>取关键字或关键字的某个线性函数值为哈希地址</p><p>$H(key)=a*key+b$</p><p>其中a,b为常数，又称$H(key)$为自身函数</p><p>优点：没有冲突</p><p>确定：若关键字取值跨度很大，浪费存储空间严重</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(KeyType key)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> key/<span class="number">10</span><span class="number">-150</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="质数除余法"><a href="#质数除余法" class="headerlink" title="质数除余法"></a>质数除余法</h5><p>如果表长为n，取小于或等于n的最大质数m作模，关键字通过m取模运算，所得值作为散列地址</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPre</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindPre</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPre</span>(n)) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;<span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(KeyType key,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key%<span class="built_in">FindPre</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h4><h5 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h5><p>冲突时，在周围找一个新的空闲地址</p><p>1.线性探测再散列法：若H(key)=d的单元发生冲突，则按下列方法进行探查：</p><p>​    $h_i(k)=(h(k)+i)%n$ n是散列表长度，$1\leqslant i\leqslant n-1$</p><p>二次聚集：两个本来不冲突的非同义词，发生争夺同一个散列地址的现象称为二次聚集或堆积</p><p>开放地址法不会引起堆积现象</p><p>1利用散列函数计算出关键字为K的地址，d=H(K)如果F[d].key==K,查找成功，返回d；</p><p>2.如果F[d].key!=K，依次查找F[(d+i)%n].key,直到找到某个F[(d+j)%n].key==K，返回(d+j)%n，或者找到一个开放地址为止，或者又回到F[d]，此时则表示没找到</p><p>2.二次探测再散列法：若H(key)=d的单元发生冲突，则按照下列方法进行探查：</p><p>$h_i$(k)=(h(k)+$d_i$)%n n是散列表长度</p><p>$d_i$=$1^2$,$-1^2$,$2^2$,$-2^2$,…,$+k^2$,$-k^2$  ($k\leqslant n/2$)</p><p>$d_i$为伪随机序列，称伪随机探测再散列</p><p>3.再哈希法</p><p>设置多个哈希函数，冲突时顺序用下一个</p><h5 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h5><p>1.根据关键字K找到关键字为K的结点所在的单链表的手地址</p><p>2.在所找到的单链表上进行顺序查找，若找到，返回地址，否则返回空值</p><p>一个哈希查找的例子</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUPLICATE -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLKEY INT_MAX</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> hashsize[]=&#123;<span class="number">13</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ElemType</span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> sizeindex;</span><br><span class="line">&#125;HashTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPre</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindPre</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPre</span>(n)) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;<span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key%<span class="built_in">FindPre</span>(hashsize[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">collision</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> &amp;c)</span></span>&#123;</span><br><span class="line">    p=(p+c)%hashsize[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SearchHash</span><span class="params">(HashTable H,KeyType K,<span class="type">int</span> &amp;p,<span class="type">int</span> &amp;c)</span></span>&#123;</span><br><span class="line">    p=<span class="built_in">Hash</span>(K);</span><br><span class="line">    <span class="keyword">while</span>(H.elem[p].key!=NULLKEY&amp;&amp;K!=H.elem[p].key)</span><br><span class="line">        <span class="built_in">collision</span>(p,++c);</span><br><span class="line">    <span class="keyword">if</span>(K==H.elem[p].key) <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> UNSUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    HashTable HT;</span><br><span class="line">    HT.count=<span class="number">13</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> c ,p;</span><br><span class="line">    HT.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*<span class="number">13</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">13</span>;i++)&#123;</span><br><span class="line">        HT.elem[i].key=NULLKEY;</span><br><span class="line">    &#125;</span><br><span class="line">    HT.elem[<span class="number">0</span>].key=NULLKEY;</span><br><span class="line">    HT.elem[<span class="number">1</span>].key=<span class="number">14</span>;</span><br><span class="line">    HT.elem[<span class="number">2</span>].key=<span class="number">1</span>;</span><br><span class="line">    HT.elem[<span class="number">3</span>].key=<span class="number">68</span>;</span><br><span class="line">    HT.elem[<span class="number">4</span>].key=<span class="number">27</span>;</span><br><span class="line">    HT.elem[<span class="number">5</span>].key=<span class="number">54</span>;</span><br><span class="line">    HT.elem[<span class="number">6</span>].key=<span class="number">19</span>;</span><br><span class="line">    HT.elem[<span class="number">7</span>].key=<span class="number">20</span>;</span><br><span class="line">    HT.elem[<span class="number">8</span>].key=<span class="number">84</span>;</span><br><span class="line">    HT.elem[<span class="number">9</span>].key=NULLKEY;</span><br><span class="line">    HT.elem[<span class="number">10</span>].key=<span class="number">23</span>;</span><br><span class="line">    HT.elem[<span class="number">11</span>].key=<span class="number">11</span>;</span><br><span class="line">    HT.elem[<span class="number">12</span>].key=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">13</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(HT.elem[i].key==NULLKEY)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;@&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;HT.elem[i].key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    c=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">SearchHash</span>(HT, <span class="number">23</span>, p, c);</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>几种不同处理冲突方法的平均查找长度：</p><p><img src="/2023/11/21/23-11-21-2/平均查找长度比较.png" alt="平均查找长度比较"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】 图</title>
      <link href="/2023/11/21/23-11-21-1/"/>
      <url>/2023/11/21/23-11-21-1/</url>
      
        <content type="html"><![CDATA[<h3 id="图的定义和术语"><a href="#图的定义和术语" class="headerlink" title="图的定义和术语"></a>图的定义和术语</h3><h4 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h4><p>图G由两个集合构成，记作<code>G=&lt;V,E&gt;</code> ，其中V是顶点的非空有限集合，E是边的有限集合，其中边是顶点的无序对或有序对集合。</p><h4 id="图的术语"><a href="#图的术语" class="headerlink" title="图的术语"></a>图的术语</h4><p>无向图：若图G中所有边是无向边，则G为无向图</p><p>有向图：若所有边是有向边，则G为有向图；有向边被称作弧。</p><p>无向完全图：无向图且边数为n(n-1)/2</p><p>有向完全图：有向图且边数为n(n-1)</p><p>邻接点：边的两个顶点</p><p>关联边：若边e=(v,u)，则称顶点v，u关联边e</p><p>顶点的度：一个顶点的度是与它关联的边的条数</p><p>入度：以该顶点为终点的有向边的条数，ID(v)</p><p>出度：以该顶点为起点的有向边的条数，OD(v)</p><p><strong>顶点数、边数e、和度数D(v)的关系</strong>：e=$\sum_{i=1}^nD(V_i)$/2</p><p>无向图的路径、回路：</p><p>无向图G=(V,E)中的顶点序列$v_1$,$v_2$,…,$v_k$,若($v_i$,$v_{i+1}$) $\in$ E(i=1,2,…,k-1),$v=v_1$,$u=v_k$,则称该序列是从v到u的路径；若v=u，则该序列称为回路。</p><p>有向图的路径、回路：</p><p>有向图G=(V,E)中的顶点序列$v_1$,$v_2$,…,$v_k$,若&lt;$v_i$,$v_{i+1}$&gt; $\in$ E(i=1,2,…,k-1),$v=v_1$,$u=v_k$,则称该序列是从v到u的路径；若v=u，则该序列称为回路。</p><p>简单路径：序列顶点中不重复出现的路径</p><p>简单回路/环：在一条路径中，除起点和终点外所有顶点各不相同</p><p>连通图：在无向图G=<V,E>中，若对于任何两个顶点v,u都存在v到u的路径，则称G是连通图。</V,E></p><p>强连通图：在有向图G=<V,E>中，若对于任何两个顶点v,u都存在v到u的路径，则称G是连通图。</V,E></p><p>子图：设有两个图G=(V,E)、$G_1=(V_1,E_1)$，若$V_1$ $\subseteq$V，$E_1$ $\subseteq$E，$E_1$关联的顶点都在$V_1$中，称$G_1$是G的子图。</p><p>连通分量：无向图中的极大连通子图</p><p>强连通分量：有向图中的极大强连通子图</p><p>网络(边带权图)：某些图的边具有与它相关的数，称为权，这种带权图叫网络</p><p>生成树：连通图的一个子图如果是一棵包含G所有顶点的树，则称为图G的生成树</p><p><img src="/2023/11/21/23-11-21-1/图分类.png" alt="图分类"></p><h4 id="图的抽象数据类型定义"><a href="#图的抽象数据类型定义" class="headerlink" title="图的抽象数据类型定义"></a>图的抽象数据类型定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT Graph&#123;</span><br><span class="line">数据对象V:V是具有相同特性的元素的集合称为顶点集。</span><br><span class="line">数据关系: R=&#123;VR&#125;</span><br><span class="line"> VR=&#123;&lt;v,w&gt;|v,w属于V且P(v,w),&lt;v,w&gt;表示从v到w的弧&#125;</span><br><span class="line">基本操作:</span><br><span class="line">  CreateGraph(&amp;G)<span class="comment">//建立图</span></span><br><span class="line">  DestoryGraph(&amp;G)<span class="comment">//销毁图</span></span><br><span class="line">  InsertVex(&amp;G,v)<span class="comment">//插入顶点</span></span><br><span class="line">  DeleteVex(&amp;G,v)<span class="comment">//删除顶点</span></span><br><span class="line">  DFSTraverse(G,v,visit())<span class="comment">//深度优先搜索</span></span><br><span class="line">  BFSTraverse(G,v,visit())  <span class="comment">//广度优先搜索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h4 id="数组表示法-邻接矩阵"><a href="#数组表示法-邻接矩阵" class="headerlink" title="数组表示法(邻接矩阵)"></a>数组表示法(邻接矩阵)</h4><p>G的邻接矩阵满足以下条件：</p><script type="math/tex; mode=display">A[i][j]=\begin{cases}1 ,若(v_i,v_j)\in E或<v_i,v_j>\in E\\0 ,否则\end{cases}</script><p>​    邻接矩阵中的元素A[i] [j]存放的是顶点i到顶点j的关系的信息。</p><h5 id="对于无向图"><a href="#对于无向图" class="headerlink" title="对于无向图"></a>对于无向图</h5><p>无向图的邻接矩阵特点：1.对称矩阵 2.对角线元素全0</p><p>无向图的第i个顶点的度怎么表示？ 第i行(或第i列)的非零元素个数之和</p><p>图的总度数：矩阵中非零元素个数之和</p><p>边数为总度数的一半。</p><h5 id="对于有向图"><a href="#对于有向图" class="headerlink" title="对于有向图"></a>对于有向图</h5><p>第i个顶点的出度和入度如何体现？</p><p>第i行的非零元个数之和为出度</p><p>第i列的非零元个数之和为入度</p><p>边数为非零元的个数</p><h5 id="网络的邻接矩阵"><a href="#网络的邻接矩阵" class="headerlink" title="网络的邻接矩阵"></a>网络的邻接矩阵</h5><script type="math/tex; mode=display">A[i][j]=\begin{cases}Wij ,若(v_i,v_j)\in E或<v_i,v_j>\in E\\\infty ,否则\end{cases}</script><p>对于无穷大，可以用INT_MAX表示(用一个特殊的数表示即可)</p><p>存储结构：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IFINITY INT_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;DG,DN,UDG,UDN&#125;GraphKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VertexType</span>&#123;</span><br><span class="line">    <span class="type">char</span> id;</span><br><span class="line">  <span class="comment">//  string label;</span></span><br><span class="line">&#125;VRType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">InfoType</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">// 用于存储边的权重</span></span><br><span class="line">&#125; InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcCell</span>&#123;</span><br><span class="line">    <span class="type">int</span> adj;</span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125;ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    VertexType vexs[MAX_VERTEX_NUM];<span class="comment">//顶点信息</span></span><br><span class="line">    AdjMatrix arcs;<span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;<span class="comment">//顶点数，边数</span></span><br><span class="line">    GraphKind kind;<span class="comment">//图种</span></span><br><span class="line">    </span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><p>创建图：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creategraph</span><span class="params">(MGraph &amp;G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;<span class="type">float</span> w;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入顶点数，弧数，图类型:&quot;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;G.vexnum,&amp;G.arcnum,&amp;G.kind);</span><br><span class="line">    <span class="comment">//构造顶点向量</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入顶点名称:&quot;</span>;</span><br><span class="line">        cin&gt;&gt;G.vexs[i].id;</span><br><span class="line">       <span class="comment">// scanf(&quot;%d&quot;,&amp;G.vexs[i].id);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">            G.arcs[i][j].adj=IFINITY;</span><br><span class="line">            G.arcs[i][j].info=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.arcnum;k++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入邻接矩阵位置与权重:&quot;</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%f&quot;</span>,&amp;i,&amp;j,&amp;w);</span><br><span class="line">        G.arcs[i][j].adj=w;</span><br><span class="line">        G.arcs[j][i].adj=w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>1.空间复杂度O($n^2$)</p><p>2.边或弧的插入和删除操作简单，但顶点的插入和删除操作不容易</p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>对于每个顶点，建立一个单链表，存储该顶点的所有邻接顶点和信息·。</p><h5 id="对于无向图-1"><a href="#对于无向图-1" class="headerlink" title="对于无向图"></a>对于无向图</h5><p>第i个顶点的总度数为边链表的结点的个数</p><p>图的总度数为所有边链表的结点个数之和。</p><p>边数即所有边链表的结点个数之和的<strong>一半</strong></p><h5 id="邻接表的定义"><a href="#邻接表的定义" class="headerlink" title="邻接表的定义"></a>邻接表的定义</h5><p>邻接表分为两部分，边链表和顶点表</p><p>存储结构：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;DG,DN,UDG,UDN&#125;GraphKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">InfoType</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vertextype</span>&#123;</span><br><span class="line">    <span class="type">char</span> id;</span><br><span class="line"> <span class="comment">//   string label;</span></span><br><span class="line">&#125;vertextype;</span><br><span class="line"><span class="comment">//边表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex; <span class="comment">//该弧指向的顶点位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *nextarc;</span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="comment">//顶点表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vnode</span>&#123;</span><br><span class="line">    vertextype data;</span><br><span class="line">    ArcNode *firstarc;</span><br><span class="line">&#125;vnode,adjlist[MAX_VERTEX_NUM];</span><br><span class="line"><span class="comment">//邻接表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    adjlist vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">    GraphKind kind;</span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure><p>创建图：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creatadilist</span><span class="params">(ALGraph &amp;G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    ArcNode *s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;G.vexnum,&amp;G.arcnum,&amp;G.kind);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        cin&gt;&gt;G.vertices[i].data.id;</span><br><span class="line">        G.vertices[i].firstarc=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.arcnum;k++)&#123;</span><br><span class="line">        cin&gt;&gt;i&gt;&gt;j;</span><br><span class="line">        s=(ArcNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ArcNode));</span><br><span class="line">        s-&gt;adjvex=j;</span><br><span class="line">        s-&gt;info=<span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;nextarc=G.vertices[i].firstarc;</span><br><span class="line">        G.vertices[i].firstarc=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><p>1.空间复杂度O(n+e)</p><p>2.容易找到任意一个顶点的第一个邻接点</p><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>图的遍历指，从图的某一顶点出发，访问图中所有顶点，且每个顶点仅访问一次</p><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5><p>1.首先访问图中某一个顶点$V_1$，以该点为出发点</p><p>2.任选一个与顶点$V_i$邻接的未被访问的顶点$V_j$，访问$V_j$</p><p>3.以$V_j$为新的出发点继续进行深度优先搜索</p><h5 id="算法概要"><a href="#算法概要" class="headerlink" title="算法概要"></a>算法概要</h5><p>输入：图G，初始访问顶点v;</p><p>输出：图G的深度优先搜索序列；</p><p>1.访问v</p><p>2.改变v的访问标志</p><p>3.任选一个与v相邻又没被访问的顶点w</p><p>4.从w开始继续进行深度优先搜索</p><p>算法实现：</p><p>这里用邻接矩阵实现算法，传入的visit[]数组全部置0</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(MGraph G, <span class="type">int</span> v, <span class="type">bool</span> visited[])</span> </span>&#123;</span><br><span class="line">    visited[v] = TRUE;</span><br><span class="line">    cout &lt;&lt; G.vexs[v].id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.vexnum; w++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G.arcs[v][w].adj != <span class="number">-1</span> &amp;&amp; !visited[w]) &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(G, w, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><h5 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h5><p>1.首先访问图中某一个指定的出发点$v_i$,</p><p>2.然后一次访问$v_i$的所有邻接点$v_{i1}$,$v_{i2}$,$v_{i3}$…</p><p>3.再依次以$v_{i1}$,$v_{i2}$,$v_{i3}$…为顶点访问各顶点未被访问的邻接点，依次类推，直到图中所有顶点均被访问</p><h5 id="算法概要-1"><a href="#算法概要-1" class="headerlink" title="算法概要"></a>算法概要</h5><p>输入：图G，初始访问结点v</p><p>输出：图G的广度优先搜索序列</p><p>1.设置辅助队列Q，访问节点v，修改v的标志，v入队列</p><p>2.while(队列非空){</p><p>​    出队列节点u</p><p>​    访问与u的所有节点</p><p>​    修改与u邻接的所有结点的标志，与u邻接的所有结点入队列</p><p>}</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span> *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.front=Q.rear=(QNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueuePtr p=(QNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QueuePtr p;</span><br><span class="line">        p=Q.front-&gt;next;</span><br><span class="line">        e=p-&gt;data;</span><br><span class="line">        Q.front-&gt;next=Q.front-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">            Q.rear=Q.front;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">LinkQueue Q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraVErse</span><span class="params">(ALGraph G,<span class="type">bool</span> visit[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</span><br><span class="line">        visit[v]=FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[v])&#123;</span><br><span class="line">            visit[v]=TRUE;</span><br><span class="line">            cout&lt;&lt;G.vertices[v].data.id;</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, v);</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))&#123;</span><br><span class="line">                <span class="type">int</span> u,w;</span><br><span class="line">                ArcNode *p;</span><br><span class="line">                <span class="built_in">DeQueue</span>(Q, u);</span><br><span class="line">                <span class="keyword">for</span>(p=G.vertices[u].firstarc;p!=<span class="literal">NULL</span>;p=p-&gt;nextarc)<span class="comment">//将取出的u结点遍历</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visit[p-&gt;adjvex])</span><br><span class="line">                    &#123;</span><br><span class="line">                        w=p-&gt;adjvex;</span><br><span class="line">                        visit[w]=TRUE;</span><br><span class="line">                        <span class="built_in">EnQueue</span>(Q,w);</span><br><span class="line">                        cout&lt;&lt;G.vertices[w].data.id;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图的连通性问题"><a href="#图的连通性问题" class="headerlink" title="图的连通性问题"></a>图的连通性问题</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>prim算法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该图输入为字符型顶点，权值为浮点数且不为0</span></span><br><span class="line"><span class="comment">//部分注释代码为调试函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcCell</span>&#123;</span><br><span class="line">    <span class="type">float</span> adj;      <span class="comment">//记录权值</span></span><br><span class="line">&#125;ArcCell,G[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">char</span> begin;</span><br><span class="line">    <span class="type">char</span> end;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    G arcs;</span><br><span class="line">    <span class="type">int</span> vexnum,arcsnum;</span><br><span class="line">    <span class="type">char</span> vex[MAX_VERTEX_NUM];</span><br><span class="line">    Edge edge[MAX_VERTEX_NUM];</span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">V</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;<span class="comment">//closedeg[i].adjvex记录的是，顶点i到U中最短边的点</span></span><br><span class="line">    <span class="type">float</span> lowcost;<span class="comment">//lowcost记录权值</span></span><br><span class="line">&#125;;</span><br><span class="line">V closedge[MAX_VERTEX_NUM];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Locatevex</span><span class="params">(MGraph G,<span class="type">char</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G.vex[i]==u)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateGraph</span><span class="params">(MGraph &amp;G)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">float</span> w;</span><br><span class="line">    <span class="type">char</span> ii, jj;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;G.vexnum,&amp;G.arcsnum);<span class="comment">//输入顶点数和弧数</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">       <span class="comment">// cout&lt;&lt;&quot;input name:&quot;;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;name);  <span class="comment">//输入顶点名称，按次存储在vex[]数组中，下标从0开始</span></span><br><span class="line">        G.vex[i]=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">            G.arcs[i][j].adj=<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.arcsnum;i++)&#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c %f&quot;</span>,&amp;ii,&amp;jj,&amp;w);</span><br><span class="line">        j=<span class="built_in">Locatevex</span>(G, ii);</span><br><span class="line">        k=<span class="built_in">Locatevex</span>(G, jj);</span><br><span class="line">        G.arcs[j][k].adj=w;</span><br><span class="line">        G.arcs[k][j].adj=w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMatrix</span><span class="params">(MGraph G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">            cout&lt;&lt;G.arcs[i][j].adj&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MiniSpanTree_P</span><span class="params">(MGraph G,<span class="type">char</span> u)</span></span>&#123;</span><br><span class="line">   <span class="comment">// getchar();</span></span><br><span class="line">    V closedge[G.vexnum];</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">Locatevex</span>(G,u);</span><br><span class="line">    <span class="type">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j!=t)&#123;</span><br><span class="line">            closedge[j]=&#123;t,G.arcs[t][j].adj&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        closedge[t].lowcost=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="comment">/*for(int c=0;c&lt;G.vexnum;c++)&#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;closedge[c].adjvex&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        for(int c=0;c&lt;G.vexnum;c++)&#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;closedge[c].lowcost&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;*/</span></span><br><span class="line">        <span class="type">float</span> temp=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;            <span class="comment">//求k closedge最小值</span></span><br><span class="line">            <span class="keyword">if</span>(closedge[j].lowcost==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(closedge[j].lowcost&lt;temp)&#123;</span><br><span class="line">                    k=j;</span><br><span class="line">                    temp=closedge[j].lowcost;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,G.vex[closedge[k].adjvex]);</span><br><span class="line">        <span class="keyword">if</span>(i==G.vexnum<span class="number">-1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        closedge[k].lowcost=<span class="number">0</span>;</span><br><span class="line">        t=k;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!closedge[j].lowcost)&#123;</span><br><span class="line">                closedge[j].adjvex=t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                closedge[j].adjvex=t;</span><br><span class="line">                closedge[j].lowcost=G.arcs[t][j].adj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MGraph G;</span><br><span class="line">    <span class="built_in">CreateGraph</span>(G);</span><br><span class="line">    <span class="built_in">showMatrix</span>(G);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;===============&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">char</span> index;</span><br><span class="line">    cin&gt;&gt;index;</span><br><span class="line">    <span class="built_in">MiniSpanTree_P</span>(G, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>kruskal算法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> src, dest;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找父节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findParent</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[i] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findParent</span>(parent, parent[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个子树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionSets</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> xset = <span class="built_in">findParent</span>(parent, x);</span><br><span class="line">    <span class="type">int</span> yset = <span class="built_in">findParent</span>(parent, y);</span><br><span class="line">    parent[xset] = yset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskalMST</span><span class="params">(<span class="type">int</span> V, Edge edges[], <span class="type">int</span> E)</span> </span>&#123;</span><br><span class="line">    Edge result[V - <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 用于结果数组的索引</span></span><br><span class="line">    <span class="type">int</span> e = <span class="number">0</span>; <span class="comment">// 用于排序边的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对边按权重进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + E, [](Edge a, Edge b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &lt; b.weight;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> parent[V]; <span class="comment">// 用于检测环路</span></span><br><span class="line">    <span class="built_in">fill</span>(parent, parent + V, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; V - <span class="number">1</span> &amp;&amp; e &lt; E) &#123;</span><br><span class="line">        Edge nextEdge = edges[e++];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">findParent</span>(parent, nextEdge.src);</span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">findParent</span>(parent, nextEdge.dest);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            result[i++] = nextEdge;</span><br><span class="line">            <span class="built_in">unionSets</span>(parent, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最小生成树的边和权重</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Edges in the Minimum Spanning Tree:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; V - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; result[i].src &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; result[i].dest &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; result[i].weight &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">4</span>; <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="type">int</span> E = <span class="number">5</span>; <span class="comment">// 边数</span></span><br><span class="line">    Edge edges[] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行Kruskal算法并输出结果</span></span><br><span class="line">    <span class="built_in">kruskalMST</span>(V, edges, E);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="有向无环图的应用"><a href="#有向无环图的应用" class="headerlink" title="有向无环图的应用"></a>有向无环图的应用</h3><p>有向无环图简称DAG图</p><p>DAG图在工程计划和管理方面应用广泛。</p><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h5 id="基本定义和特点"><a href="#基本定义和特点" class="headerlink" title="基本定义和特点"></a>基本定义和特点</h5><p>顶点活动网：AOV网，将顶点表示活动，边表示活动之间的关系</p><p>拓扑序列：把AOV网中的所有顶点排成可以线性序列，该序列满足：若AOV网中存在从$v_i$到$v_j$的路径，则在该序列中，$v_i$必位于$v_j$之前</p><p>拓扑排序：构造AOV网的拓扑序列的操作被称为拓扑排序</p><p>特点：</p><p>1.一个有向图的拓扑序列不一定唯一</p><p>2.有向无环图一定存在拓扑序列</p><p>3.有向有环图不存在拓扑序列</p><p>4.可以通过构造拓扑序列，判断AOV网是否存在环</p><h5 id="拓扑排序算法的基本思想"><a href="#拓扑排序算法的基本思想" class="headerlink" title="拓扑排序算法的基本思想"></a>拓扑排序算法的基本思想</h5><p>1.在有向图中选一个入度为0的顶点输出</p><p>2。从图中删除该顶点及所有它的出边</p><p>3.重复 1和2 直到所有顶点输出或者图中剩余顶点入度均不为0（此时图中有回路，无法拓扑排序）</p><h5 id="算法概要-2"><a href="#算法概要-2" class="headerlink" title="算法概要"></a>算法概要</h5><p>增加一个存放各顶点入度的数组indegree[]</p><p>1.扫描indegree[]，将入度为0的顶点入栈</p><p>2.while(栈非空){</p><p>​    出栈顶元素$v_i$，并输出；</p><p>​    检查$v_i$的出边表，将每条出边&lt;$v_i$,$v_j$&gt;的终点$v_j$的入度减1，若vj的入度减至0，v$v_j$入栈；</p><p>}</p><p>3.若输出的顶点数小于n则有回路（无法拓扑排序），否则正常结束。</p><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;DG,DN,UDG,UDN&#125;GraphKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">InfoType</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vertextype</span>&#123;</span><br><span class="line">    <span class="type">char</span> id;</span><br><span class="line">    <span class="type">int</span> No;</span><br><span class="line"> <span class="comment">//   string label;</span></span><br><span class="line">&#125;vertextype;</span><br><span class="line"><span class="comment">//边表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex; <span class="comment">//该弧指向的顶点位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *nextarc;</span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="comment">//顶点表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vnode</span>&#123;</span><br><span class="line">    vertextype data;</span><br><span class="line">    ArcNode *firstarc;</span><br><span class="line">&#125;vnode,adjlist[MAX_VERTEX_NUM];</span><br><span class="line"><span class="comment">//邻接表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    adjlist vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">    GraphKind kind;</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creatadilist</span><span class="params">(ALGraph &amp;G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    ArcNode *s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;G.vexnum,&amp;G.arcnum,&amp;G.kind);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        cin&gt;&gt;G.vertices[i].data.id;</span><br><span class="line">        G.vertices[i].firstarc=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.arcnum;k++)&#123;</span><br><span class="line">        cin&gt;&gt;i&gt;&gt;j;</span><br><span class="line">        s=(ArcNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ArcNode));</span><br><span class="line">        s-&gt;adjvex=j;</span><br><span class="line">        s-&gt;info=<span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;nextarc=G.vertices[i].firstarc;</span><br><span class="line">        G.vertices[i].firstarc=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SElemType</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *base;</span><br><span class="line">    <span class="type">int</span> *top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base=(<span class="type">int</span>*)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    S.top=S.base;</span><br><span class="line">    S.stacksize=STACK_INIT_SIZE;</span><br><span class="line">  <span class="comment">//  cout&lt;&lt;&quot;Init succeed.&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,<span class="type">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top-S.base&gt;=S.stacksize)&#123;</span><br><span class="line">        S.base=(<span class="type">int</span>*)<span class="built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(!S.base) &#123;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;&quot;ERROR&quot;&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    S.top=S.base+S.stacksize;</span><br><span class="line">    S.stacksize+=STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++=e;</span><br><span class="line"> <span class="comment">//   cout&lt;&lt;&quot;Push succeed.&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,<span class="type">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.base)&#123;</span><br><span class="line">     <span class="comment">//   cout&lt;&lt;&quot;Stack is Empty.&quot;&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        e=*(S.top<span class="number">-1</span>);</span><br><span class="line">        S.top--;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;Pop succeed.&quot;&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S.top&gt;S.base)&#123;</span><br><span class="line">        <span class="type">int</span>* p=S.top;</span><br><span class="line">        S.top--;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        S.stacksize-=STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// cout&lt;&lt;&quot;Stack clear succeed.&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.base != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="built_in">Clear</span>(S);</span><br><span class="line">        <span class="built_in">free</span>(S.base);</span><br><span class="line">        S.base = <span class="literal">NULL</span>;</span><br><span class="line">        S.top = <span class="literal">NULL</span>;</span><br><span class="line">        S.stacksize = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;Stack destroyed.&quot; &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base==S.top) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(S.base==S.top)) <span class="keyword">return</span> S.top-S.base;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetTop</span><span class="params">(SqStack S,<span class="type">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    e=*(S.top<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;e is:&quot;</span>&lt;&lt;(&amp;e)&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;(&amp;e)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackTravers</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Stack is Empty.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!(S.top==S.base))&#123;</span><br><span class="line">        S.top--;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot;. &quot;</span>;</span><br><span class="line">        cout&lt;&lt;(*(&amp;S.top))&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;(*(&amp;S.top))-&gt;b&lt;&lt;endl;</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindInDegree</span><span class="params">(ALGraph G, <span class="type">int</span> indegree[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        p=G.vertices[i].firstarc;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            indegree[p-&gt;adjvex]++;</span><br><span class="line">            p=p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TopologicalSort</span><span class="params">(ALGraph G)</span></span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="type">int</span> count,k,i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="type">int</span> indegree[MAX_VERTEX_NUM]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">FindInDegree</span>(G, indegree);</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!indegree[i]) <span class="built_in">Push</span>(S, i);</span><br><span class="line">    &#125;</span><br><span class="line">    count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">StackEmpty</span>(S))&#123;</span><br><span class="line">        <span class="built_in">Pop</span>(S,i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,i,G.vertices[i].data.No);</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)&#123;</span><br><span class="line">            k=p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[k])) <span class="built_in">Push</span>(S, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count&lt;G.vexnum)<span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h4><p>路径长度：路径上边的权值之和</p><p>最短路径：两结点间权值之和最小的路径</p><h4 id="单源最短路径Dijkstra"><a href="#单源最短路径Dijkstra" class="headerlink" title="单源最短路径Dijkstra"></a>单源最短路径Dijkstra</h4><p>给定有向图G和源点$v_i$，求$v_i$到G中其余各顶点的最短路径</p><h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><p>按路径长度的递增次序，逐步产生最短路径Dijkstra算法(SPF算法)</p><p>首先求出长度最短的一条路径，再参照它求出长度次短的一条最短路径，以此类推，直到从顶点v到其他各顶点的最短路径全部求出为止</p><h5 id="算法要点"><a href="#算法要点" class="headerlink" title="算法要点"></a>算法要点</h5><p>例图：<img src="/2023/11/21/23-11-21-1/单源最小路径示例.png" alt="单源最小路径"><br>1.设源点$v_0$，顶点集合分成两部分：</p><p>U：已经求出最短路径的顶点集合</p><p>V-U：未求出最短路径的顶点集合</p><p>初值：U={$v_0$},V-U={$v_1$,$v_2$,$v_3$,$v_4$}</p><p>第二个加入U中的顶点必然是与$v_0$邻接且与$v_0$之间的边长最短的顶点</p><p>2.U={$v_0$,$v_2$}，V-U={$v_1$,$v_3$,$v_4$}</p><p>设第三个加入U中的顶点是w$\in$V-U,则w到$v_0$的最短路径的特点是：w是V-U中满足$v_0$-&gt;w和$v_0$-&gt;$v_2$-&gt;w中最短的</p><h5 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> vexs[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">float</span> arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><h5 id="算法概要-3"><a href="#算法概要-3" class="headerlink" title="算法概要"></a>算法概要</h5><p>1.引入辅助数组D[ ],D[i]表示当前所找到的源点到每个终点i的最短路径长度，最短路径的初值即有向边的权值D[i]=G.arcs[$v_0$] [i]</p><p>​    引入辅助数组final[ ],final[i]=1表示顶点i的最短路径已经求出，否则未求出</p><p>​    初始状态：final[$v_0$]标志为1，其余为0</p><p>​    引入数组P[ ]来记录路径</p><p>2.选择D[ ]中路径最小值的顶点v(已经求出最短路的顶点除外)</p><p>​    v就是当前求得得一条从$v_0$出发的最短路径的终点，修改final[v]=1</p><p>3.修改未求出最短路径的顶点的最短路径长度，如果D[v]+G.arcs[v] [w]&lt;D[w]</p><p>​    则修改D[w]，D[w]=D[v]+G.arcs[v] [w]</p><p>​    同时修改P[w]=v</p><p>4.重复2 ，3操作 n-1次，求得最短路径长度递增序列</p><h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  dijkstra</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 1000</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span> <span class="title class_">ArcCell</span> &#123;</span><br><span class="line">    <span class="type">int</span> adj;</span><br><span class="line">&#125;ArcCell,AdjMatrix[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> vexs[MAX_VERTEX_NUM];</span><br><span class="line">   <span class="comment">// AdjMatrix arcs;</span></span><br><span class="line">    <span class="type">float</span> arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath_DIJ</span><span class="params">(MGraph G,<span class="type">int</span> v0,<span class="type">int</span> *P,<span class="type">float</span> *D)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,v,w,min,f[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</span><br><span class="line">        f[v]=<span class="number">0</span>;</span><br><span class="line">        D[v]=G.arcs[v0][v];</span><br><span class="line">       </span><br><span class="line">        P[v]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(D[v]&lt;INFINITY) P[v]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;P[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">        cout&lt;&lt;D[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">        cout&lt;&lt;f[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">        cout&lt;&lt;P[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        min=INFINITY;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;++w)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[w])</span><br><span class="line">                <span class="keyword">if</span>(D[w]&lt;min)&#123;v=w;min=D[w];&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;++w)&#123;</span><br><span class="line">            <span class="keyword">if</span>((!f[w])&amp;&amp;(min+G.arcs[v][w]&lt;D[w]))&#123;</span><br><span class="line">                D[w]=min+G.arcs[v][w];</span><br><span class="line">                P[w]=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pre;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%.0f:%d&quot;</span>,D[i],i); <span class="comment">//这里因为测试的都用的整数，直接舍去小数输出了</span></span><br><span class="line">        pre=P[i];</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&lt;-%d&quot;</span>,pre);</span><br><span class="line">            pre=P[pre];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    MGraph G;</span><br><span class="line">    G.vexnum=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            G.arcs[i][j]=INFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G.arcs[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">4</span>][<span class="number">4</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">6</span>;</span><br><span class="line">    G.arcs[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">    G.arcs[<span class="number">1</span>][<span class="number">3</span>]=<span class="number">5</span>;</span><br><span class="line">    G.arcs[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    G.arcs[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">    G.arcs[<span class="number">2</span>][<span class="number">4</span>]=<span class="number">4</span>;</span><br><span class="line">    G.arcs[<span class="number">3</span>][<span class="number">4</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="type">float</span> *D = <span class="keyword">new</span> <span class="type">float</span>[G.vexnum]; <span class="comment">// 动态分配内存</span></span><br><span class="line">    <span class="type">int</span> *P = <span class="keyword">new</span> <span class="type">int</span>[G.vexnum];</span><br><span class="line">    <span class="built_in">ShortestPath_DIJ</span>(G, <span class="number">0</span>, P,D);</span><br><span class="line">    <span class="keyword">delete</span>[] D; <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><p>Dijkstra算法的时间复杂行主要体现在求每个顶点的最短路径是，需要修改距离和求最小值，时间复杂性O($n^2$)</p><p>Dijkstra算法的空间复杂性主要体现在辅助数组，空间复杂性为O(n)</p><h4 id="每一对顶点之间的最短路径"><a href="#每一对顶点之间的最短路径" class="headerlink" title="每一对顶点之间的最短路径"></a>每一对顶点之间的最短路径</h4><p>依次把有向网络的每个顶点作为源点，重复执行Dijkstra算法n次，即可求得每对顶点之间的最短路径</p><p>Floyd算法 可以直接求出所有顶点之间的最短路径</p><h5 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h5><p>对顶点进行编号，设顶点为0,1,…,n-1，算法采用邻接矩阵G.arcs[n] [n]表示有向网络</p><p>$D^{(-1)}[n][n]$表示中间不经过任何点的最短路径；即邻接矩阵</p><p>$D^{(0)}[n][n]$表示只允许经过0号顶点的最短路径</p><p>$D^{(1)}[n][n]$表示只允许经过0号和1号顶点的最短路径</p><p>$…….$</p><p>$D^{(n-1)}[n][n]$表示可经过所有顶点的最短路径</p><p>基本想法：动态规划算法</p><p>如果$v_i$与$v_j$之间有一条路径，但不一定最短，也许经过某些中间点会使路径长度更短，尝试在原路径中加入其他顶点作为中间顶点</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】树与二叉树</title>
      <link href="/2023/11/14/23-11-14/"/>
      <url>/2023/11/14/23-11-14/</url>
      
        <content type="html"><![CDATA[<h3 id="树的定义和基本术语"><a href="#树的定义和基本术语" class="headerlink" title="树的定义和基本术语"></a>树的定义和基本术语</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>树是n(n&gt;=0)个结点的有限集。</p><p>(1)<strong>有且仅有</strong>一个特定的称为根的结点</p><p>(2)n&gt;1时，其他结点可以分为m个不相交的有限集，其中每个集合也构成一颗树，称为根的子树。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>(1)树的根结点没有前驱，其他结点有且仅有一个前驱。</p><p>(2)树中任何一个结点可以有零或多个后继结点。</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>1.结点(node)</p><p>2.结点的度(degree)</p><p>3.树的度</p><p>4.叶子或终端结点</p><p>5.非终端结点</p><p>6.父(双)亲结点(parent)</p><p>7.儿(孩)子结点(child)</p><p>8.兄弟结点(sibling)</p><p>9.路径</p><p>10.祖先</p><p>11.子孙(后代)</p><p>12.结点的层数(level)</p><p>12.树的深度(depth)或高度</p><p>14.有序树和无序树</p><p>15.森林(forest): 是m(m&gt;=0)棵互不相交的树的集合</p><h4 id="树的表示方法"><a href="#树的表示方法" class="headerlink" title="树的表示方法"></a>树的表示方法</h4><p>1.图</p><p>2.嵌套集合</p><p>3.广义表形式： (A(B(D),C))</p><p>4.凹入表示法</p><h3 id="树的有关概念"><a href="#树的有关概念" class="headerlink" title="树的有关概念"></a>树的有关概念</h3><h4 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ADT Tree&#123;</span><br><span class="line">    数据对象D:D是具有相同特性的元素的集合。</span><br><span class="line">  数据关系R:若D为空集,则称为空树;否则:</span><br><span class="line">                  (<span class="number">1</span>)在D中存在唯一的称为根的数据元素，则R集为空;</span><br><span class="line">                (<span class="number">2</span>)当n&gt;<span class="number">1</span>时,其余结点n&gt;<span class="number">1</span>时，其他结点可以分为m个不相交的有限集，其中每个集合也是一颗符合本定义的树，称为根root的子树。</span><br><span class="line">  基本操作P:查找类、插入类、删除类操作。                                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树的基本操作类"><a href="#树的基本操作类" class="headerlink" title="树的基本操作类"></a>树的基本操作类</h4><p>查找类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Root(T)//求树的根结点</span><br><span class="line">Value(T,cur_e)//求当前结点的元素值</span><br><span class="line">Parent(T,cur_e)//求当前结点的双亲结点</span><br><span class="line">LeftChild(T,cur_e)//求当前结点的最左孩子</span><br><span class="line">RightSibling(T,cur_e)//求当前结点的右兄弟</span><br><span class="line">TreeEmpty(T)//判断树是否为空</span><br><span class="line">TreeDepth(T)//求树的高度</span><br><span class="line">TraverseTree(T,Visit())//遍历</span><br></pre></td></tr></table></figure><p>插入类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InitTree(&amp;T)//初始化置空树</span><br><span class="line">CreateTree(&amp;T,definition)//按定义构造树</span><br><span class="line">Assign(T,cur_e,value)//为当前结点赋值</span><br><span class="line">InsertChild(&amp;T,&amp;p,i,c)//将c为根的树插入为结点p的第i棵子树</span><br></pre></td></tr></table></figure><p>删除类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClearTree(&amp;T)//清空树</span><br><span class="line">DestroyTree(&amp;T)//销毁树的结构</span><br><span class="line">DeleteChild(&amp;T,&amp;p,i)删除结点p的第i棵子树</span><br></pre></td></tr></table></figure><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>二叉树(Binary Tree)是n(n&gt;=0)个结点的集合，这个集合可以是空集，可以是一个结点，或者是由一个根结点和两棵称为左子树和右子树的互不相交的二叉树组成。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>1.可以为空，即不含结点</p><p>2.每个结点至多有二棵子树(二叉树中不存在度大于2的结点)</p><p>3.二叉树是有序树，子树有左右之分，次序不能任意颠倒；允许有些结点只有左子树或右子树</p><h4 id="五种基本形态"><a href="#五种基本形态" class="headerlink" title="五种基本形态"></a>五种基本形态</h4><p>如图：<img src="/2023/11/14/23-11-14/树的五种基本形态.png" alt="image1"></p><h4 id="二叉树与树的区别"><a href="#二叉树与树的区别" class="headerlink" title="二叉树与树的区别"></a>二叉树与树的区别</h4><p>每个结点至多两个子树，且有左右之分</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>1.在二叉树的第i(i&gt;=1)层上至多有$2^{i-1}$个结点</p><p>2.深度为k的二叉树最多有$2^k$-1个结点</p><p>3.对任意二叉树T，如果终端结点数为n~0~(度数为0的结点树),n~1~,n~2~分别表示度数为1，2的结点个数，则n~0~=n~2~+1</p><p>满二叉树：</p><p>一个二叉树的叶子结点都在最后一层上，且不存在度数为1的结点</p><p>设高为k则有$2^k$-1个结点</p><p>特点：</p><p>1.对给定的高度，满二叉树有最多结点</p><p>2.不存在度为1的结点</p><p>3.每个分支都有两颗高度相同的子树</p><p>4.叶子结点都在最后一层</p><p>(重点)<strong>完全二叉树</strong>：如果存在一颗二叉树，对树中结点自上而下，自左而右连续编号，若编号为i的结点的位置与满二叉树中i的结点的位置相同，则称此二叉树为完全二叉树。</p><p>特点：</p><p>1.叶子结点只可能在<strong>层树最大的两层</strong>上出现</p><p>2.对任意结点，若有右子树则必有左子树</p><p>3.具有n个结点的完全二叉树深度为$\lfloor log_2n\rfloor$+1（向下取整）或者$\lceil log_2(n+1)\rceil$(向上取整)</p><p>4.对于一个具有n个结点的完全二叉树，其结点按层序编号，则对任意结点k~i~(1$\leq$i$\leq$n)：</p><p>已知编号i(1$\leq$i$\leq$n)，双亲结点是$\lfloor i/2 \rfloor$</p><p>已知编号i(1$\leq$i$\leq$n/2)，左孩子结点为2i</p><p>已知编号i(1$\leq$i$\leq$(n-1)/2)，左孩子结点为2i+1</p><p>已知编号i(i为奇数,且1&lt;i&lt;n),左兄弟结点为i-1</p><p>已知编号i(i为偶数,且1&lt;i&lt;n),左兄弟结点为i+1</p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>利用完全二叉树的性质，可以将完全二叉树存入向量b[n]中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE];</span><br><span class="line">SqBiTree bt;<span class="comment">//和TElemType bt[100]相同</span></span><br></pre></td></tr></table></figure><p><img src="/2023/11/14/23-11-14/顺序存储结构.png" alt="image2"></p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>31</td><td>23</td><td>12</td><td>66</td><td>$\emptyset$</td><td>05</td><td>17</td><td>70</td><td>62</td><td>$\emptyset$</td><td>$\emptyset$</td><td>$\emptyset$</td><td>88</td><td>$\emptyset$</td><td>55</td></tr></tbody></table></div><p>顺序存储方式对于畸形二叉树，浪费空间</p><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p>每个结点中，设置两个链域指向左孩子和右孩子，一个数据域，若没有左孩子或右孩子，则指针指向NULL</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TElemType</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lch</span>,*<span class="title">rch</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><p>n个结点的二叉树中，共有n+1个空域</p><p>二叉链表很难找到双亲</p><p>三叉链表(带双亲的二叉链表) 含四个域：数据域，左指针域，右指针域，双亲域</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TElemType</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lch</span>,*<span class="title">rch</span>,*<span class="title">parent</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><h4 id="二叉树的生成"><a href="#二叉树的生成" class="headerlink" title="二叉树的生成"></a>二叉树的生成</h4><p>递归创建</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BiTNode* <span class="title">CreateBiTree</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n, <span class="type">int</span> &amp;i,<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;size&amp;&amp;a[i]!=n)</span><br><span class="line">    &#123;</span><br><span class="line">        BiTNode* newNode = <span class="built_in">InitBtNode</span>(a[i]);</span><br><span class="line">        i++;</span><br><span class="line">        newNode-&gt;lch = <span class="built_in">CreateBiTree</span>(a, n, i,size);</span><br><span class="line">        i++;</span><br><span class="line">        newNode-&gt;rch = <span class="built_in">CreateBiTree</span>(a, n, i,size);</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestoryBiTree</span><span class="params">(BiTree &amp;root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span>==root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DestoryBiTree(root-&gt;lch);</span><br><span class="line">    DestoryBiTree(root-&gt;rch);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>样例：<img src="/2023/11/14/23-11-14/遍历例子.png" alt="image3"></p><h4 id="前序遍历-先根遍历"><a href="#前序遍历-先根遍历" class="headerlink" title="前序遍历(先根遍历)"></a>前序遍历(先根遍历)</h4><p>1.若二叉树为空，则返回；</p><p>若不空：</p><p>2.访问根结点；</p><p>3.前序遍历左子树</p><p>4.前序遍历右子树</p><p><strong>先根，再左，后右</strong></p><p>遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 4 8 9 5 10 11 3 6 12 7</span><br></pre></td></tr></table></figure><p>前序遍历的第一个结点的是根结点，最后一个结点一定是叶子结点。</p><h4 id="中序遍历-中根遍历"><a href="#中序遍历-中根遍历" class="headerlink" title="中序遍历(中根遍历)"></a>中序遍历(中根遍历)</h4><p>1.若二叉树空，返回；</p><p>若不空：</p><p>2.中序遍历左子树；</p><p>3.访问根结点；</p><p>4.中序遍历右子树。</p><p><strong>先左，再根，后右</strong></p><p>遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 4 9 2 10 5 11 1 12 6 3 7</span><br></pre></td></tr></table></figure><p>第一个结点是最左边的结点，最后一个结点是最右边的结点，根结点位于左子树结点和右子树结点之间。</p><h4 id="后序遍历-后根遍历"><a href="#后序遍历-后根遍历" class="headerlink" title="后序遍历(后根遍历)"></a>后序遍历(后根遍历)</h4><p>1.若二叉树空，返回；</p><p>若不空：</p><p>2.中序遍历左子树；</p><p>3.后序遍历右子树；</p><p>4.访问根结点。</p><p><strong>先左，再右，后根</strong></p><p>遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 9 4 10 11 5 2 12 6 7 3 1</span><br></pre></td></tr></table></figure><p>后序遍历中最后一个结点是根结点</p><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><h4 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h4><p>先序遍历：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">    visit(T-&gt;data);<span class="comment">//遍历操作，可以是打印该结点的值</span></span><br><span class="line">    PreOrder(T-&gt;lch);</span><br><span class="line">    PreOrder(T-&gt;rch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T)&#123;</span><br><span class="line">    InOrder(T-&gt;lch);</span><br><span class="line">    visit(T-&gt;data);</span><br><span class="line">    InOrder(T-&gt;rch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T)&#123;</span><br><span class="line">    PostOrder(T-&gt;lch);</span><br><span class="line">    PostOrder(T-&gt;rch);</span><br><span class="line">    visit(T-&gt;data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h4><p>先序遍历：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTNode *root)</span></span>&#123;</span><br><span class="line">  BiTNode *p,*BiNode[MAX];</span><br><span class="line">  <span class="type">int</span> top=<span class="number">0</span>;p=root;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">      BiNode[top]=p;</span><br><span class="line">      top++;</span><br><span class="line">      p=p-&gt;lch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      top--;</span><br><span class="line">      p=BiNode[top];</span><br><span class="line">      p=p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">while</span>(top&gt;<span class="number">0</span>||p!=<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder_N</span><span class="params">(BiTree root)</span></span>&#123;</span><br><span class="line">    BiTNode *p,*BiNode[MAX];</span><br><span class="line">    <span class="type">int</span> top=<span class="number">0</span>;p=root;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>(root))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BiTree Empty!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            BiNode[top]=p;</span><br><span class="line">            top++;</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            top--;</span><br><span class="line">            p=BiNode[top];</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            p=p-&gt;rch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(top&gt;<span class="number">0</span>||p!=<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder_N</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTNode *p, *lastVisited = <span class="literal">NULL</span>;</span><br><span class="line">    BiTNode *stack[MAX];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>; <span class="comment">// 栈顶位置下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || top &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stack[++top] = p;</span><br><span class="line">            p = p-&gt;lch;</span><br><span class="line">        &#125;</span><br><span class="line">        p = stack[top];</span><br><span class="line">        <span class="comment">// 判断右子树是否已经访问过</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rch == <span class="literal">NULL</span> || p-&gt;rch == lastVisited)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            lastVisited = p;</span><br><span class="line">            top--;</span><br><span class="line">            p = <span class="literal">NULL</span>; <span class="comment">// 置空，防止重复访问</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;rch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="二叉树的其他操作"><a href="#二叉树的其他操作" class="headerlink" title="二叉树的其他操作"></a>二叉树的其他操作</h4><p>判断树是否空：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">(BiTree root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问结点操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(TElemType data)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,data.key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求结点数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">NodesNum</span><span class="params">(BiTNode *b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">NodesNum</span>(b-&gt;lch)+<span class="built_in">NodesNum</span>(b-&gt;rch)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求叶子结点数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LeafNodesNum</span><span class="params">(BiTNode *b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b-&gt;lch==<span class="literal">NULL</span>&amp;&amp;b-&gt;rch==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        num1=<span class="built_in">LeafNodesNum</span>(b-&gt;lch);</span><br><span class="line">        num2=<span class="built_in">LeafNodesNum</span>(b-&gt;rch);</span><br><span class="line">        <span class="keyword">return</span> (num1+num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制树的操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Copy</span><span class="params">(BiTNode *b,BiTNode *&amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>) t=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        t=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        t-&gt;data=b-&gt;data;</span><br><span class="line">        <span class="built_in">Copy</span>(b-&gt;lch, t-&gt;lch);</span><br><span class="line">        <span class="built_in">Copy</span>(b-&gt;rch,t-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交换左右子树：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(BiTNode *b,BiTNode *&amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>) t=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        t=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        t-&gt;data=b-&gt;data;</span><br><span class="line">        <span class="built_in">Swap</span>(b-&gt;lch, t-&gt;lch);</span><br><span class="line">        <span class="built_in">Swap</span>(b-&gt;rch,t-&gt;rch);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>求树的高度：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(BiTree t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tl,tr;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    tl=<span class="built_in">height</span>(t-&gt;lch);</span><br><span class="line">    tr=<span class="built_in">height</span>(t-&gt;rch);</span><br><span class="line">    <span class="keyword">if</span>(tl&gt;=tr) <span class="keyword">return</span> tl+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> tr+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>给定遍历序列是否可以确定树的唯一结构？</p><p>只给出一个序列，无法确定树的唯一结构</p><p>给出前序和后序序列，无法确定唯一的二叉树</p><p>给出中序和后序序列，可以确定唯一的二叉树</p><p>给出中序和前序序列，可以确定唯一的二叉树</p><p>问题：给出前序和中序序列，如何构建二叉树？</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateTree</span><span class="params">(BiTree &amp;T,<span class="type">int</span> root,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">char</span> *m,<span class="type">char</span> *n)</span>   <span class="comment">//创建二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T=(BiNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiNode));</span><br><span class="line">    <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=start;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;end&amp;&amp;n[i]!=m[root])</span><br><span class="line">        i++;</span><br><span class="line">    T-&gt;data=n[i];</span><br><span class="line">    <span class="built_in">CreateTree</span>(T-&gt;lch,root+<span class="number">1</span>,start,i<span class="number">-1</span>,m,n);</span><br><span class="line">    <span class="built_in">CreateTree</span>(T-&gt;rch,root+<span class="number">1</span>+i-start,i+<span class="number">1</span> ,end,m,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>既可以指示前驱又可以指示后继的双链结构的二叉树称为线索二叉树</p><p>若结点有左子树，则lch指示左孩子，否则指示其前驱</p><p>若结点有右子树，则rch指示其右孩子，否则指示其后继</p><h4 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构"></a>结点结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    datatype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lch</span>,*<span class="title">rch</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;threadbithptr,*BiThrTree;</span><br></pre></td></tr></table></figure><p>ltag=0 lch指向左孩子 ltag=1 lch指向前驱</p><p>ltag=0 rch指向右孩子 ltag=1 rch指向后继</p><h4 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h4><p>存储结构：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> *lch,*rch;</span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;threadbithptr,*BiThrTree;</span><br><span class="line">BiThrTree pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中序线索化：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        <span class="built_in">InThreading</span>(p-&gt;lch);</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;lch)&#123;</span><br><span class="line">            p-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">            p-&gt;lch=pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;rch)&#123;</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">            pre-&gt;rch=p;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;</span><br><span class="line">        <span class="built_in">InThreading</span>(p-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderThreading</span><span class="params">(BiThrTree &amp;Thrt,BiThrTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(Thrt=(threadbithptr*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(threadbithptr))))&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Thrt-&gt;ltag=<span class="number">0</span>;</span><br><span class="line">    Thrt-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    Thrt-&gt;rch=Thrt;</span><br><span class="line">    <span class="keyword">if</span>(!T)&#123;</span><br><span class="line">        Thrt-&gt;lch=Thrt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Thrt-&gt;lch=T;</span><br><span class="line">        pre=Thrt;</span><br><span class="line">        <span class="built_in">InThreading</span>(T);</span><br><span class="line">        pre-&gt;rch=Thrt;</span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">        Thrt-&gt;rch=pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中序线索树中查找结点*p的后继：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">threadbithptr* <span class="title">InOrderNext</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    threadbithptr *q;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q=p-&gt;rch;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">            q=q-&gt;lch;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraverseInthread</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            p=<span class="built_in">InOrderNext</span>(p);</span><br><span class="line">        &#125;<span class="keyword">while</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中序线索树中查找结点*p的前驱：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">threadbithptr* <span class="title">InOrderPre</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    threadbithptr *q;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;lch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q=p-&gt;lch;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">            q=q-&gt;rch;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历中序线索二叉树的非递归算法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraverseInthread</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            p=<span class="built_in">InOrderNext</span>(p);</span><br><span class="line">        &#125;<span class="keyword">while</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><h5 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h5><p>采用一组连续空间存储树的结点，通过保存每个结点的双亲结点的位置，表示树中结点关系的位置结构。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br></pre></td></tr></table></figure><h5 id="孩子链表表示法"><a href="#孩子链表表示法" class="headerlink" title="孩子链表表示法"></a>孩子链表表示法</h5><p>对树的每个结点用线性链表存储它的孩子结点。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CTNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> child;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">CTNode</span> *next;</span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">  <span class="type">int</span> parent;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  CTBox nodes[MAX];</span><br><span class="line">  <span class="type">int</span> n,r;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><h5 id="带双亲的孩子链表表示法"><a href="#带双亲的孩子链表表示法" class="headerlink" title="带双亲的孩子链表表示法"></a>带双亲的孩子链表表示法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CTNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> child;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">CTNode</span> *next;</span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">  <span class="type">int</span> parent;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  CTBox nodes[MAX];</span><br><span class="line">  <span class="type">int</span> n,r;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><h5 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CSNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CSNode</span> *firstchild,*firstbrother;</span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><h4 id="树、森林与二叉树的转化"><a href="#树、森林与二叉树的转化" class="headerlink" title="树、森林与二叉树的转化"></a>树、森林与二叉树的转化</h4><h5 id="树到二叉树"><a href="#树到二叉树" class="headerlink" title="树到二叉树"></a>树到二叉树</h5><p>1)在所有兄弟结点之间加一条连线。</p><p>2)对每个结点，除了保留与其长子的连线外，去掉该结点与其他孩子的连线。</p><h5 id="森林到二叉树"><a href="#森林到二叉树" class="headerlink" title="森林到二叉树"></a>森林到二叉树</h5><p>1)将森林中的每一棵树转化为二叉树</p><p>2)将各二叉树的根结点视为兄弟连在一起</p><h4 id="树的遍历-1"><a href="#树的遍历-1" class="headerlink" title="树的遍历"></a>树的遍历</h4><p>一般不中序遍历</p><p>两条路径：从左到右、从上到下</p><p><strong>树的前序遍历</strong>与转换成<strong>二叉树的前序遍历</strong>相同</p><p><strong>树的后序遍历</strong>与转换成<strong>二叉树的中序遍历</strong>相同</p><h3 id="赫夫曼树及其应用"><a href="#赫夫曼树及其应用" class="headerlink" title="赫夫曼树及其应用"></a>赫夫曼树及其应用</h3><p>基本概念</p><p>路径长度：路径上边的个数</p><p>树的路径长度：从根结点出发，到所有结点的路径长度之和</p><p>结点的带权路径长度：结点到根结点的长度与权重的乘积</p><p>树的带权路径长度：所有叶子结点的带权路径长度之和</p><h4 id="赫夫曼树的定义"><a href="#赫夫曼树的定义" class="headerlink" title="赫夫曼树的定义"></a>赫夫曼树的定义</h4><p>最优二叉树，给定叶结点权重，具有最小带权路径长度的二叉树。</p><h4 id="构造赫夫曼树-赫夫曼算法"><a href="#构造赫夫曼树-赫夫曼算法" class="headerlink" title="构造赫夫曼树(赫夫曼算法)"></a>构造赫夫曼树(赫夫曼算法)</h4><p>基本思想：使权值大的叶子结点尽量靠近根节点，而使权值小的叶子结点尽量远离根结点</p><p>将给定的一些叶子结点中取出两个最小的叶子作为一个结点的左孩子和右孩子，然后将它们的权值相加，从剩下的叶子中寻找最小的结点作为上面结点的兄弟，重复此操作。</p><p>n个叶结点，按上述操作，构造的树中含有2n-1个结点。</p><p><img src="/2023/11/14/23-11-14/赫夫曼树构造.png" alt="image4"></p><p>huffman算法实现：</p><p>主函数先给n，m赋值。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">    <span class="type">int</span> lch,rch,parent;</span><br><span class="line">&#125;hufmtree;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateHuffmanTree</span><span class="params">(hufmtree tree[])</span></span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        tree[i].weight=<span class="number">0.0</span>;</span><br><span class="line">        tree[i].lch=<span class="number">-1</span>;</span><br><span class="line">        tree[i].rch=<span class="number">-1</span>;</span><br><span class="line">        tree[i].parent=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputWeight</span><span class="params">(hufmtree tree[])</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> w;</span><br><span class="line">    <span class="type">float</span> small1,small2,f;</span><br><span class="line">    <span class="type">int</span> i,j,p1,p2;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n输入第%d个权值:&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;w);</span><br><span class="line">        tree[i].weight=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&lt;m;i++)&#123;<span class="comment">//把合并后的结点放入n～m向量</span></span><br><span class="line">        p1=<span class="number">0</span>;p2=<span class="number">0</span>;    <span class="comment">//两个根结点在tree中的下标</span></span><br><span class="line">        small1=MAXFLOAT;<span class="comment">//MAXFLOAT为最大浮点数</span></span><br><span class="line">        small2=MAXFLOAT;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i<span class="number">-1</span>;j++)&#123;<span class="comment">//选择两个最小的权</span></span><br><span class="line">            <span class="keyword">if</span>(tree[j].parent==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tree[j].weight&lt;small1)&#123;</span><br><span class="line">                    small2=small1;<span class="comment">//更新最小权，次小权，及其位置</span></span><br><span class="line">                    small1=tree[j].weight;<span class="comment">//找出最小权</span></span><br><span class="line">                    p2=p1;</span><br><span class="line">                    p1=j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tree[j].weight&lt;small2)&#123;</span><br><span class="line">                    small2=tree[j].weight;<span class="comment">//改变次小权及位置</span></span><br><span class="line">                    p2=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[p1].parent=i+<span class="number">1</span>;</span><br><span class="line">        tree[p2].parent=i+<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//将新生成的结点放在tree[i+1]</span></span><br><span class="line">        tree[i+<span class="number">1</span>].lch=p1;</span><br><span class="line">        tree[i+<span class="number">1</span>].rch=p2;</span><br><span class="line">        tree[i+<span class="number">1</span>].weight=tree[p1].weight+tree[p1].weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h4><p>1)首先构造出赫夫曼树</p><p>2)每个结点的左分支计0 右分支计1，从根结点到叶子结点的沿途路径分支组成的01代码串即赫夫曼编码</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>个人博客基本部署成功！</title>
      <link href="/2023/11/09/successcd-blog-lincoxi/"/>
      <url>/2023/11/09/successcd-blog-lincoxi/</url>
      
        <content type="html"><![CDATA[<p>11.09日我的博客基本部署成功了，有一些基本的美化功能（借鉴各路大佬）<br>接下来预计将会逐步完善各项功能，留言板已开，可以多多留言<br>预计接下来会发布内容关于：<br>1.ctf题目/工具解答 本人misc做的多点，预计一个月内发布一篇misc工具合集介绍。<br>2.学校的课程内容，主要是为了复习+记录。<br>3.个人日常板块还没做，迟早会发。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>a basic test</title>
      <link href="/2023/11/09/a-basic-test/"/>
      <url>/2023/11/09/a-basic-test/</url>
      
        <content type="html"><![CDATA[<p>test test tes</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>今日测试</title>
      <link href="/2023/11/09/11-9work/"/>
      <url>/2023/11/09/11-9work/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="314b778ccd1012cad8846435536f091270f2b36b97591be73fd3ae3f00163cdd">10d79030e8222445804370796b90fca18d3af0ca0aed65002f2d27e5161276f9a34ce6f47914fa2d3c77a4530036ebbf49392c613893bc04a4747ee94fb4d5f88c16dc93152c4f00c0ef25a2ae27d29cd3b7a1c8f2dba4224c6e826413ea97a1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>work_12.11</title>
      <link href="/2023/11/09/work-12-11/"/>
      <url>/2023/11/09/work-12-11/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4237b5ab9b62ff40e91ec2f2339630465adbd8b2917c54802b887802653cdc78">01c5434afc057ec70c0b06aa0591fac6feaac8ea76c74c2a16a82314c7311e3d7a8f6737cf7b5c9038c6896dbf539075414845885f166cbc4c60fc4e2685be30b483fc1b39384fa2edc582211d27467ff62aac53660ebd6b7cbe4aff2b8872e220eb40bd790ff5838c8e22b6a2b2e12cafa1ba3d29e51f2b55cbeab4c022e21298cf2583bbf44aa28cd5bb30cdc842aa07134361303d2e403741d7cee9bc62af</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">需要密码！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test4blog</title>
      <link href="/2023/11/08/test4blog/"/>
      <url>/2023/11/08/test4blog/</url>
      
        <content type="html"><![CDATA[<p>This is a test for lincoxi to test if his blog works ok.</p><p>My github account is cyan4run. It’s easy to recongnize.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/08/hello-world/"/>
      <url>/2023/11/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
